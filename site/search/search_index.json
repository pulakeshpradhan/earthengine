{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"What is Google Earth Engine?","text":"<p>Google Earth Engine (GEE) is like having a supercomputer that can analyze satellite images of Earth. It's completely free and runs in your web browser.</p> <p>Up-to-Date Information</p> <p>This guide uses the latest satellite data and best practices, so you're learning the most current methods.</p>"},{"location":"#what-youll-learn","title":"What You'll Learn","text":"<p>This course takes you from complete beginner to someone who can analyze Earth from space. Here's what we'll cover:</p>"},{"location":"#getting-started-modules-1-2","title":"Getting Started (Modules 1-2)","text":"What You'll Do Topics Covered Set Up Your Account Creating a free GEE account, understanding the interface Your First Analysis Viewing satellite images, filtering by date and location Basic Operations Combining images, cutting them to your area of interest Time-Series Charts Creating charts that show changes over time"},{"location":"#understanding-data-modules-3-5","title":"Understanding Data (Modules 3-5)","text":"What You'll Do Topics Covered Image Charts Histograms (data distribution), scatter plots, area calculations Map Charts Pie charts and column charts for geographic data Advanced Visualization Creating professional charts and exporting your results"},{"location":"#real-world-applications-modules-6-10","title":"Real-World Applications (Modules 6-10)","text":"What You'll Do Topics Covered Water Mapping Finding water bodies, tracking changes, converting images to maps Rainfall Analysis Calculating precipitation, finding trends over time Land Classification Identifying forests, cities, farmland automatically Flood Mapping Using radar data to map flooded areas Drought Monitoring Tracking vegetation health and drought conditions"},{"location":"#advanced-skills-modules-11-12","title":"Advanced Skills (Modules 11-12)","text":"What You'll Do Topics Covered Creating Apps Building interactive web apps others can use Statistical Analysis Calculating averages, totals, and statistics for regions"},{"location":"#key-topics-explained-simply","title":"Key Topics Explained Simply","text":"<p>Here's what you'll master, organized by topic:</p> Topic What It Means Introduction to GEE What it is, why it's useful, how to navigate Account Setup Creating your account, getting access Basic Programming Simple coding concepts (don't worry, we explain everything!) Understanding Images How satellite images work, what the colors mean Working with Maps Using boundaries, shapes, and geographic features Projections How flat maps represent our round Earth Drawing Shapes Creating points, lines, and areas on maps Satellite Images Working with different types of satellite data Map Features Filtering and organizing geographic information Visualization Making your data look good with colors and legends Image Cleanup Removing clouds and improving image quality Time Analysis Combining images from different dates Vegetation Indices Measuring plant health and water content Advanced Analysis Professional techniques for complex projects Change Detection Seeing how places have changed over time Spatial Operations Measuring distances, combining datasets Statistics Calculating averages and patterns Classification Automatically identifying land types Water Studies Detecting water, mapping floods Agriculture Monitoring crops and farmland Disasters Assessing damage from floods, fires, storms Python Integration Using Python instead of JavaScript (optional) App Building Creating tools others can use"},{"location":"#what-makes-this-different","title":"What Makes This Different?","text":"<ul> <li>Plain English - We avoid jargon and explain everything clearly</li> <li>Step-by-Step - Each lesson builds on the previous one</li> <li>Real Examples - Every concept includes working code you can try</li> <li>Modern Tools - We use the latest satellite data and techniques</li> <li>Free Forever - Google Earth Engine is completely free to use</li> </ul> <p>Ready to start? Let's set up your account!</p> <p>Next: Sign Up &amp; Setup \u2192</p>"},{"location":"gee/Debugging/","title":"Google Earth Engine Debugging","text":""},{"location":"gee/Debugging/#note","title":"\ud83e\udd14 Note:","text":"<p>These points help with understanding common debugging scenarios and tools for effective debugging in Earth Engine.</p> <ul> <li> <p>Syntax Errors: Syntax errors occur when the code doesn\u2019t follow JavaScript or Python syntax rules, often highlighted by Earth Engine before execution.   <pre><code>// Syntax Error Example: Missing closing parenthesis\nvar image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318'\nprint(image);\n// Fix\nvar imageCorrect = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');\nprint(imageCorrect);\n</code></pre></p> </li> <li> <p>Client-side Errors: Even with syntactically correct code, errors can occur due to logic issues or variable scope limitations (e.g., undefined variables or invalid method calls).</p> </li> </ul> <pre><code>// Example: Undefined variable error\nvar area = length * width; // 'length' and 'width' are undefined\n// Fix\nvar length = 10;\nvar width = 5;\nvar areaCorrect = length * width;\n</code></pre> <ul> <li>Unknown Object Type Casting: Errors often arise when Earth Engine cannot recognize a variable's type. Solution: Cast objects explicitly.</li> </ul> <p><pre><code>// Example: Casting to a known type\nvar feature = ee.Feature(null, {name: 'Test Feature'});\nvar area = feature.get('area'); // Causes error if 'area' isn't present\n</code></pre> - Debugging Methods: Use methods like <code>print()</code>, <code>aside()</code>, and <code>Map.addLayer()</code> to inspect intermediate values and identify issues. Isolate functions and test on individual elements from collections.</p> <pre><code>// Example: Using `aside()` for debugging\nvar image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');\nvar bandNames = image.bandNames().aside(print); // Prints band names for inspection\n</code></pre>"},{"location":"gee/Debugging/#caution","title":"\u26a0\ufe0f Caution:","text":"<p>These points require extra care during development to prevent errors due to the unique server-client structure of Earth Engine.</p> <ul> <li>Server-side Errors: Earth Engine errors often arise when accessing non-existent bands in an image, or performing operations on unsupported data types.</li> </ul> <p><pre><code>// Example: Accessing a non-existent band\nvar image = ee.Image('COPERNICUS/S2/20190830T104031_20190830T104033_T31TFJ');\nvar ndvi = image.normalizedDifference(['B4', 'B8']); // Sentinel-2 NDVI\nprint(ndvi); // Ensure both bands are present\n</code></pre> - Immutability of Server-side Objects: Objects in Earth Engine are immutable. To make changes, you must assign them to new variables rather than modifying existing ones.</p> <p><pre><code>// Example: Reassigning after operation\nvar image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');\nvar scaledImage = image.multiply(2); // Assign to new variable\n</code></pre> - Scaling Errors: Errors like \"computation timed out\" or \"user memory limit exceeded\" are due to large-scale computations. Check Profiler to diagnose and simplify operations if needed.</p> <pre><code>// Example: Reduce region or scale to avoid scaling errors\nvar reducedRegion = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: image.geometry(),\n  scale: 1000 // Adjust scale to manage computation\n});\nprint(reducedRegion);\n</code></pre>"},{"location":"gee/Debugging/#avoid","title":"\u274c Avoid:","text":"<p>Avoid these common pitfalls that can lead to unexpected results or execution failures.</p> <ul> <li>Mixing Client and Server Functions: Avoid mixing Earth Engine (server-side) objects with JavaScript (client-side) operations.</li> </ul> <p><pre><code>// Incorrect: Mixing client-side with server-side\nvar clientNumber = 2;\nvar eeNumber = ee.Number(10);\nvar result = eeNumber * clientNumber; // Causes error\n\n// Fix: Convert client-side variable to server-side\nvar resultCorrect = eeNumber.multiply(ee.Number(clientNumber));\n</code></pre> - Browser Lock (Avoid <code>for Loops</code> and <code>getInfo()</code>): Using getInfo() on large data can freeze the browser. Avoid for loops over Earth Engine collections as it forces client-side evaluation.</p> <p><pre><code>// Incorrect: Using getInfo() on a large collection\nvar collection = ee.ImageCollection('LANDSAT/LC08/C01/T1_TOA');\nvar size = collection.size().getInfo(); // Potentially freezes browser\n\n// Fix: Avoid getInfo() for large collections\ncollection.size().aside(print);\n</code></pre> - Mapped Functions with Client-side Operations: Ensure mapped functions only include server-side operations, as client-side operations inside mapped functions will cause errors.</p> <p><pre><code>// Incorrect: Using client-side math in a mapped function\nvar collection = ee.ImageCollection('COPERNICUS/S2');\nvar doubledCollection = collection.map(function(img) {\n  return img.multiply(2); // This is correct as it's server-side\n});\n</code></pre> - Procedural Errors: Applying incompatible functions, such as operations on images without the required bands.</p>"},{"location":"gee/Debugging/#incorrect-attempting-to-calculate-ndvi-on-an-image-without-bands-var-emptyimage-eeimage-no-bands-var-ndvi-emptyimagenormalizeddifferenceb4-b5-error-fix-check-for-bands-first-var-bandcheck-emptyimagebandnames-bandcheckevaluatefunctionbands-if-bandslength-0-var-ndvicorrect-emptyimagenormalizeddifferenceb4-b5-else-printno-bands-available-for-ndvi-calculation","title":"<pre><code>// Incorrect: Attempting to calculate NDVI on an image without bands\nvar emptyImage = ee.Image([]); // No bands\nvar ndvi = emptyImage.normalizedDifference(['B4', 'B5']); // Error\n\n// Fix: Check for bands first\nvar bandCheck = emptyImage.bandNames();\nbandCheck.evaluate(function(bands) {\n  if (bands.length &gt; 0) {\n    var ndviCorrect = emptyImage.normalizedDifference(['B4', 'B5']);\n  } else {\n    print(\"No bands available for NDVI calculation.\");\n  }\n});\n</code></pre>","text":""},{"location":"gee/Debugging/#projection-in-earth-engine","title":"Projection in Earth Engine","text":""},{"location":"gee/Debugging/#caution_1","title":"\u26a0\ufe0f Caution:","text":"<ul> <li>Automatic Projection Handling: Earth Engine automatically assigns projections (e.g., Web Mercator) for visualizations. Explicitly set projections only if needed to avoid unexpected results.</li> <li>Default Output Projection: When combining images with different projections, the default output is WGS84 (EPSG:4326) with a 1\u00b0 scale, which may not suit high-resolution analyses. https://epsg.io/</li> <li>Reprojection and Data Requests: When using <code>reproject()</code>, requesting data at scales finer than the current zoom level can result in excessive data usage.</li> </ul>"},{"location":"gee/Debugging/#avoid_1","title":"\u274c Avoid:","text":"<ul> <li>Leaving Projections Unspecified: Ensure projections are defined, especially with <code>ImageCollection</code>, to prevent inconsistencies.</li> <li>Frequent Reprojection Calls: Overuse of <code>reproject()</code> can decrease performance due to redundant reprojections.</li> <li>Mixing Projections: When using images with different projections in a single computation, ensure they\u2019re properly handled to avoid errors.</li> </ul>"},{"location":"gee/Debugging/#note_1","title":"\ud83e\udd14 Note:","text":"<ul> <li>Checking Projection Information: Use image.projection() to retrieve an image's projection.   <pre><code>var image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select(0);\nprint('Projection:', image.projection());\nprint('Scale in meters:', image.projection().nominalScale());\n</code></pre></li> <li> <p>Composites and Projections: Default to WGS84 when combining differently projected images.   <pre><code>var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA');\nvar mosaic = collection.filterDate('2018-01-01', '2019-01-01').mosaic();\nprint(mosaic.projection());\n</code></pre></p> </li> <li> <p>Specifying Projection: Use reproject() for fixed projections.   <pre><code>var proj = ee.Projection('EPSG:4326');\nvar output = collection.reduce(...).reproject(proj);\n</code></pre> For specific analysis needs, such as gradients, a fixed projection may be required.</p> </li> </ul>"},{"location":"gee/Debugging/#code-example-for-reprojecting-and-calculating-slope-in-earth-engine","title":"Code Example for Reprojecting and Calculating Slope in Earth Engine","text":"<ul> <li>Use of <code>ee.Image.reproject</code> is rarely needed and should generally be <code>avoided</code>.</li> <li>Define projection and scale with \"scale\", \"crs\", and \"crsTransform\" when available.</li> <li>Use <code>reproject()</code> only if alternative methods aren\u2019t suitable. Below, it\u2019s used to calculate terrain slope from a DEM composite at a desired scale.</li> </ul> <pre><code>// Load DEM datasets and calculate mean elevation (defaults to WGS84, 1 degree pixels).\nvar dem1 = ee.Image('NASA/NASADEM_HGT/001').select('elevation');\nvar dem2 = ee.Image('CGIAR/SRTM90_V4').select('elevation');\nvar demMean = ee.ImageCollection([dem1, dem2]).mean();\n\n// Display the DEMs on the map\nvar demVisParams = {min: 500, max: 2500};\nMap.setCenter(-123.457, 47.815, 11);\nMap.addLayer(dem1, demVisParams, 'DEM 1');\nMap.addLayer(dem2, demVisParams, 'DEM 2');\nMap.addLayer(demMean, demVisParams, 'DEM composite');\n\n// Calculate terrain slope from the composite DEM (WGS84, 1 degree pixel scale).\nvar demCompSlope = ee.Terrain.slope(demMean);\n\n// Display slope (1 degree scale; zoom out to see pixels).\nMap.addLayer(demCompSlope, {min: 0, max: 0.3}, 'Slope');\n</code></pre>"},{"location":"gee/Debugging/#httpsepsgio","title":"https://epsg.io/","text":"<pre><code>// Force slope calculation at 30m scale on WGS84 CRS with reproject().\nvar slopeScale = ee.Terrain.slope(\n  demMean.reproject({\n    crs: 'EPSG:4326',\n    scale: 30\n  })\n);\nMap.addLayer(slopeScale, {min: 0, max: 45}, 'Slope w/ CRS and scale');\n\n// Control reprojection more precisely using \"crsTransform\" or match a reference image projection.\nvar nasademProj = dem1.projection();\nvar demMeanReproj = demMean.reproject(nasademProj);\nvar slopeRefProj = ee.Terrain.slope(demMeanReproj);\nMap.addLayer(slopeRefProj, {min: 0, max: 45}, 'Slope w/ reference proj');\nprint('Reference projection', nasademProj);\nprint('DEM composite projection', demMeanReproj.projection());\n\n// Alternative to reproject(): set default projection with setDefaultProjection().\nvar demMeanProj = ee.ImageCollection([dem1, dem2]).mean()\n                      .setDefaultProjection(nasademProj);\nvar slopeProj = ee.Terrain.slope(demMeanProj);\nMap.addLayer(slopeProj, {min: 0, max: 45}, 'slope w/ default projection set');\n</code></pre> <p>\ud83e\udd14 Note: \u26a0\ufe0f Caution:  \u274c Avoid: </p>"},{"location":"gee/code_examples/","title":"GEE Code Examples: JavaScript &amp; Python","text":"<p>This page shows common Google Earth Engine operations in both JavaScript and Python. Use the tabs to switch between languages.</p>"},{"location":"gee/code_examples/#basic-operations","title":"Basic Operations","text":""},{"location":"gee/code_examples/#loading-an-image","title":"Loading an Image","text":"JavaScriptPython <pre><code>// Load a single Landsat 8 image\nvar image = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318');\nprint('Image:', image);\n</code></pre> <pre><code># Load a single Landsat 8 image\nimage = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318')\nprint('Image:', image)\n</code></pre>"},{"location":"gee/code_examples/#loading-an-image-collection","title":"Loading an Image Collection","text":"JavaScriptPython <pre><code>// Load Sentinel-2 image collection\nvar collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')\n  .filterDate('2023-01-01', '2023-12-31')\n  .filterBounds(ee.Geometry.Point([-122.4, 37.8]));\n\nprint('Number of images:', collection.size());\n</code></pre> <pre><code># Load Sentinel-2 image collection\ncollection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') \\\n    .filterDate('2023-01-01', '2023-12-31') \\\n    .filterBounds(ee.Geometry.Point([-122.4, 37.8]))\n\nprint('Number of images:', collection.size().getInfo())\n</code></pre>"},{"location":"gee/code_examples/#creating-geometries","title":"Creating Geometries","text":"JavaScriptPython <pre><code>// Create a point\nvar point = ee.Geometry.Point([-122.4194, 37.7749]);\n\n// Create a rectangle\nvar rectangle = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]);\n\n// Create a polygon\nvar polygon = ee.Geometry.Polygon([\n  [[-122.5, 37.5], [-122.5, 38.0], [-122.0, 38.0], \n   [-122.0, 37.5], [-122.5, 37.5]]\n]);\n</code></pre> <pre><code># Create a point\npoint = ee.Geometry.Point([-122.4194, 37.7749])\n\n# Create a rectangle\nrectangle = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0])\n\n# Create a polygon\npolygon = ee.Geometry.Polygon([\n    [[-122.5, 37.5], [-122.5, 38.0], [-122.0, 38.0], \n     [-122.0, 37.5], [-122.5, 37.5]]\n])\n</code></pre>"},{"location":"gee/code_examples/#filtering-data","title":"Filtering Data","text":""},{"location":"gee/code_examples/#filter-by-date-and-location","title":"Filter by Date and Location","text":"JavaScriptPython <pre><code>var roi = ee.Geometry.Point([-122.4, 37.8]);\n\nvar filtered = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n  .filterDate('2023-06-01', '2023-08-31')\n  .filterBounds(roi)\n  .filter(ee.Filter.lt('CLOUD_COVER', 10));\n\nprint('Filtered images:', filtered.size());\n</code></pre> <pre><code>roi = ee.Geometry.Point([-122.4, 37.8])\n\nfiltered = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \\\n    .filterDate('2023-06-01', '2023-08-31') \\\n    .filterBounds(roi) \\\n    .filter(ee.Filter.lt('CLOUD_COVER', 10))\n\nprint('Filtered images:', filtered.size().getInfo())\n</code></pre>"},{"location":"gee/code_examples/#image-operations","title":"Image Operations","text":""},{"location":"gee/code_examples/#calculate-ndvi","title":"Calculate NDVI","text":"JavaScriptPython <pre><code>// Load an image\nvar image = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318');\n\n// Calculate NDVI\nvar ndvi = image.normalizedDifference(['SR_B5', 'SR_B4'])\n  .rename('NDVI');\n\n// Display on map\nMap.centerObject(image, 8);\nMap.addLayer(ndvi, {min: -1, max: 1, palette: ['blue', 'white', 'green']}, 'NDVI');\n</code></pre> <pre><code># Load an image\nimage = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318')\n\n# Calculate NDVI\nndvi = image.normalizedDifference(['SR_B5', 'SR_B4']) \\\n    .rename('NDVI')\n\n# Display on map (using geemap)\nimport geemap\nMap = geemap.Map()\nMap.centerObject(image, 8)\nMap.addLayer(ndvi, {'min': -1, 'max': 1, 'palette': ['blue', 'white', 'green']}, 'NDVI')\nMap\n</code></pre>"},{"location":"gee/code_examples/#band-math","title":"Band Math","text":"JavaScriptPython <pre><code>// Select bands\nvar nir = image.select('SR_B5');\nvar red = image.select('SR_B4');\n\n// Calculate using expression\nvar ndvi = image.expression(\n  '(NIR - RED) / (NIR + RED)', {\n    'NIR': nir,\n    'RED': red\n  }\n);\n</code></pre> <pre><code># Select bands\nnir = image.select('SR_B5')\nred = image.select('SR_B4')\n\n# Calculate using expression\nndvi = image.expression(\n    '(NIR - RED) / (NIR + RED)', {\n        'NIR': nir,\n        'RED': red\n    }\n)\n</code></pre>"},{"location":"gee/code_examples/#working-with-collections","title":"Working with Collections","text":""},{"location":"gee/code_examples/#map-function","title":"Map Function","text":"JavaScriptPython <pre><code>// Function to calculate NDVI for each image\nfunction addNDVI(image) {\n  var ndvi = image.normalizedDifference(['SR_B5', 'SR_B4'])\n    .rename('NDVI');\n  return image.addBands(ndvi);\n}\n\n// Apply to collection\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n  .filterDate('2023-01-01', '2023-12-31')\n  .map(addNDVI);\n</code></pre> <pre><code># Function to calculate NDVI for each image\ndef add_ndvi(image):\n    ndvi = image.normalizedDifference(['SR_B5', 'SR_B4']) \\\n        .rename('NDVI')\n    return image.addBands(ndvi)\n\n# Apply to collection\ncollection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \\\n    .filterDate('2023-01-01', '2023-12-31') \\\n    .map(add_ndvi)\n\n# Or using lambda\ncollection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \\\n    .filterDate('2023-01-01', '2023-12-31') \\\n    .map(lambda img: img.addBands(\n        img.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI')\n    ))\n</code></pre>"},{"location":"gee/code_examples/#reduce-collection","title":"Reduce Collection","text":"JavaScriptPython <pre><code>// Calculate median composite\nvar median = collection.median();\n\n// Calculate mean\nvar mean = collection.mean();\n\n// Calculate min and max\nvar minMax = collection.reduce(ee.Reducer.minMax());\n</code></pre> <pre><code># Calculate median composite\nmedian = collection.median()\n\n# Calculate mean\nmean = collection.mean()\n\n# Calculate min and max\nminMax = collection.reduce(ee.Reducer.minMax())\n</code></pre>"},{"location":"gee/code_examples/#statistics","title":"Statistics","text":""},{"location":"gee/code_examples/#reduce-region","title":"Reduce Region","text":"JavaScriptPython <pre><code>var region = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]);\n\nvar stats = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: region,\n  scale: 30,\n  maxPixels: 1e9\n});\n\nprint('Mean values:', stats);\n</code></pre> <pre><code>region = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0])\n\nstats = image.reduceRegion(\n    reducer=ee.Reducer.mean(),\n    geometry=region,\n    scale=30,\n    maxPixels=1e9\n)\n\nprint('Mean values:', stats.getInfo())\n</code></pre>"},{"location":"gee/code_examples/#exporting-data","title":"Exporting Data","text":""},{"location":"gee/code_examples/#export-image","title":"Export Image","text":"JavaScriptPython <pre><code>Export.image.toDrive({\n  image: ndvi,\n  description: 'NDVI_Export',\n  scale: 30,\n  region: region,\n  fileFormat: 'GeoTIFF'\n});\n</code></pre> <pre><code>task = ee.batch.Export.image.toDrive(\n    image=ndvi,\n    description='NDVI_Export',\n    scale=30,\n    region=region,\n    fileFormat='GeoTIFF'\n)\ntask.start()\n</code></pre>"},{"location":"gee/code_examples/#export-table","title":"Export Table","text":"JavaScriptPython <pre><code>var features = ee.FeatureCollection([\n  ee.Feature(point, {name: 'Point 1', value: 100})\n]);\n\nExport.table.toDrive({\n  collection: features,\n  description: 'Features_Export',\n  fileFormat: 'CSV'\n});\n</code></pre> <pre><code>features = ee.FeatureCollection([\n    ee.Feature(point, {'name': 'Point 1', 'value': 100})\n])\n\ntask = ee.batch.Export.table.toDrive(\n    collection=features,\n    description='Features_Export',\n    fileFormat='CSV'\n)\ntask.start()\n</code></pre>"},{"location":"gee/code_examples/#key-syntax-differences","title":"Key Syntax Differences","text":"Operation JavaScript Python Print to console <code>print(value)</code> <code>print(value.getInfo())</code> Variable <code>var x = 5</code> <code>x = 5</code> Function <code>function name() {}</code> <code>def name():</code> Anonymous function <code>function(x) {return x}</code> <code>lambda x: x</code> Dictionary <code>{key: value}</code> <code>{'key': value}</code> Boolean <code>true</code>, <code>false</code> <code>True</code>, <code>False</code> Line continuation <code>;</code> (optional) <code>\\</code> (for multi-line) Comments <code>// comment</code> <code># comment</code> <p>Tip: Most GEE functions work the same in both languages. The main differences are in syntax, not functionality!</p>"},{"location":"gee/gee_syntax/","title":"Commonly Used GEE Syntax Reference","text":""},{"location":"gee/gee_syntax/#goto-online-version-for-copy-the-codes-click-here","title":"Goto Online Version for Copy the Codes Click Here","text":"<p>This document provides a comprehensive reference for commonly used Google Earth Engine (GEE) syntax and functions, organized by category with detailed examples.</p>"},{"location":"gee/gee_syntax/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Basic Display &amp; Visualization</li> <li>Map.addLayer()</li> <li>Map.centerObject()</li> <li>print()</li> <li>Map.setCenter()</li> <li>Map.add()</li> <li>Loading Datasets</li> <li>ee.Image()</li> <li>ee.ImageCollection()</li> <li>ee.FeatureCollection()</li> <li>ee.Image() (DEM)</li> <li>Filtering Data</li> <li>filterDate()</li> <li>filterBounds()</li> <li>filter()</li> <li>Mathematical &amp; Band Operations</li> <li>normalizedDifference()</li> <li>select()</li> <li>add()</li> <li>multiply()</li> <li>Geometry &amp; Feature Collection Operations</li> <li>ee.Geometry.Point()</li> <li>ee.Geometry.Polygon()</li> <li>ee.FeatureCollection()</li> <li>filterBounds()</li> <li>Reducing &amp; Statistics</li> <li>reduce(ee.Reducer.mean())</li> <li>reduce(ee.Reducer.minMax())</li> <li>reduce(ee.Reducer.sum())</li> <li>reduceRegion()</li> <li>Exporting Data</li> <li>Export.image.toDrive()</li> <li>Export.table.toDrive()</li> <li>Export.image.toAsset()</li> <li>Miscellaneous</li> <li>ee.Algorithms.If()</li> <li>clip()</li> <li>median()</li> <li>toList().get()</li> <li>Best Practices</li> <li>Projection and Scale Best Practices</li> </ol>"},{"location":"gee/gee_syntax/#basic-display-visualization","title":"Basic Display &amp; Visualization","text":"<p>Functions for visualizing data and controlling the map display</p>"},{"location":"gee/gee_syntax/#mapaddlayerimage-visparams-name","title":"Map.addLayer(image, visParams, name)","text":"<p>Adds an image/layer to the map.</p> <p>Example:</p> <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Define visualization parameters\nvar visParams = {\n  bands: ['B4', 'B3', 'B2'],  // Use Red, Green, Blue bands\n  min: 0,                     // Minimum value for display\n  max: 0.3,                   // Maximum value for display\n  gamma: 1.4                  // Gamma correction\n};\n\n// Add the image to the map\nMap.addLayer(landsat, visParams, 'Landsat 8 RGB');\n\n// Add a single band with a different color palette\nMap.addLayer(landsat.select('B5'), \n  {min: 0, max: 0.4, palette: ['blue', 'green', 'red']}, \n  'NIR Band');\n</code></pre>"},{"location":"gee/gee_syntax/#mapcenterobjectobject-zoom","title":"Map.centerObject(object, zoom)","text":"<p>Centers the map on a feature/geometry/image.</p> <p>Example:</p> <pre><code>// Create a point for San Francisco\nvar sanFrancisco = ee.Geometry.Point([-122.4193, 37.7749]);\n\n// Center the map on the point with zoom level 10\nMap.centerObject(sanFrancisco, 10);\n\n// Center on a feature collection with automatic zoom\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nvar brazil = countries.filter(ee.Filter.eq('country_na', 'Brazil'));\nMap.centerObject(brazil);\n</code></pre>"},{"location":"gee/gee_syntax/#printvariable","title":"print(variable)","text":"<p>Prints a variable to the Console.</p> <p>Example:</p> <pre><code>// Print a simple message\nprint('Hello Earth Engine!');\n\n// Print an Earth Engine object\nvar image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nprint('Landsat Image:', image);\n\n// Print properties of an image\nprint('Image Bands:', image.bandNames());\nprint('Image Projection:', image.projection());\n\n// Print a dictionary\nvar stats = {min: 0, max: 255, mean: 127.5};\nprint('Statistics:', stats);\n</code></pre>"},{"location":"gee/gee_syntax/#mapsetcenterlon-lat-zoom","title":"Map.setCenter(lon, lat, zoom)","text":"<p>Centers the map at a specific latitude and longitude.</p> <p>Example:</p> <pre><code>// Center the map on Tokyo, Japan with zoom level 8\nMap.setCenter(139.6917, 35.6895, 8);\n\n// Center on the Amazon Rainforest with a closer zoom\nMap.setCenter(-60.5, -3.0, 6);\n</code></pre>"},{"location":"gee/gee_syntax/#mapadduilabeltext","title":"Map.add(ui.Label('Text'))","text":"<p>Adds a UI label to the map.</p> <p>Example:</p> <pre><code>// Create a simple label\nvar simpleLabel = ui.Label('This is a map label');\nMap.add(simpleLabel);\n\n// Create a styled label\nvar styledLabel = ui.Label({\n  value: 'NDVI Analysis Results',\n  style: {\n    fontWeight: 'bold',\n    fontSize: '18px',\n    margin: '10px',\n    padding: '8px',\n    backgroundColor: 'rgba(255, 255, 255, 0.8)'\n  }\n});\nMap.add(styledLabel);\n\n// Create a panel with multiple labels\nvar panel = ui.Panel({\n  style: {\n    position: 'top-left',\n    padding: '8px',\n    width: '300px'\n  }\n});\npanel.add(ui.Label('Vegetation Analysis'));\npanel.add(ui.Label('Data source: Landsat 8'));\nMap.add(panel);\n</code></pre> <p>Back to top</p>"},{"location":"gee/gee_syntax/#loading-datasets","title":"Loading Datasets","text":"<p>Functions for loading satellite imagery, collections, and vector data</p>"},{"location":"gee/gee_syntax/#var-image-eeimagecopernicuss2_sr20220101t000000_20220101t000000","title":"var image = ee.Image('COPERNICUS/S2_SR/20220101T000000_20220101T000000')","text":"<p>Loads a satellite image.</p> <p>Example:</p> <pre><code>// Load a specific Sentinel-2 surface reflectance image\nvar sentinel2Image = ee.Image('COPERNICUS/S2_SR/20220101T104429_20220101T104426_T31TFJ');\nprint('Sentinel-2 Image:', sentinel2Image);\n\n// Load a Landsat 8 image\nvar landsat8Image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_123032_20210615');\nprint('Landsat 8 Image:', landsat8Image);\n\n// Load a MODIS image\nvar modisImage = ee.Image('MODIS/006/MOD13A2/2022_01_01');\nprint('MODIS Image:', modisImage);\n\n// Access image properties\nprint('Acquisition date:', sentinel2Image.get('system:time_start'));\nprint('Cloud cover percentage:', sentinel2Image.get('CLOUDY_PIXEL_PERCENTAGE'));\n</code></pre>"},{"location":"gee/gee_syntax/#var-collection-eeimagecollectioncopernicuss2","title":"var collection = ee.ImageCollection('COPERNICUS/S2')","text":"<p>Loads an image collection.</p> <p>Example:</p> <pre><code>// Load the Sentinel-2 image collection\nvar sentinel2Collection = ee.ImageCollection('COPERNICUS/S2');\nprint('Sentinel-2 Collection:', sentinel2Collection);\n\n// Load the MODIS NDVI collection\nvar modisNDVI = ee.ImageCollection('MODIS/006/MOD13Q1');\nprint('MODIS NDVI Collection:', modisNDVI);\n\n// Load Landsat 8 collection\nvar landsat8Collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA');\nprint('Landsat 8 Collection:', landsat8Collection);\n\n// Get collection metadata\nprint('Number of images in collection:', sentinel2Collection.size());\nprint('Collection date range:', sentinel2Collection.date());\n</code></pre>"},{"location":"gee/gee_syntax/#var-feature-eefeaturecollectionfaogaul2015level1","title":"var feature = ee.FeatureCollection('FAO/GAUL/2015/level1')","text":"<p>Loads a feature collection (vector data).</p> <p>Example:</p> <pre><code>// Load country boundaries\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nprint('Countries:', countries);\n\n// Load administrative boundaries (level 1 - states/provinces)\nvar adminLevel1 = ee.FeatureCollection('FAO/GAUL/2015/level1');\nprint('Admin Level 1:', adminLevel1);\n\n// Load watershed boundaries\nvar watersheds = ee.FeatureCollection('WWF/HydroSHEDS/v1/Basins/hybas_12');\nprint('Watersheds:', watersheds);\n\n// Filter a feature collection\nvar california = adminLevel1.filter(ee.Filter.and(\n  ee.Filter.eq('ADM0_NAME', 'United States of America'),\n  ee.Filter.eq('ADM1_NAME', 'California')\n));\nprint('California:', california);\n</code></pre>"},{"location":"gee/gee_syntax/#var-dem-eeimageusgssrtmgl1_003","title":"var dem = ee.Image('USGS/SRTMGL1_003')","text":"<p>Loads a Digital Elevation Model (DEM).</p> <p>Example:</p> <pre><code>// Load SRTM 30m global DEM\nvar srtm = ee.Image('USGS/SRTMGL1_003');\nprint('SRTM DEM:', srtm);\n\n// Load ALOS 30m global DEM\nvar alos = ee.Image('JAXA/ALOS/AW3D30/V2_2');\nprint('ALOS DEM:', alos);\n\n// Visualize elevation data\nMap.setCenter(-119.5383, 37.8651, 9); // Yosemite National Park\nMap.addLayer(srtm, {min: 0, max: 4000, palette: ['blue', 'green', 'yellow', 'brown', 'white']}, 'SRTM DEM');\n\n// Calculate slope and aspect from DEM\nvar slope = ee.Terrain.slope(srtm);\nvar aspect = ee.Terrain.aspect(srtm);\nMap.addLayer(slope, {min: 0, max: 60}, 'Slope (degrees)');\nMap.addLayer(aspect, {min: 0, max: 360, palette: ['blue', 'green', 'yellow', 'orange', 'red']}, 'Aspect (degrees)');\n</code></pre> <p>Back to top</p>"},{"location":"gee/gee_syntax/#filtering-data","title":"Filtering Data","text":"<p>Functions for subsetting and filtering image collections and feature collections</p> <pre><code>graph LR\n    A[ImageCollection] --&gt; B{Filter}\n    B -- filterDate --&gt; C[Time Period]\n    B -- filterBounds --&gt; D[Area of Interest]\n    B -- filter(ee.Filter.lt) --&gt; E[Cloud Cover]\n    C &amp; D &amp; E --&gt; F[Filtered Subset]\n    style F fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"gee/gee_syntax/#collectionfilterdate2023-01-01-2023-12-31","title":"collection.filterDate('2023-01-01', '2023-12-31')","text":"<p>Filters images by date.</p> <p>Example:</p> <pre><code>// Load Sentinel-2 collection\nvar sentinel2 = ee.ImageCollection('COPERNICUS/S2_SR');\n\n// Filter by date range (for the year 2023)\nvar s2_2023 = sentinel2.filterDate('2023-01-01', '2023-12-31');\nprint('Images from 2023:', s2_2023.size());\n\n// Filter by specific season (summer 2023)\nvar s2_summer = sentinel2.filterDate('2023-06-01', '2023-08-31');\nprint('Summer 2023 images:', s2_summer.size());\n\n// Filter by specific month and sort by cloud cover\nvar s2_july = sentinel2.filterDate('2023-07-01', '2023-07-31')\n  .sort('CLOUDY_PIXEL_PERCENTAGE');\nprint('July 2023 images (sorted by cloud cover):', s2_july);\n\n// Get the most recent image from a date range\nvar endDate = ee.Date('2023-12-31');\nvar startDate = endDate.advance(-1, 'month');\nvar recentImage = sentinel2\n  .filterDate(startDate, endDate)\n  .sort('system:time_start', false) // Sort in descending order\n  .first();\nprint('Most recent image:', recentImage);\n</code></pre>"},{"location":"gee/gee_syntax/#collectionfilterboundsgeometry","title":"collection.filterBounds(geometry)","text":"<p>Filters images by geographic region.</p> <p>Example:</p> <pre><code>// Define a region of interest (ROI)\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]); // San Francisco area\n\n// Load Landsat 8 collection\nvar landsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA');\n\n// Filter collection by the ROI\nvar landsatSF = landsat8.filterBounds(roi);\nprint('Images intersecting ROI:', landsatSF.size());\n\n// Combine with date filter\nvar landsatSF_2023 = landsat8\n  .filterBounds(roi)\n  .filterDate('2023-01-01', '2023-12-31');\nprint('2023 images intersecting ROI:', landsatSF_2023.size());\n\n// Filter using a point\nvar mountEverest = ee.Geometry.Point([86.9250, 27.9881]);\nvar landsatEverest = landsat8\n  .filterBounds(mountEverest)\n  .filterDate('2023-01-01', '2023-12-31');\nprint('2023 images covering Mount Everest:', landsatEverest.size());\n\n// Filter using a feature collection\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nvar japan = countries.filter(ee.Filter.eq('country_na', 'Japan'));\nvar landsatJapan = landsat8\n  .filterBounds(japan.geometry())\n  .filterDate('2023-01-01', '2023-01-31');\nprint('January 2023 images covering Japan:', landsatJapan.size());\n</code></pre>"},{"location":"gee/gee_syntax/#collectionfiltereefiltereqcloud_cover-0","title":"collection.filter(ee.Filter.eq('CLOUD_COVER', 0))","text":"<p>Filters images based on metadata properties.</p> <p>Example:</p> <pre><code>// Load Landsat 8 collection\nvar landsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA');\n\n// Filter by cloud cover (less than 10%)\nvar clearImages = landsat8.filter(ee.Filter.lt('CLOUD_COVER', 10));\nprint('Images with &lt; 10% cloud cover:', clearImages.size());\n\n// Filter by exact property match\nvar path44 = landsat8.filter(ee.Filter.eq('WRS_PATH', 44));\nprint('Images from Path 44:', path44.size());\n\n// Combine multiple filters\nvar clearPath44 = landsat8\n  .filter(ee.Filter.and(\n    ee.Filter.eq('WRS_PATH', 44),\n    ee.Filter.lt('CLOUD_COVER', 10)\n  ));\nprint('Clear images from Path 44:', clearPath44.size());\n\n// Filter by date and properties\nvar recentClearImages = landsat8\n  .filterDate('2023-01-01', '2023-12-31')\n  .filter(ee.Filter.lt('CLOUD_COVER', 5));\nprint('Clear 2023 images:', recentClearImages.size());\n\n// Filter by list of values\nvar pathList = ee.List([44, 45, 46]);\nvar multiPath = landsat8.filter(ee.Filter.inList('WRS_PATH', pathList));\nprint('Images from multiple paths:', multiPath.size());\n</code></pre> <p>Back to top</p>"},{"location":"gee/gee_syntax/#mathematical-band-operations","title":"Mathematical &amp; Band Operations","text":"<p>Functions for performing calculations and manipulating image bands</p> <pre><code>graph LR\n    A[Raw Image] -- select --&gt; B[Specific Bands]\n    B -- normalizedDifference --&gt; C[NDVI / NDWI]\n    A -- add / subtract --&gt; D[Change Detection]\n    A -- multiply / divide --&gt; E[Scaling / Unit Conversion]\n    style C fill:#9f9,stroke:#333,stroke-width:2px</code></pre>"},{"location":"gee/gee_syntax/#var-ndvi-imagenormalizeddifferenceb5-b4","title":"var ndvi = image.normalizedDifference(['B5', 'B4'])","text":"<p>Calculates NDVI (or any other index).</p> <p>Example:</p> <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Calculate NDVI (Normalized Difference Vegetation Index)\n// For Landsat 8: NIR is B5, Red is B4\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']);\nMap.addLayer(ndvi, {min: -1, max: 1, palette: ['blue', 'white', 'green']}, 'NDVI');\n\n// Calculate NDWI (Normalized Difference Water Index)\n// For Landsat 8: Green is B3, NIR is B5\nvar ndwi = landsat.normalizedDifference(['B3', 'B5']);\nMap.addLayer(ndwi, {min: -1, max: 1, palette: ['white', 'blue']}, 'NDWI');\n\n// Calculate EVI (Enhanced Vegetation Index)\n// EVI = 2.5 * ((NIR - Red) / (NIR + 6 * Red - 7.5 * Blue + 1))\nvar evi = landsat.expression(\n  '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {\n    'NIR': landsat.select('B5'),\n    'RED': landsat.select('B4'),\n    'BLUE': landsat.select('B2')\n  });\nMap.addLayer(evi, {min: -1, max: 1, palette: ['white', 'darkgreen']}, 'EVI');\n\n// Create a mask for high vegetation areas\nvar vegetationMask = ndvi.gt(0.4);\nMap.addLayer(vegetationMask, {palette: ['white', 'green']}, 'Vegetation Mask');\n</code></pre>"},{"location":"gee/gee_syntax/#var-image2-imageselectb4-b3-b2","title":"var image2 = image.select(['B4', 'B3', 'B2'])","text":"<p>Selects specific bands.</p> <p>Example:</p> <pre><code>// Load a Sentinel-2 image\nvar sentinel2 = ee.Image('COPERNICUS/S2_SR/20210701T101559_20210701T101554_T33UUP');\n\n// Select RGB bands\nvar rgbImage = sentinel2.select(['B4', 'B3', 'B2']);\nMap.addLayer(rgbImage, {min: 0, max: 3000}, 'RGB Image');\n\n// Select NIR band\nvar nirImage = sentinel2.select('B8');\nMap.addLayer(nirImage, {min: 0, max: 3000, palette: ['black', 'white']}, 'NIR Band');\n\n// Select multiple bands and rename them\nvar selectedBands = sentinel2.select(\n  ['B8', 'B4', 'B3', 'B2'], // Original band names\n  ['nir', 'red', 'green', 'blue'] // New band names\n);\nprint('Selected bands with new names:', selectedBands);\n\n// Select all bands that match a pattern (using regular expression)\nvar allBands = sentinel2.bandNames();\nprint('All bands:', allBands);\n\nvar selectedBands = sentinel2.select('B.*'); // Select all bands starting with 'B'\nprint('Bands starting with B:', selectedBands.bandNames());\n</code></pre>"},{"location":"gee/gee_syntax/#var-newimage-imageaddimage2","title":"var newImage = image.add(image2)","text":"<p>Adds two images.</p> <p>Example:</p> <pre><code>// Load two Landsat 8 images from different dates\nvar image1 = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar image2 = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20150321');\n\n// Add corresponding bands\nvar sumImage = image1.add(image2);\nMap.addLayer(sumImage.select(['B4', 'B3', 'B2']), \n  {min: 0, max: 0.6}, 'Sum of two images');\n\n// Calculate the difference between images (for change detection)\nvar diffImage = image2.subtract(image1);\nMap.addLayer(diffImage.select(['B4', 'B3', 'B2']), \n  {min: -0.2, max: 0.2}, 'Difference between images');\n\n// Calculate the average of two images\nvar avgImage = image1.add(image2).divide(2);\nMap.addLayer(avgImage.select(['B4', 'B3', 'B2']), \n  {min: 0, max: 0.3}, 'Average of two images');\n\n// Perform band-wise operations\nvar ndvi1 = image1.normalizedDifference(['B5', 'B4']);\nvar ndvi2 = image2.normalizedDifference(['B5', 'B4']);\nvar ndviDiff = ndvi2.subtract(ndvi1);\nMap.addLayer(ndviDiff, \n  {min: -0.5, max: 0.5, palette: ['red', 'white', 'green']}, \n  'NDVI Change');\n</code></pre>"},{"location":"gee/gee_syntax/#var-newimage-imagemultiply2","title":"var newImage = image.multiply(2)","text":"<p>Multiplies an image by a constant.</p> <p>Example:</p> <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Multiply all bands by a constant (e.g., for scaling)\nvar scaledImage = landsat.multiply(10000);\nprint('Original range:', landsat.select('B4').reduceRegion({\n  reducer: ee.Reducer.minMax(),\n  geometry: landsat.geometry(),\n  scale: 30\n}));\nprint('Scaled range:', scaledImage.select('B4').reduceRegion({\n  reducer: ee.Reducer.minMax(),\n  geometry: landsat.geometry(),\n  scale: 30\n}));\n\n// Apply different scaling factors to different bands\nvar scaleFactors = ee.Image([0.0001, 0.0001, 0.0001, 1]); // Different factors for each band\nvar selectedBands = landsat.select(['B2', 'B3', 'B4', 'B5']);\nvar customScaled = selectedBands.multiply(scaleFactors);\nMap.addLayer(customScaled, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Custom Scaled');\n\n// Convert temperature from Kelvin to Celsius\nvar thermal = landsat.select('B10'); // Thermal band in Kelvin\nvar celsius = thermal.multiply(0.1).subtract(273.15); // K to C conversion\nMap.addLayer(celsius, {min: -10, max: 30, palette: ['blue', 'white', 'red']}, 'Temperature (C)');\n\n// Calculate percent reflectance\nvar percentReflectance = landsat.select(['B4', 'B3', 'B2']).multiply(100);\nMap.addLayer(percentReflectance, {min: 0, max: 30}, 'Percent Reflectance');\n</code></pre> <p>Back to top</p>"},{"location":"gee/gee_syntax/#geometry-feature-collection-operations","title":"Geometry &amp; Feature Collection Operations","text":"<p>Functions for creating and manipulating vector geometries and feature collections</p>"},{"location":"gee/gee_syntax/#var-point-eegeometrypointlon-lat","title":"var point = ee.Geometry.Point([lon, lat])","text":"<p>Creates a point geometry.</p> <p>Example:</p> <pre><code>// Create a point for New York City\nvar nyc = ee.Geometry.Point([-74.0060, 40.7128]);\nprint('NYC Point:', nyc);\n\n// Add the point to the map\nMap.centerObject(nyc, 10);\nMap.addLayer(nyc, {color: 'red'}, 'New York City');\n\n// Create a point from coordinates\nvar longitude = -118.2437;\nvar latitude = 34.0522;\nvar losAngeles = ee.Geometry.Point([longitude, latitude]);\nMap.addLayer(losAngeles, {color: 'blue'}, 'Los Angeles');\n\n// Get information about the point\nprint('Point coordinates:', nyc.coordinates());\nprint('Point type:', nyc.type());\nprint('Point area (should be 0):', nyc.area());\n\n// Buffer a point to create a circle\nvar bufferedPoint = nyc.buffer(10000); // 10km buffer\nMap.addLayer(bufferedPoint, {color: 'yellow'}, 'NYC 10km Buffer');\n</code></pre>"},{"location":"gee/gee_syntax/#var-polygon-eegeometrypolygonlon1-lat1-lon2-lat2","title":"var polygon = ee.Geometry.Polygon([[[lon1, lat1], [lon2, lat2], ...]])","text":"<p>Creates a polygon.</p> <p>Example:</p> <pre><code>// Create a polygon for Yellowstone National Park (approximate)\nvar yellowstone = ee.Geometry.Polygon([\n  [[-111.2, 44.6],\n   [-111.2, 45.1],\n   [-109.9, 45.1],\n   [-109.9, 44.6],\n   [-111.2, 44.6]]\n]);\n\n// Add the polygon to the map\nMap.centerObject(yellowstone, 8);\nMap.addLayer(yellowstone, {color: 'green'}, 'Yellowstone National Park');\n\n// Create a rectangle (simplified polygon)\nvar rectangle = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]);\nMap.addLayer(rectangle, {color: 'blue'}, 'San Francisco Bay Area');\n\n// Create a multi-polygon\nvar multiPolygon = ee.Geometry.MultiPolygon([\n  [[[-122.1, 37.4], [-122.1, 37.5], [-122.0, 37.5], [-122.0, 37.4], [-122.1, 37.4]]], // Polygon 1\n  [[[-122.3, 37.6], [-122.3, 37.7], [-122.2, 37.7], [-122.2, 37.6], [-122.3, 37.6]]]  // Polygon 2\n]);\nMap.addLayer(multiPolygon, {color: 'red'}, 'Multi-Polygon');\n\n// Calculate polygon area\nprint('Yellowstone area (square meters):', yellowstone.area());\nprint('Yellowstone perimeter (meters):', yellowstone.perimeter());\n\n// Check if a point is inside a polygon\nvar testPoint = ee.Geometry.Point([-110.5, 44.8]);\nprint('Is point inside Yellowstone?', yellowstone.contains(testPoint));\n</code></pre>"},{"location":"gee/gee_syntax/#var-fc-eefeaturecollectionfeature1-feature2","title":"var fc = ee.FeatureCollection([feature1, feature2])","text":"<p>Creates a Feature Collection.</p> <p>Example:</p> <pre><code>// Create features with properties\nvar city1 = ee.Feature(\n  ee.Geometry.Point([-122.4194, 37.7749]), // San Francisco\n  {name: 'San Francisco', population: 874961, state: 'CA'}\n);\n\nvar city2 = ee.Feature(\n  ee.Geometry.Point([-74.0060, 40.7128]), // New York\n  {name: 'New York', population: 8804190, state: 'NY'}\n);\n\nvar city3 = ee.Feature(\n  ee.Geometry.Point([-87.6298, 41.8781]), // Chicago\n  {name: 'Chicago', population: 2746388, state: 'IL'}\n);\n\n// Create a feature collection from the features\nvar cities = ee.FeatureCollection([city1, city2, city3]);\nprint('Cities collection:', cities);\n\n// Add the feature collection to the map\nMap.setCenter(-95, 40, 4);\nMap.addLayer(cities, {color: 'red'}, 'Major US Cities');\n\n// Create a feature collection from a list of geometries\nvar points = [\n  ee.Geometry.Point([-122.4, 37.8]),\n  ee.Geometry.Point([-122.5, 37.7]),\n  ee.Geometry.Point([-122.3, 37.9])\n];\nvar pointCollection = ee.FeatureCollection(points);\nMap.addLayer(pointCollection, {color: 'blue'}, 'Bay Area Points');\n\n// Create a feature collection with computed properties\nvar citiesWithDensity = cities.map(function(city) {\n  // Add a new property based on existing properties\n  return city.set('density', ee.Number(city.get('population')).divide(100));\n});\nprint('Cities with density:', citiesWithDensity);\n</code></pre>"},{"location":"gee/gee_syntax/#fcfilterboundspoint","title":"fc.filterBounds(point)","text":"<p>Filters features based on location.</p> <p>Example:</p> <pre><code>// Load country boundaries\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\n\n// Create a point for Paris\nvar paris = ee.Geometry.Point([2.3522, 48.8566]);\n\n// Filter to find which country contains Paris\nvar franceFilter = countries.filterBounds(paris);\nprint('Country containing Paris:', franceFilter);\n\n// Load global cities dataset\nvar cities = ee.FeatureCollection('projects/sat-io/open-datasets/hrsl/hrsl_cities');\n\n// Define a region of interest (California)\nvar california = ee.Geometry.Rectangle([-124.4, 32.5, -114.1, 42.0]);\n\n// Filter cities that fall within California\nvar californiaCities = cities.filterBounds(california);\nprint('Number of cities in California:', californiaCities.size());\nMap.addLayer(californiaCities, {color: 'yellow'}, 'California Cities');\n\n// Filter features that intersect with a buffer\nvar bufferZone = paris.buffer(100000); // 100km around Paris\nvar nearbyCountries = countries.filterBounds(bufferZone);\nprint('Countries within 100km of Paris:', nearbyCountries);\n\n// Combine with property filters\nvar europeanCountriesNearParis = countries\n  .filter(ee.Filter.eq('continent', 'Europe'))\n  .filterBounds(bufferZone);\nprint('European countries near Paris:', europeanCountriesNearParis);\n</code></pre> <p>Back to top</p>"},{"location":"gee/gee_syntax/#reducing-statistics","title":"Reducing &amp; Statistics","text":"<p>Functions for computing statistics and aggregating data across collections and regions</p> <pre><code>graph LR\n    A[ImageCollection] -- reduce --&gt; B(ee.Reducer)\n    B -- mean/median --&gt; C[Single Composite Image]\n    D[Image + Region] -- reduceRegion --&gt; E(ee.Reducer)\n    E -- mean/sum/histogram --&gt; F[Dictionary of Stats]\n    style C fill:#ffd,stroke:#333,stroke-width:2px\n    style F fill:#ffd,stroke:#333,stroke-width:2px</code></pre>"},{"location":"gee/gee_syntax/#var-mean-collectionreduceeereducermean","title":"var mean = collection.reduce(ee.Reducer.mean())","text":"<p>Computes the mean of an image collection.</p> <p>Example:</p> <pre><code>// Load a Landsat 8 collection for a specific area and time\nvar roi = ee.Geometry.Point([-122.3578, 37.7726]).buffer(50000); // San Francisco area\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterDate('2020-01-01', '2020-12-31')\n  .filterBounds(roi);\n\n// Calculate the mean (average) image across the collection\nvar meanImage = collection.reduce(ee.Reducer.mean());\nMap.centerObject(roi, 9);\nMap.addLayer(meanImage, \n  {bands: ['B4_mean', 'B3_mean', 'B2_mean'], min: 0, max: 0.3}, \n  'Mean RGB');\n\n// Calculate mean NDVI across the collection\nvar ndviCollection = collection.map(function(image) {\n  return image.normalizedDifference(['B5', 'B4']).rename('NDVI');\n});\nvar meanNDVI = ndviCollection.reduce(ee.Reducer.mean());\nMap.addLayer(meanNDVI, \n  {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, \n  'Mean NDVI');\n\n// Calculate mean by season\nvar winter = collection.filter(ee.Filter.calendarRange(12, 2, 'month'));\nvar summer = collection.filter(ee.Filter.calendarRange(6, 8, 'month'));\nvar winterMean = winter.reduce(ee.Reducer.mean());\nvar summerMean = summer.reduce(ee.Reducer.mean());\nMap.addLayer(winterMean, \n  {bands: ['B4_mean', 'B3_mean', 'B2_mean'], min: 0, max: 0.3}, \n  'Winter Mean');\nMap.addLayer(summerMean, \n  {bands: ['B4_mean', 'B3_mean', 'B2_mean'], min: 0, max: 0.3}, \n  'Summer Mean');\n</code></pre>"},{"location":"gee/gee_syntax/#var-minmax-collectionreduceeereducerminmax","title":"var minMax = collection.reduce(ee.Reducer.minMax())","text":"<p>Computes min and max values.</p> <p>Example:</p> <pre><code>// Load a Landsat 8 collection for a specific area and time\nvar roi = ee.Geometry.Point([-122.3578, 37.7726]).buffer(50000); // San Francisco area\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterDate('2020-01-01', '2020-12-31')\n  .filterBounds(roi);\n\n// Calculate min and max values across the collection\nvar minMaxImage = collection.reduce(ee.Reducer.minMax());\nMap.centerObject(roi, 9);\n\n// Display the minimum values\nMap.addLayer(minMaxImage, \n  {bands: ['B4_min', 'B3_min', 'B2_min'], min: 0, max: 0.3}, \n  'Min RGB');\n\n// Display the maximum values\nMap.addLayer(minMaxImage, \n  {bands: ['B4_max', 'B3_max', 'B2_max'], min: 0, max: 0.3}, \n  'Max RGB');\n\n// Calculate the range (max - min)\nvar rangeImage = minMaxImage.select('.*_max').subtract(minMaxImage.select('.*_min'));\n// Rename the bands to remove the _max suffix\nvar bandNames = rangeImage.bandNames().map(function(name) {\n  return ee.String(name).replace('_max', '_range');\n});\nrangeImage = rangeImage.rename(bandNames);\nMap.addLayer(rangeImage, \n  {bands: ['B4_range', 'B3_range', 'B2_range'], min: 0, max: 0.3}, \n  'Range RGB');\n\n// Calculate min/max NDVI\nvar ndviCollection = collection.map(function(image) {\n  return image.normalizedDifference(['B5', 'B4']).rename('NDVI');\n});\nvar ndviMinMax = ndviCollection.reduce(ee.Reducer.minMax());\nMap.addLayer(ndviMinMax.select('NDVI_min'), \n  {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, \n  'Min NDVI');\nMap.addLayer(ndviMinMax.select('NDVI_max'), \n  {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, \n  'Max NDVI');\n</code></pre>"},{"location":"gee/gee_syntax/#var-sum-collectionreduceeereducersum","title":"var sum = collection.reduce(ee.Reducer.sum())","text":"<p>Computes the sum of pixel values.</p> <p>Example:</p> <pre><code>// Load a MODIS precipitation collection\nvar precipitation = ee.ImageCollection('UCSB-CHG/CHIRPS/PENTAD')\n  .filterDate('2020-01-01', '2020-12-31');\n\n// Calculate total annual precipitation\nvar annualPrecip = precipitation.reduce(ee.Reducer.sum());\nMap.addLayer(annualPrecip, \n  {min: 0, max: 3000, palette: ['white', 'blue', 'purple']}, \n  'Annual Precipitation (mm)');\n\n// Calculate seasonal precipitation\nvar winterMonths = ee.List([12, 1, 2]);\nvar springMonths = ee.List([3, 4, 5]);\nvar summerMonths = ee.List([6, 7, 8]);\nvar fallMonths = ee.List([9, 10, 11]);\n\n// Filter by season and calculate sum\nvar winterPrecip = precipitation\n  .filter(ee.Filter.calendarRange(12, 2, 'month'))\n  .reduce(ee.Reducer.sum());\nvar springPrecip = precipitation\n  .filter(ee.Filter.calendarRange(3, 5, 'month'))\n  .reduce(ee.Reducer.sum());\nvar summerPrecip = precipitation\n  .filter(ee.Filter.calendarRange(6, 8, 'month'))\n  .reduce(ee.Reducer.sum());\nvar fallPrecip = precipitation\n  .filter(ee.Filter.calendarRange(9, 11, 'month'))\n  .reduce(ee.Reducer.sum());\n\n// Display seasonal precipitation\nMap.addLayer(winterPrecip, \n  {min: 0, max: 1000, palette: ['white', 'blue', 'purple']}, \n  'Winter Precipitation');\nMap.addLayer(summerPrecip, \n  {min: 0, max: 1000, palette: ['white', 'blue', 'purple']}, \n  'Summer Precipitation');\n\n// Calculate cumulative precipitation over time\nvar cumulativePrecip = precipitation.sort('system:time_start').iterate(\n  function(image, result) {\n    result = ee.Image(result);\n    image = ee.Image(image);\n    return result.add(image);\n  },\n  ee.Image.constant(0)\n);\nMap.addLayer(ee.Image(cumulativePrecip), \n  {min: 0, max: 3000, palette: ['white', 'blue', 'purple']}, \n  'Cumulative Precipitation');\n</code></pre>"},{"location":"gee/gee_syntax/#var-histogram-imagereduceregion-reducer-eereducerhistogram-geometry-region","title":"var histogram = image.reduceRegion({ reducer: ee.Reducer.histogram(), geometry: region })","text":"<p>Computes a histogram of pixel values.</p> <p>Example:</p> <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Define a region of interest\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]); // San Francisco Bay Area\n\n// Calculate NDVI\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']).rename('NDVI');\n\n// Compute histogram of NDVI values in the region\nvar histogram = ndvi.reduceRegion({\n  reducer: ee.Reducer.histogram({\n    maxBuckets: 30\n  }),\n  geometry: roi,\n  scale: 30,\n  maxPixels: 1e9\n});\n\n// Print the histogram\nprint('NDVI Histogram:', histogram);\n\n// Access histogram properties\nvar ndviHistogram = ee.Dictionary(histogram.get('NDVI'));\nvar counts = ndviHistogram.get('histogram');\nvar buckets = ndviHistogram.get('bucketMeans');\nprint('Histogram counts:', counts);\nprint('Bucket means:', buckets);\n\n// Compute histograms for multiple bands\nvar rgbHistograms = landsat.select(['B4', 'B3', 'B2']).reduceRegion({\n  reducer: ee.Reducer.histogram({\n    maxBuckets: 50\n  }),\n  geometry: roi,\n  scale: 30,\n  maxPixels: 1e9\n});\nprint('RGB Histograms:', rgbHistograms);\n\n// Compute statistics from histogram\nvar ndviStats = ndvi.reduceRegion({\n  reducer: ee.Reducer.mean().combine({\n    reducer2: ee.Reducer.stdDev(),\n    sharedInputs: true\n  }),\n  geometry: roi,\n  scale: 30,\n  maxPixels: 1e9\n});\nprint('NDVI Statistics:', ndviStats);\n</code></pre> <p>Back to top</p>"},{"location":"gee/gee_syntax/#exporting-data","title":"Exporting Data","text":"<p>Functions for exporting images and feature collections to Google Drive and Earth Engine assets</p> <pre><code>graph LR\n    A[Analysis Result] --&gt; B{Export To}\n    B -- .toDrive --&gt; C[Google Drive (.tif, .csv, .shp)]\n    B -- .toAsset --&gt; D[Cloud Asset (Stay in GEE)]\n    B -- .toCloudStorage --&gt; E[Google Cloud Bucket]\n    style C fill:#6bf,stroke:#333,stroke-width:2px\n    style D fill:#6bf,stroke:#333,stroke-width:2px</code></pre>"},{"location":"gee/gee_syntax/#exportimagetodriveimage-img-description-export-scale-30-region-geometry","title":"Export.image.toDrive({image: img, description: 'export', scale: 30, region: geometry})","text":"<p>Exports an image to Google Drive.</p> <p>Example:</p> <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Define a region of interest\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]); // San Francisco Bay Area\n\n// Select RGB bands for a natural color image\nvar rgb = landsat.select(['B4', 'B3', 'B2']);\n\n// Export the RGB image to Google Drive\nExport.image.toDrive({\n  image: rgb,\n  description: 'Landsat8_RGB_SanFrancisco',\n  folder: 'GEE_Exports',\n  scale: 30,  // 30 meters per pixel\n  region: roi,\n  fileFormat: 'GeoTIFF',\n  maxPixels: 1e9\n});\n\n// Export an NDVI image\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']).rename('NDVI');\nExport.image.toDrive({\n  image: ndvi,\n  description: 'Landsat8_NDVI_SanFrancisco',\n  folder: 'GEE_Exports',\n  scale: 30,\n  region: roi,\n  fileFormat: 'GeoTIFF'\n});\n\n// Export with different parameters\nExport.image.toDrive({\n  image: landsat.select(['B4', 'B3', 'B2', 'B5', 'B6']),\n  description: 'Landsat8_Multispectral',\n  folder: 'GEE_Exports',\n  scale: 100,  // Coarser resolution (100m)\n  region: roi,\n  fileFormat: 'GeoTIFF',\n  crs: 'EPSG:4326',  // WGS84 coordinate system\n  dimensions: null,  // Use scale instead of dimensions\n  skipEmptyTiles: true\n});\n\n// Export a classified image\nvar classified = landsat.select('B5').gt(0.2).add(landsat.select('B4').gt(0.2)).rename('classes');\nExport.image.toDrive({\n  image: classified,\n  description: 'Landsat8_Classification',\n  folder: 'GEE_Exports',\n  scale: 30,\n  region: roi,\n  fileFormat: 'GeoTIFF'\n});\n</code></pre>"},{"location":"gee/gee_syntax/#exporttabletodrivecollection-fc-description-export_fc","title":"Export.table.toDrive({collection: fc, description: 'export_fc'})","text":"<p>Exports a feature collection to Google Drive.</p> <p>Example:</p> <pre><code>// Load country boundaries\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\n\n// Filter to get specific countries\nvar selectedCountries = countries.filter(ee.Filter.inList('country_na', \n  ['Brazil', 'Argentina', 'Chile', 'Peru', 'Colombia']));\n\n// Export the feature collection to Google Drive as a shapefile\nExport.table.toDrive({\n  collection: selectedCountries,\n  description: 'South_American_Countries',\n  folder: 'GEE_Exports',\n  fileFormat: 'SHP'  // Shapefile format\n});\n\n// Export as CSV with selected properties\nExport.table.toDrive({\n  collection: selectedCountries,\n  description: 'South_American_Countries_CSV',\n  folder: 'GEE_Exports',\n  fileFormat: 'CSV',\n  selectors: ['country_na', 'iso_alpha3']  // Only export these properties\n});\n\n// Export as GeoJSON\nExport.table.toDrive({\n  collection: selectedCountries,\n  description: 'South_American_Countries_GeoJSON',\n  folder: 'GEE_Exports',\n  fileFormat: 'GeoJSON'\n});\n\n// Export with computed properties\nvar countriesWithArea = selectedCountries.map(function(feature) {\n  // Add area in square kilometers\n  var area = feature.geometry().area().divide(1000 * 1000);\n  return feature.set('area_km2', area);\n});\n\nExport.table.toDrive({\n  collection: countriesWithArea,\n  description: 'South_American_Countries_With_Area',\n  folder: 'GEE_Exports',\n  fileFormat: 'CSV',\n  selectors: ['country_na', 'area_km2']\n});\n</code></pre>"},{"location":"gee/gee_syntax/#exportimagetoassetimage-img-description-export_asset","title":"Export.image.toAsset({image: img, description: 'export_asset'})","text":"<p>Exports an image to an Earth Engine asset.</p> <p>Example:</p> <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Define a region of interest\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]); // San Francisco Bay Area\n\n// Calculate NDVI\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']).rename('NDVI');\n\n// Export the NDVI image to an Earth Engine asset\nExport.image.toAsset({\n  image: ndvi,\n  description: 'NDVI_SanFrancisco',\n  assetId: 'users/username/NDVI_SanFrancisco',  // Replace 'username' with your GEE username\n  scale: 30,\n  region: roi,\n  maxPixels: 1e9\n});\n\n// Export a composite image to an asset\nvar composite = landsat.select(['B4', 'B3', 'B2', 'B5']);\nExport.image.toAsset({\n  image: composite,\n  description: 'Landsat_Composite',\n  assetId: 'users/username/Landsat_Composite',\n  scale: 30,\n  region: roi,\n  maxPixels: 1e9\n});\n\n// Export a classified image to an asset\nvar classified = ndvi.gt(0.3).rename('vegetation');\nExport.image.toAsset({\n  image: classified,\n  description: 'Vegetation_Mask',\n  assetId: 'users/username/Vegetation_Mask',\n  scale: 30,\n  region: roi,\n  maxPixels: 1e9\n});\n\n// Export with pyramiding policy\nvar elevation = ee.Image('USGS/SRTMGL1_003');\nExport.image.toAsset({\n  image: elevation.clip(roi),\n  description: 'SRTM_Elevation',\n  assetId: 'users/username/SRTM_Elevation',\n  scale: 30,\n  region: roi,\n  maxPixels: 1e9,\n  pyramidingPolicy: {'.default': 'mean'}  // Use mean for pyramiding\n});\n</code></pre> <p>Back to top</p>"},{"location":"gee/gee_syntax/#miscellaneous","title":"Miscellaneous","text":"<p>Additional useful functions for various operations in Earth Engine</p>"},{"location":"gee/gee_syntax/#eealgorithmsifcondition-truevalue-falsevalue","title":"ee.Algorithms.If(condition, trueValue, falseValue)","text":"<p>Conditional statement.</p> <p>Example:</p> <pre><code>// Create a simple condition\nvar x = 10;\nvar condition = x &gt; 5;\n\n// Use If statement to return different values based on condition\nvar result = ee.Algorithms.If(condition, 'x is greater than 5', 'x is less than or equal to 5');\nprint('Result:', result);\n\n// Use with Earth Engine objects\nvar image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar ndvi = image.normalizedDifference(['B5', 'B4']);\n\n// Create a condition based on mean NDVI\nvar roi = ee.Geometry.Point([-122.3578, 37.7726]).buffer(5000);\nvar meanNdvi = ndvi.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: roi,\n  scale: 30\n}).get('nd');\n\n// Use If to determine vegetation status\nvar vegetationStatus = ee.Algorithms.If(\n  ee.Number(meanNdvi).gt(0.3),\n  'Healthy vegetation',\n  'Sparse vegetation'\n);\nprint('Vegetation status:', vegetationStatus);\n\n// Use If for image processing\nvar processedImage = ee.Algorithms.If(\n  ee.Number(meanNdvi).gt(0.3),\n  // If vegetation is healthy, highlight vegetation in green\n  ndvi.gt(0.3).selfMask().visualize({palette: ['green']}),\n  // Otherwise, highlight non-vegetation in brown\n  ndvi.lt(0.3).selfMask().visualize({palette: ['brown']})\n);\nMap.addLayer(ee.Image(processedImage), {}, 'Processed Image');\n\n// Nested If statements\nvar cloudCover = image.get('CLOUD_COVER');\nvar qualityCategory = ee.Algorithms.If(\n  ee.Number(cloudCover).lt(10),\n  'Excellent',\n  ee.Algorithms.If(\n    ee.Number(cloudCover).lt(30),\n    'Good',\n    'Poor'\n  )\n);\nprint('Image quality:', qualityCategory);\n</code></pre>"},{"location":"gee/gee_syntax/#imageclipregion","title":"image.clip(region)","text":"<p>Clips an image to a specified region.</p> <p>Example:</p> <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Define a region to clip to (San Francisco Bay Area)\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]);\n\n// Clip the image to the region\nvar clippedImage = landsat.clip(roi);\n\n// Display the clipped image\nMap.centerObject(roi, 10);\nMap.addLayer(clippedImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Clipped Landsat Image');\n\n// Clip a DEM to a country boundary\nvar dem = ee.Image('USGS/SRTMGL1_003');\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nvar nepal = countries.filter(ee.Filter.eq('country_na', 'Nepal'));\n\nvar nepalDEM = dem.clip(nepal);\nMap.centerObject(nepal, 7);\nMap.addLayer(nepalDEM, {min: 0, max: 8000, palette: ['blue', 'green', 'yellow', 'red', 'white']}, 'Nepal Elevation');\n\n// Clip multiple bands\nvar rgbImage = landsat.select(['B4', 'B3', 'B2']).clip(roi);\nMap.addLayer(rgbImage, {min: 0, max: 0.3}, 'Clipped RGB');\n\n// Clip an image collection\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterDate('2020-01-01', '2020-12-31')\n  .filterBounds(roi);\n\nvar clippedCollection = collection.map(function(image) {\n  return image.clip(roi);\n});\n\n// Display the first image from the clipped collection\nvar firstImage = ee.Image(clippedCollection.first());\nMap.addLayer(firstImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'First Clipped Image');\n</code></pre>"},{"location":"gee/gee_syntax/#collectionmedian","title":"collection.median()","text":"<p>Computes the median of an image collection.</p> <p>Example:</p> <pre><code>// Load a Landsat 8 collection for a specific area and time\nvar roi = ee.Geometry.Point([-122.3578, 37.7726]).buffer(50000); // San Francisco area\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterDate('2020-01-01', '2020-12-31')\n  .filterBounds(roi);\n\n// Compute the median image\nvar medianImage = collection.median();\nMap.centerObject(roi, 9);\nMap.addLayer(medianImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Median RGB');\n\n// Compare median with mean\nvar meanImage = collection.mean();\nMap.addLayer(meanImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Mean RGB');\n\n// Calculate median NDVI\nvar ndviCollection = collection.map(function(image) {\n  return image.normalizedDifference(['B5', 'B4']).rename('NDVI');\n});\nvar medianNDVI = ndviCollection.median();\nMap.addLayer(medianNDVI, {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, 'Median NDVI');\n\n// Create a cloud-free composite using median\nvar cloudFreeLandsat = collection\n  .filter(ee.Filter.lt('CLOUD_COVER', 20))  // Filter low cloud images\n  .median();\nMap.addLayer(cloudFreeLandsat, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Cloud-free Composite');\n\n// Calculate seasonal medians\nvar winter = collection.filter(ee.Filter.calendarRange(12, 2, 'month')).median();\nvar summer = collection.filter(ee.Filter.calendarRange(6, 8, 'month')).median();\nMap.addLayer(winter, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Winter Median');\nMap.addLayer(summer, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Summer Median');\n</code></pre>"},{"location":"gee/gee_syntax/#collectiontolistngeti","title":"collection.toList(n).get(i)","text":"<p>Converts an image collection to a list and retrieves the i-th element.</p> <p>Example:</p> <pre><code>// Load a Landsat 8 collection for a specific area and time\nvar roi = ee.Geometry.Point([-122.3578, 37.7726]).buffer(50000); // San Francisco area\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterDate('2020-01-01', '2020-12-31')\n  .filterBounds(roi)\n  .sort('CLOUD_COVER'); // Sort by cloud cover (ascending)\n\n// Get the size of the collection\nvar collectionSize = collection.size();\nprint('Collection size:', collectionSize);\n\n// Convert the collection to a list\nvar imageList = collection.toList(collectionSize);\n\n// Get the first image (lowest cloud cover)\nvar firstImage = ee.Image(imageList.get(0));\nprint('First image:', firstImage);\nMap.centerObject(roi, 9);\nMap.addLayer(firstImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Lowest Cloud Cover Image');\n\n// Get the second image\nvar secondImage = ee.Image(imageList.get(1));\nMap.addLayer(secondImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Second Lowest Cloud Cover Image');\n\n// Get a specific image by index (e.g., the 5th image)\nvar fifthImage = ee.Image(imageList.get(4));\nMap.addLayer(fifthImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, '5th Image');\n\n// Get the last image (highest cloud cover)\nvar lastIndex = ee.Number(collectionSize).subtract(1);\nvar lastImage = ee.Image(imageList.get(lastIndex));\nMap.addLayer(lastImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Highest Cloud Cover Image');\n\n// Process multiple images from the list\nvar processImages = function(start, end) {\n  var result = ee.List([]);\n  for (var i = start; i &lt;= end; i++) {\n    var image = ee.Image(imageList.get(i));\n    var ndvi = image.normalizedDifference(['B5', 'B4']).rename('NDVI');\n    result = ee.List(result).add(ndvi);\n  }\n  return result;\n};\n\n// Process the first 3 images\nvar processedImages = processImages(0, 2);\nprint('Processed images:', processedImages);\n\n// Display the first processed image\nMap.addLayer(ee.Image(processedImages.get(0)), \n  {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, \n  'NDVI of First Image');\n</code></pre> <p>Back to top</p>"},{"location":"gee/gee_syntax/#best-practices","title":"Best Practices","text":"<p>Recommended approaches for efficient and accurate geospatial analysis in Earth Engine</p>"},{"location":"gee/gee_syntax/#projection-and-scale-best-practices","title":"Projection and Scale Best Practices","text":"<p>When working with geospatial data in Google Earth Engine, it's important to follow these best practices for handling projections and scale:</p> <ol> <li>Let GEE handle projections dynamically unless absolutely necessary</li> </ol> <pre><code>// Good practice: Let GEE handle projection\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nMap.addLayer(landsat, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Landsat Image');\n\n// Check the native projection\nprint('Image projection:', landsat.projection());\n</code></pre> <ol> <li>Use .projection() to check an image's native projection before applying operations</li> </ol> <pre><code>// Check projection before operations\nvar image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nprint('Native projection:', image.projection());\nprint('Scale (meters):', image.projection().nominalScale());\n\n// Use the native projection information\nvar scale = image.projection().nominalScale();\nprint('Native scale in meters:', scale);\n</code></pre> <ol> <li>For area calculations, use an equal-area projection like EPSG:6933</li> </ol> <pre><code>// Calculate area using equal-area projection\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]);\nvar areaDefault = roi.area();\nprint('Area with default projection (m\u00b2):', areaDefault);\n\n// Reproject to an equal-area projection for more accurate area calculation\nvar equalAreaProjection = 'EPSG:6933'; // World Mollweide equal-area projection\nvar roiReprojected = roi.transform(equalAreaProjection);\nvar areaEqualArea = roiReprojected.area();\nprint('Area with equal-area projection (m\u00b2):', areaEqualArea);\n</code></pre> <ol> <li>Specify projection and scale only when exporting or performing specific analyses</li> </ol> <pre><code>// Specify scale and projection when exporting\nvar image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]);\n\nExport.image.toDrive({\n  image: image.select(['B4', 'B3', 'B2']),\n  description: 'Landsat_RGB_Reprojected',\n  scale: 30,  // Specify scale in meters\n  crs: 'EPSG:4326',  // Specify projection\n  region: roi\n});\n</code></pre> <ol> <li>Avoid reproject() unless necessary for small-scale analysis</li> </ol> <pre><code>// Avoid unnecessary reprojection\n// Instead of this:\nvar reprojectedImage = image.reproject({\n  crs: 'EPSG:4326',\n  scale: 30\n});\n\n// Prefer this for most operations:\nvar result = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: roi,\n  scale: 30,  // Specify scale without reprojection\n  maxPixels: 1e9\n});\n</code></pre> <ol> <li>Use reduceResolution() instead of reproject() to aggregate data at a coarser scale</li> </ol> <pre><code>// Aggregate to coarser resolution using reduceResolution\nvar image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Instead of reprojecting to coarser resolution:\nvar coarseImage = image.reduceResolution({\n  reducer: ee.Reducer.mean(),\n  maxPixels: 1024\n});\n\n// Set the projection for the aggregated image\ncoarseImage = coarseImage.reproject({\n  crs: image.projection().crs(),\n  scale: 300  // 10x coarser than original 30m resolution\n});\n\nMap.addLayer(image, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Original Resolution');\nMap.addLayer(coarseImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Aggregated Resolution');\n</code></pre>"},{"location":"gee/gee_syntax/#common-real-world-workflows","title":"Common Real-World Workflows","text":""},{"location":"gee/gee_syntax/#1-land-use-land-cover-lulc-classification","title":"1. Land Use / Land Cover (LULC) Classification","text":"<p>Automated mapping of land types using machine learning.</p> <pre><code>graph LR\n    A[Satellite Image Collection] -- filter &amp; median --&gt; B[Cloud-free Composite]\n    C[Training Points] -- sampleRegions --&gt; D[Training Data]\n    D -- ee.Classifier.smileRandomForest --&gt; E[Trained Classifier]\n    B -- .classify --&gt; F[LULC Map]\n    F -- .clip --&gt; G[Final Result]\n    style F fill:#9f9,stroke:#333,stroke-width:2px</code></pre> <p>Example Code:</p> <pre><code>// 1. Prepare Data\nvar roi = ee.Geometry.Point([-122.4, 37.7]).buffer(10000);\nvar landsat = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\")\n  .filterBounds(roi)\n  .filterDate('2023-01-01', '2023-12-31')\n  .median();\n\n// 2. Training Data (Example points)\nvar trainingPoints = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([-122.43, 37.75]), {label: 0, class: 'urban'}),\n  ee.Feature(ee.Geometry.Point([-122.45, 37.78]), {label: 1, class: 'water'})\n]);\n\n// 3. Train and Classify\nvar training = landsat.sampleRegions({\n  collection: trainingPoints,\n  properties: ['label'],\n  scale: 30\n});\n\nvar classifier = ee.Classifier.smileRandomForest(10).train(training, 'label');\nvar classified = landsat.classify(classifier);\n\nMap.addLayer(classified, {min: 0, max: 1, palette: ['red', 'blue']}, 'LULC Classification');\n</code></pre>"},{"location":"gee/gee_syntax/#2-time-series-change-detection","title":"2. Time-Series Change Detection","text":"<p>Detecting how an area changed between two time periods.</p> <pre><code>graph LR\n    A[Year 2015 Image] -- calculate --&gt; B[NDVI 2015]\n    C[Year 2023 Image] -- calculate --&gt; D[NDVI 2023]\n    D -- subtract --&gt; E[NDVI Difference]\n    E -- threshold --&gt; F[Significant Change Map]\n    style F fill:#f66,stroke:#333,stroke-width:2px</code></pre> <p>Example Code:</p> <pre><code>var roi = ee.Geometry.Point([-122.4, 37.7]).buffer(5000);\n\n// Load images for two years\nvar img1 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\").filterBounds(roi).filterDate('2015-01-01', '2015-12-31').median();\nvar img2 = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\").filterBounds(roi).filterDate('2023-01-01', '2023-12-31').median();\n\n// Calculate NDVI for both\nvar ndvi1 = img1.normalizedDifference(['B5', 'B4']);\nvar ndvi2 = img2.normalizedDifference(['B5', 'B4']);\n\n// Find difference\nvar diff = ndvi2.subtract(ndvi1);\n\nMap.addLayer(diff, {min: -0.5, max: 0.5, palette: ['red', 'white', 'green']}, 'Vegetation Change');\n</code></pre>"},{"location":"gee/modern_best_practices/","title":"Modern GEE Best Practices &amp; Recent Changes","text":"<p>Google Earth Engine is constantly evolving. Staying up-to-date with the latest best practices ensures your scripts are efficient, scalable, and use the most accurate data available.</p>"},{"location":"gee/modern_best_practices/#1-use-collection-2-c02-for-landsat","title":"1. Use Collection 2 (C02) for Landsat","text":"<p>Landsat Collection 1 is being retired. Always use Collection 2, which provides improved data quality, better geolocation, and consistent metadata.</p> JavaScriptPythonLegacy (Avoid) <pre><code>// Modern approach - Collection 2 Level 2 (Surface Reflectance)\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_L2');\n</code></pre> <pre><code># Modern approach - Collection 2 Level 2 (Surface Reflectance)\nlandsat = ee.Image('LANDSAT/LC08/C02/T1_L2')\n</code></pre> <pre><code>// Old approach - Don't use this anymore\nvar legacy = ee.Image('LANDSAT/LC08/C01/T1_SR');\n</code></pre>"},{"location":"gee/modern_best_practices/#2-server-side-vs-client-side","title":"2. Server-Side vs. Client-Side","text":"<p>One of the most common mistakes is mixing server-side Earth Engine objects with client-side functions (like <code>for</code> loops or <code>if</code> statements).</p>"},{"location":"gee/modern_best_practices/#the-correct-way-server-side","title":"The Correct Way (Server-Side)","text":"<p>Use <code>.map()</code> instead of <code>for</code> loops and <code>ee.Algorithms.If()</code> or boolean expressions instead of <code>if</code>.</p> JavaScriptPython <pre><code>// Scale an ImageCollection (The modern way)\nvar collection = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\")\n  .map(function(image) {\n    return image.divide(10000); // Server-side operation\n  });\n</code></pre> <pre><code># Scale an ImageCollection (The modern way)\ndef scale_image(image):\n    return image.divide(10000)  # Server-side operation\n\ncollection = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\") \\\n    .map(scale_image)\n\n# Or using lambda (shorter syntax)\ncollection = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\") \\\n    .map(lambda image: image.divide(10000))\n</code></pre>"},{"location":"gee/modern_best_practices/#3-sentinel-2-harmonization","title":"3. Sentinel-2 Harmonization","text":"<p>Recent Sentinel-2 data (after early 2022) has a processing change. Use <code>COPERNICUS/S2_SR_HARMONIZED</code> to ensure consistent values across different processing baseline versions.</p> JavaScriptPython <pre><code>var s2 = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\");\n</code></pre> <pre><code>s2 = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\")\n</code></pre>"},{"location":"gee/modern_best_practices/#4-efficient-reducers","title":"4. Efficient Reducers","text":"<p>When calculating statistics over large areas, specify a <code>scale</code> and <code>tileScale</code> to avoid memory errors.</p> JavaScriptPython <pre><code>var stats = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: region,\n  scale: 30,\n  tileScale: 4 // Use higher values (up to 16) for complex computations\n});\n</code></pre> <pre><code>stats = image.reduceRegion(\n    reducer=ee.Reducer.mean(),\n    geometry=region,\n    scale=30,\n    tileScale=4  # Use higher values (up to 16) for complex computations\n)\n</code></pre>"},{"location":"gee/modern_best_practices/#5-ui-and-apps","title":"5. UI and Apps","text":"<p>Modern GEE apps should use the <code>ui.*</code> package instead of simple print statements for a more professional user interface.</p> <p>JavaScript Only</p> <p>The UI package is only available in the JavaScript Code Editor. For Python, use libraries like <code>geemap</code> or <code>ipywidgets</code> for interactive interfaces.</p> JavaScriptPython (Alternative) <pre><code>var panel = ui.Panel({\n  style: {width: '400px', backgroundColor: 'rgba(255,255,255,0.8)'}\n});\nui.root.add(panel);\n</code></pre> <pre><code># In Python, use geemap for interactive maps\nimport geemap\n\nMap = geemap.Map()\nMap.addLayer(image, vis_params, 'Layer Name')\nMap\n</code></pre>"},{"location":"gee/modern_best_practices/#key-differences-javascript-vs-python","title":"Key Differences: JavaScript vs Python","text":"Feature JavaScript Python Variable Declaration <code>var x = ...</code> <code>x = ...</code> Functions <code>function(x) { return x; }</code> <code>def func(x): return x</code> or <code>lambda x: x</code> Dictionary/Object <code>{key: 'value'}</code> <code>{'key': 'value'}</code> Comments <code>// comment</code> <code># comment</code> True/False <code>true</code>, <code>false</code> <code>True</code>, <code>False</code> UI Elements <code>ui.Panel()</code>, <code>ui.Label()</code> Use <code>geemap</code> or <code>ipywidgets</code> <p>Stay updated by checking the Earth Engine Developers Blog regularly.</p>"},{"location":"gee/quick_start/","title":"Quick Start Guide","text":"<p>Welcome! This page will get you started with Google Earth Engine in just a few minutes.</p>"},{"location":"gee/quick_start/#choose-your-language","title":"Choose Your Language","text":"<p>Google Earth Engine works with both JavaScript and Python. Pick whichever you prefer:</p> JavaScript Python \u2705 No installation needed \u26a0\ufe0f Requires Python installation \u2705 Works in web browser \u2705 Works in Jupyter notebooks \u2705 Built-in Code Editor \u2705 Use familiar Python tools \u2705 Great for beginners \u2705 Great for data scientists <p>All examples on this site show both languages - just click the tabs!</p>"},{"location":"gee/quick_start/#your-first-gee-script","title":"Your First GEE Script","text":"<p>Let's load and display a satellite image. Click the tabs to see the code in your preferred language:</p> JavaScriptPython <pre><code>// Load a Landsat 8 image\nvar image = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318');\n\n// Define how to display it (RGB = Red, Green, Blue bands)\nvar visParams = {\n  bands: ['SR_B4', 'SR_B3', 'SR_B2'],\n  min: 7000,\n  max: 12000\n};\n\n// Center the map and add the image\nMap.centerObject(image, 8);\nMap.addLayer(image, visParams, 'Landsat Image');\n\n// Print information about the image\nprint('Image details:', image);\n</code></pre> <pre><code>import ee\nimport geemap\n\n# Initialize Earth Engine\nee.Initialize()\n\n# Load a Landsat 8 image\nimage = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318')\n\n# Define how to display it (RGB = Red, Green, Blue bands)\nvis_params = {\n    'bands': ['SR_B4', 'SR_B3', 'SR_B2'],\n    'min': 7000,\n    'max': 12000\n}\n\n# Create a map and add the image\nMap = geemap.Map()\nMap.centerObject(image, 8)\nMap.addLayer(image, vis_params, 'Landsat Image')\n\n# Print information about the image\nprint('Image details:', image.getInfo())\n\n# Display the map\nMap\n</code></pre> <p></p> <p>Above: Example of a Landsat 8 image (Grand Canyon). The code above loads a similar image over California.</p> <p>What this does:</p> <ol> <li>Loads a satellite image from 2014</li> <li>Selects the Red, Green, and Blue bands to create a natural color image</li> <li>Displays it on a map</li> <li>Prints information about the image</li> </ol>"},{"location":"gee/quick_start/#calculate-vegetation-health-ndvi","title":"Calculate Vegetation Health (NDVI)","text":"<p>NDVI (Normalized Difference Vegetation Index) shows where plants are healthy. Green = healthy vegetation, brown = bare soil.</p> JavaScriptPython <pre><code>// Load the image\nvar image = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318');\n\n// Calculate NDVI (uses Near-Infrared and Red bands)\nvar ndvi = image.normalizedDifference(['SR_B5', 'SR_B4'])\n  .rename('NDVI');\n\n// Display it with a color palette\nvar ndviParams = {\n  min: -1,\n  max: 1,\n  palette: ['blue', 'white', 'green']\n};\n\nMap.centerObject(image, 8);\nMap.addLayer(ndvi, ndviParams, 'NDVI');\n</code></pre> <pre><code>import ee\nimport geemap\n\nee.Initialize()\n\n# Load the image\nimage = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318')\n\n# Calculate NDVI (uses Near-Infrared and Red bands)\nndvi = image.normalizedDifference(['SR_B5', 'SR_B4']) \\\n    .rename('NDVI')\n\n# Display it with a color palette\nndvi_params = {\n    'min': -1,\n    'max': 1,\n    'palette': ['blue', 'white', 'green']\n}\n\nMap = geemap.Map()\nMap.centerObject(image, 8)\nMap.addLayer(ndvi, ndvi_params, 'NDVI')\nMap\n</code></pre> <p></p> <p>Above: Example of a Global NDVI map. The code above calculates NDVI for a single image.</p> <p>What this does:</p> <ul> <li>Calculates vegetation health using infrared and red light</li> <li>Blue = water</li> <li>White = bare soil or urban areas</li> <li>Green = healthy vegetation</li> </ul>"},{"location":"gee/quick_start/#work-with-multiple-images","title":"Work with Multiple Images","text":"<p>Instead of one image, let's work with many images over time:</p> JavaScriptPython <pre><code>// Define your area of interest\nvar point = ee.Geometry.Point([-122.4, 37.8]); // San Francisco\n\n// Load all Landsat 8 images from 2023\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n  .filterDate('2023-01-01', '2023-12-31')\n  .filterBounds(point)\n  .filter(ee.Filter.lt('CLOUD_COVER', 20));\n\n// How many images did we find?\nprint('Number of images:', collection.size());\n\n// Create a cloud-free composite (median of all images)\nvar composite = collection.median();\n\n// Display it\nvar visParams = {\n  bands: ['SR_B4', 'SR_B3', 'SR_B2'],\n  min: 7000,\n  max: 12000\n};\n\nMap.centerObject(point, 10);\nMap.addLayer(composite, visParams, '2023 Composite');\n</code></pre> <pre><code>import ee\nimport geemap\n\nee.Initialize()\n\n# Define your area of interest\npoint = ee.Geometry.Point([-122.4, 37.8])  # San Francisco\n\n# Load all Landsat 8 images from 2023\ncollection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \\\n    .filterDate('2023-01-01', '2023-12-31') \\\n    .filterBounds(point) \\\n    .filter(ee.Filter.lt('CLOUD_COVER', 20))\n\n# How many images did we find?\nprint('Number of images:', collection.size().getInfo())\n\n# Create a cloud-free composite (median of all images)\ncomposite = collection.median()\n\n# Display it\nvis_params = {\n    'bands': ['SR_B4', 'SR_B3', 'SR_B2'],\n    'min': 7000,\n    'max': 12000\n}\n\nMap = geemap.Map()\nMap.centerObject(point, 10)\nMap.addLayer(composite, vis_params, '2023 Composite')\nMap\n</code></pre> <p>What this does:</p> <ol> <li>Finds all Landsat 8 images from 2023 over San Francisco</li> <li>Filters to only images with less than 20% cloud cover</li> <li>Combines them into one cloud-free image (using the median value)</li> <li>Displays the result</li> </ol>"},{"location":"gee/quick_start/#next-steps","title":"Next Steps","text":"<p>Now that you've seen the basics, here's where to go next:</p> <ol> <li>Set up your account - Create a free GEE account</li> <li>Learn the interface - Understand the Code Editor</li> <li>JavaScript vs Python - Detailed comparison</li> <li>More examples - Comprehensive code reference</li> </ol>"},{"location":"gee/quick_start/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 Both languages work the same - Choose JavaScript or Python based on your preference</p> <p>\u2705 No downloads needed for JavaScript - Everything runs in your browser</p> <p>\u2705 Python offers more flexibility - Integrate with other Python libraries</p> <p>\u2705 All examples are tabbed - Easy to compare and learn both</p> <p>\u2705 Start simple, build up - Begin with single images, then collections, then analysis</p> <p>Ready to dive deeper? Continue to the full guide!</p> <p>Continue Learning \u2192</p>"},{"location":"gee/scale_projection/","title":"Comprehensive Guide to Projection and Scale in Google Earth Engine","text":""},{"location":"gee/scale_projection/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Fundamentals of Geospatial Data in GEE</li> <li>How Google Earth Engine Handles Projections</li> <li>Understanding Scale in Google Earth Engine</li> <li>When to Specify Projections and Scale Manually</li> <li>Best Practices for Projection and Scale in GEE</li> <li>Common Errors and Troubleshooting</li> <li>Practical Examples with Code</li> <li>Advanced Topics</li> <li>Conclusion and Resources</li> </ol>"},{"location":"gee/scale_projection/#10-conclusion-and-resources","title":"10. Conclusion and Resources","text":""},{"location":"gee/scale_projection/#summary-of-key-concepts","title":"Summary of Key Concepts","text":"<p>Throughout this comprehensive tutorial, we've explored the critical concepts of projection and scale in Google Earth Engine, from fundamental principles to advanced applications. Let's recap the key points:</p>"},{"location":"gee/scale_projection/#projection-fundamentals","title":"Projection Fundamentals","text":"<ul> <li>Coordinate Reference Systems (CRS) define how Earth's curved surface is represented on a flat plane</li> <li>Different projections serve different purposes: some preserve angles, others preserve areas</li> <li>EPSG codes provide standardized identifiers for projection systems (e.g., EPSG:4326 for WGS84)</li> </ul>"},{"location":"gee/scale_projection/#scale-concepts","title":"Scale Concepts","text":"<ul> <li>Scale refers to pixel resolution in meters</li> <li>Native resolution is the original pixel size of a dataset</li> <li>Image pyramids store data at multiple resolutions for efficient access</li> </ul>"},{"location":"gee/scale_projection/#gees-unique-approach","title":"GEE's Unique Approach","text":"<ul> <li>GEE uses a \"pull\" basis for both projection and scale</li> <li>The output requirements determine how inputs are processed</li> <li>Dynamic reprojection happens automatically based on analysis needs</li> <li>Lazy computation optimizes resource usage</li> </ul>"},{"location":"gee/scale_projection/#when-to-take-control","title":"When to Take Control","text":"<ul> <li>Exporting data requires explicit projection and scale settings</li> <li>Area calculations should use equal-area projections</li> <li>Multi-dataset analysis may benefit from explicit projection control</li> <li>Performance optimization sometimes requires manual scale management</li> </ul>"},{"location":"gee/scale_projection/#best-practices","title":"Best Practices","text":"<ul> <li>Let GEE handle projections automatically when possible</li> <li>Check native projections before operations</li> <li>Use appropriate projections for specific analytical needs</li> <li>Avoid unnecessary reprojection</li> <li>Select scale parameters based on analysis requirements and computational constraints</li> </ul>"},{"location":"gee/scale_projection/#practical-applications","title":"Practical Applications","text":"<p>The concepts covered in this tutorial apply to numerous Earth science applications:</p> <ul> <li>Land Cover Classification: Ensuring consistent scale across training and classification</li> <li>Change Detection: Maintaining projection consistency for accurate time-series analysis</li> <li>Area Measurement: Using equal-area projections for accurate quantification of deforestation, urbanization, etc.</li> <li>Global Studies: Handling projection distortions at different latitudes</li> <li>Regional Analysis: Selecting regionally optimized projections for specific study areas</li> </ul>"},{"location":"gee/scale_projection/#further-learning-resources","title":"Further Learning Resources","text":""},{"location":"gee/scale_projection/#official-google-earth-engine-documentation","title":"Official Google Earth Engine Documentation","text":"<ul> <li>Earth Engine Projections Guide</li> <li>Earth Engine Scale Guide</li> <li>Earth Engine API Reference</li> </ul>"},{"location":"gee/scale_projection/#community-resources","title":"Community Resources","text":"<ul> <li>Google Earth Engine Developers Forum</li> <li>GIS Stack Exchange - Earth Engine Tag</li> <li>Earth Engine Community Tutorials on GitHub</li> </ul>"},{"location":"gee/scale_projection/#projection-resources","title":"Projection Resources","text":"<ul> <li>EPSG Registry - Comprehensive database of coordinate reference systems</li> <li>Projection Wizard - Tool to help select appropriate map projections</li> <li>Map Projections: A Working Manual - Classic USGS publication on map projections</li> </ul>"},{"location":"gee/scale_projection/#academic-papers","title":"Academic Papers","text":"<ul> <li>Gorelick, N., Hancher, M., Dixon, M., Ilyushchenko, S., Thau, D., &amp; Moore, R. (2017). Google Earth Engine: Planetary-scale geospatial analysis for everyone. Remote Sensing of Environment, 202, 18-27.</li> <li>Padilla, M., Stehman, S. V., Ramo, R., Corti, D., Hantson, S., Oliva, P., ... &amp; Chuvieco, E. (2015). Comparing the accuracies of remote sensing global burned area products using stratified random sampling and estimation. Remote Sensing of Environment, 160, 114-121.</li> <li>Potere, D. (2008). Horizontal positional accuracy of Google Earth's high-resolution imagery archive. Sensors, 8(12), 7973-7981.</li> </ul>"},{"location":"gee/scale_projection/#books-and-textbooks","title":"Books and Textbooks","text":"<ul> <li>Lovelace, R., Nowosad, J., &amp; Muenchow, J. (2019). Geocomputation with R. CRC Press.</li> <li>Pebesma, E., &amp; Bivand, R. (2023). Spatial Data Science: With Applications in R. Chapman and Hall/CRC.</li> <li>Westra, E. (2016). Python Geospatial Development. Packt Publishing Ltd.</li> </ul>"},{"location":"gee/scale_projection/#final-thoughts","title":"Final Thoughts","text":"<p>Understanding projection and scale in Google Earth Engine is essential for producing accurate, reliable, and computationally efficient geospatial analyses. While GEE's automatic handling of these concepts simplifies many workflows, knowing when and how to take manual control empowers you to optimize your analyses for specific needs.</p> <p>As you continue your journey with Google Earth Engine, remember that projection and scale considerations should be integrated into your analytical thinking from the beginning of a project. By applying the principles and best practices covered in this tutorial, you'll be well-equipped to tackle complex geospatial challenges with confidence and precision.</p> <p>The field of geospatial analysis continues to evolve, with new datasets, methods, and tools emerging regularly. Stay connected with the GEE community, explore the resources provided, and continue experimenting with different approaches to refine your skills and expand your capabilities.</p> <p>Happy mapping and analyzing with Google Earth Engine!</p>"},{"location":"gee/scale_projection/#1-introduction-to-projection-and-scale-in-google-earth-engine","title":"1. Introduction to Projection and Scale in Google Earth Engine","text":"<p>Google Earth Engine (GEE) is a powerful cloud-based geospatial processing platform that revolutionizes how we analyze satellite imagery and geospatial datasets. By leveraging Google's computational infrastructure, GEE enables users to process and analyze petabytes of satellite imagery and geospatial data with unprecedented speed and efficiency. This capability has transformed how researchers, scientists, and analysts approach large-scale environmental monitoring, land use change detection, climate studies, and numerous other Earth science applications.</p>"},{"location":"gee/scale_projection/#why-understanding-projection-and-scale-matters","title":"Why Understanding Projection and Scale Matters","text":"<p>When working with geospatial data in GEE, two fundamental concepts significantly impact the accuracy and efficiency of your analyses: projection and scale. These concepts might seem technical at first, but mastering them is essential for anyone seeking to produce reliable results and optimize computational resources in GEE.</p>"},{"location":"gee/scale_projection/#impact-on-analysis-accuracy","title":"Impact on Analysis Accuracy","text":"<p>Projection and scale directly affect the accuracy of measurements and calculations in your geospatial analyses:</p> <ul> <li>Area calculations can vary significantly depending on the projection used, potentially leading to substantial errors in land cover estimates or deforestation measurements</li> <li>Distance measurements are affected by projection distortions, which can impact analyses like buffer operations or proximity calculations</li> <li>Pixel value aggregations are influenced by scale, affecting statistics derived from imagery such as mean reflectance values or classification results</li> </ul>"},{"location":"gee/scale_projection/#impact-on-computational-efficiency","title":"Impact on Computational Efficiency","text":"<p>GEE's cloud-based architecture is designed to handle massive datasets, but understanding projection and scale helps you optimize your computational resources:</p> <ul> <li>Processing time can increase dramatically with unnecessary reprojection operations or inappropriate scale settings</li> <li>Memory usage is affected by the resolution at which you process data, with finer scales requiring more resources</li> <li>Request quotas in GEE can be quickly consumed by inefficient code that doesn't properly account for projection and scale</li> </ul>"},{"location":"gee/scale_projection/#what-youll-learn-in-this-tutorial","title":"What You'll Learn in This Tutorial","text":"<p>This comprehensive tutorial will guide you through the intricacies of projection and scale in Google Earth Engine, providing both theoretical understanding and practical implementation skills. By the end of this tutorial, you will:</p> <ol> <li>Understand the fundamental concepts of coordinate reference systems and how they relate to GEE</li> <li>Master how GEE uniquely handles projections and scale using its \"pull\" basis approach</li> <li>Know when and how to specify projections and scale manually for different analytical needs</li> <li>Implement best practices to ensure accurate results while optimizing computational efficiency</li> <li>Troubleshoot common projection and scale-related errors in your GEE workflows</li> <li>Apply these concepts through practical code examples for real-world geospatial analysis tasks</li> </ol>"},{"location":"gee/scale_projection/#tutorial-structure","title":"Tutorial Structure","text":"<p>This tutorial is organized to progressively build your understanding from fundamental concepts to advanced applications:</p> <ol> <li>Introduction (this section)</li> <li>Fundamentals of Geospatial Data in GEE - Core concepts of coordinate systems and pixel resolution</li> <li>How Google Earth Engine Handles Projections - GEE's unique approach to projection management</li> <li>Understanding Scale in Google Earth Engine - The relationship between scale, image pyramids, and analysis</li> <li>When to Specify Projections and Scale Manually - Critical scenarios requiring explicit settings</li> <li>Best Practices for Projection and Scale in GEE - Guidelines for optimal implementation</li> <li>Common Errors and Troubleshooting - Solutions to frequent projection and scale challenges</li> <li>Practical Examples with Code - Real-world applications with detailed code explanations</li> <li>Advanced Topics - Specialized considerations for complex analyses</li> <li>Conclusion and Resources - Summary and further learning materials</li> </ol> <p>Whether you're new to GEE or looking to deepen your expertise, this tutorial will enhance your ability to work with geospatial data accurately and efficiently. Let's begin by exploring the fundamental concepts of geospatial data representation in GEE.</p>"},{"location":"gee/scale_projection/#2-fundamentals-of-geospatial-data-in-gee","title":"2. Fundamentals of Geospatial Data in GEE","text":"<p>To effectively work with geospatial data in Google Earth Engine, it's essential to understand how the Earth's three-dimensional surface is represented in a two-dimensional computational environment. This section explores the core concepts of coordinate reference systems, projections, and scale that form the foundation of geospatial analysis in GEE.</p>"},{"location":"gee/scale_projection/#coordinate-reference-systems-crs-explained","title":"Coordinate Reference Systems (CRS) Explained","text":"<p>A Coordinate Reference System (CRS) defines how coordinates on a flat map relate to real locations on the Earth's curved surface. Every CRS consists of several components:</p> <ol> <li>Datum: A model of the Earth's shape (typically an ellipsoid) and its orientation in space</li> <li>Coordinate System: A framework that specifies how positions are represented (e.g., using latitude/longitude or meters)</li> <li>Projection: A mathematical transformation that converts the Earth's curved surface to a flat representation</li> </ol> <p>In GEE, coordinate reference systems are typically identified using EPSG codes, which are standardized numerical identifiers maintained by the International Association of Oil &amp; Gas Producers (IOGP). For example, \"EPSG:4326\" refers to the WGS84 geographic coordinate system, which uses latitude and longitude coordinates.</p>"},{"location":"gee/scale_projection/#common-projection-systems-used-in-gee","title":"Common Projection Systems Used in GEE","text":"<p>Google Earth Engine supports numerous projection systems, but several are particularly important to understand:</p>"},{"location":"gee/scale_projection/#epsg4326-wgs84","title":"EPSG:4326 (WGS84)","text":"<ul> <li>The World Geodetic System 1984, which uses latitude and longitude coordinates</li> <li>The default projection for many global datasets and the GEE default when no projection is specified</li> <li>Not an equal-area projection, meaning area calculations can be distorted, especially near the poles</li> <li>Example in GEE: <code>ee.Projection('EPSG:4326')</code></li> </ul>"},{"location":"gee/scale_projection/#epsg3857-web-mercator","title":"EPSG:3857 (Web Mercator)","text":"<ul> <li>The projection used by Google Maps, Bing Maps, and most web mapping applications</li> <li>Used by default for visualization in the GEE Code Editor and geemap</li> <li>Preserves angles but significantly distorts areas, especially at high latitudes</li> <li>Example in GEE: <code>ee.Projection('EPSG:3857')</code></li> </ul>"},{"location":"gee/scale_projection/#epsg6933-equal-earth","title":"EPSG:6933 (Equal Earth)","text":"<ul> <li>An equal-area projection that preserves the relative size of areas</li> <li>Ideal for accurate area calculations in global analyses</li> <li>Minimizes distortion of shapes while maintaining equal area</li> <li>Example in GEE: <code>ee.Projection('EPSG:6933')</code></li> </ul>"},{"location":"gee/scale_projection/#sinusoidal-projections","title":"Sinusoidal Projections","text":"<ul> <li>Used by several satellite data products, including MODIS</li> <li>An equal-area projection that preserves areas but distorts shapes away from the central meridian</li> <li>Example in GEE: MODIS datasets use a custom sinusoidal projection (SR-ORG:6974)</li> </ul>"},{"location":"gee/scale_projection/#understanding-scale-as-pixel-resolution","title":"Understanding Scale as Pixel Resolution","text":"<p>In Google Earth Engine, scale refers to the spatial resolution of raster data\u2014essentially, the size of each pixel in meters. Scale is a critical concept that affects both the accuracy of your analysis and the computational resources required:</p> <ul> <li>Native resolution: The original pixel size of a dataset (e.g., 30 meters for Landsat, 10 meters for Sentinel-2)</li> <li>Analysis scale: The resolution at which computations are performed, which may differ from native resolution</li> <li>Output scale: The resolution of your final results or exports</li> </ul> <p>Scale in GEE is typically expressed in meters, representing the side length of a square pixel. For example:</p> <ul> <li>Landsat 8 optical bands: 30 meters</li> <li>Sentinel-2 optical bands: 10-20 meters (depending on the band)</li> <li>MODIS land surface temperature: 1000 meters</li> <li>Digital Elevation Models: Various resolutions from 30 meters to 90 meters</li> </ul>"},{"location":"gee/scale_projection/#relationship-between-projection-and-scale","title":"Relationship Between Projection and Scale","text":"<p>Projection and scale are interrelated concepts in GEE that together determine how accurately your analysis represents the Earth's surface:</p> <ol> <li>Scale varies with projection: In some projections (like Mercator), the actual ground distance represented by a pixel varies with latitude</li> <li>Reprojection affects scale: When data is reprojected, pixels may be resampled, potentially changing their values</li> <li>Analysis consistency: Using consistent projections and scales across datasets is crucial for accurate comparative analyses</li> </ol>"},{"location":"gee/scale_projection/#example-scale-variation-in-web-mercator","title":"Example: Scale Variation in Web Mercator","text":"<p>In the Web Mercator projection (EPSG:3857), the actual ground distance represented by a \"30-meter\" pixel increases as you move away from the equator:</p> <ul> <li>At the equator: 30 meters is 30 meters on the ground</li> <li>At 60\u00b0 latitude: 30 meters in the projection represents about 60 meters on the ground</li> <li>Near the poles: The distortion becomes extreme</li> </ul> <p>This variation has significant implications for area calculations, distance measurements, and any analysis that depends on accurate spatial relationships.</p>"},{"location":"gee/scale_projection/#practical-implications-for-gee-analysis","title":"Practical Implications for GEE Analysis","text":"<p>Understanding these fundamental concepts has direct practical implications for your work in Google Earth Engine:</p> <ol> <li>Accuracy of measurements: Using inappropriate projections can lead to significant errors in area and distance calculations</li> <li>Computational efficiency: Processing at unnecessarily fine scales can dramatically increase computation time and resource usage</li> <li>Data compatibility: Working with multiple datasets requires understanding their native projections and scales</li> <li>Result interpretation: The choice of projection and scale affects how results should be interpreted and presented</li> </ol> <p>In the next section, we'll explore how Google Earth Engine uniquely handles projections using its \"pull\" basis approach, which differs significantly from traditional GIS platforms.</p>"},{"location":"gee/scale_projection/#3-how-google-earth-engine-handles-projections","title":"3. How Google Earth Engine Handles Projections","text":"<p>Google Earth Engine's approach to handling projections differs significantly from traditional GIS and image processing platforms. Understanding this unique approach is crucial for effective and efficient geospatial analysis in GEE. This section explores how GEE manages projections dynamically and what that means for your workflows.</p>"},{"location":"gee/scale_projection/#the-pull-basis-concept-for-projection-handling","title":"The \"Pull\" Basis Concept for Projection Handling","text":"<p>In traditional GIS software, users typically need to ensure all input data layers share the same projection before analysis\u2014a \"push\" approach where inputs determine the processing projection. Google Earth Engine inverts this paradigm with a \"pull\" approach:</p> <ul> <li>Output determines input: The projection of the output (what you're requesting) determines how inputs are processed</li> <li>Dynamic reprojection: GEE reprojects inputs on-the-fly based on the output's requirements</li> <li>Lazy computation: Projections aren't applied until results are actually needed (for display or export)</li> </ul> <p>This pull-based approach means that in most cases, you don't need to manually reproject your data in GEE. Instead, the system intelligently handles projections based on what you're trying to accomplish.</p>"},{"location":"gee/scale_projection/#automatic-projection-handling-in-gee","title":"Automatic Projection Handling in GEE","text":"<p>When you perform operations in Earth Engine, the system automatically manages projections through several mechanisms:</p>"},{"location":"gee/scale_projection/#1-projection-inference","title":"1. Projection Inference","text":"<p>GEE determines the appropriate projection for computation based on:</p> <ul> <li>Function parameters: When you specify a <code>crs</code> parameter in functions like <code>reduceRegion()</code> or <code>Export.image</code></li> <li>Display context: The Code Editor and geemap use Web Mercator (EPSG:3857) for visualization</li> <li>Explicit reprojection: When you use the <code>reproject()</code> method to force a specific projection</li> </ul>"},{"location":"gee/scale_projection/#2-projection-propagation","title":"2. Projection Propagation","text":"<p>When you chain operations together, projection information flows backward through your computation:</p> <pre><code>Input Image \u2192 Operation 1 \u2192 Operation 2 \u2192 ... \u2192 Output (with specified projection)\n                                                      \u2191\n                                        Projection requirements flow backward\n</code></pre> <p>This means the projection specified at the end of your computation chain determines how all previous operations are handled.</p>"},{"location":"gee/scale_projection/#3-on-demand-resampling","title":"3. On-Demand Resampling","text":"<p>GEE doesn't actually perform reprojection until results are needed:</p> <ul> <li>When you visualize an image on the map</li> <li>When you export data</li> <li>When you request statistics with reducers</li> </ul> <p>This lazy evaluation approach optimizes computational resources by avoiding unnecessary reprojection operations.</p>"},{"location":"gee/scale_projection/#visualization-vs-computation-projections","title":"Visualization vs. Computation Projections","text":"<p>An important distinction in GEE is that visualization and computation may use different projections:</p>"},{"location":"gee/scale_projection/#visualization-projection","title":"Visualization Projection","text":"<ul> <li>The Code Editor and geemap maps use Web Mercator (EPSG:3857) for display</li> <li>This projection is optimized for web mapping but distorts areas, especially at high latitudes</li> <li>When you add an image to the map, GEE automatically reprojects it to Web Mercator regardless of its native projection</li> </ul>"},{"location":"gee/scale_projection/#computation-projection","title":"Computation Projection","text":"<ul> <li>Analyses and calculations use the projection specified in your code or the native projection of the input data</li> <li>For accurate area calculations, you should specify an equal-area projection like EPSG:6933</li> <li>Statistical operations through reducers use the projection specified in the <code>crs</code> parameter</li> </ul> <p>This separation allows GEE to optimize both display performance and analytical accuracy.</p>"},{"location":"gee/scale_projection/#how-gee-aligns-multiple-datasets-with-different-projections","title":"How GEE Aligns Multiple Datasets with Different Projections","text":"<p>When working with multiple datasets that have different native projections, GEE automatically aligns them based on the output requirements:</p> <ol> <li>Common projection determination: GEE identifies the target projection from your code or defaults to the first input's projection</li> <li>Dynamic reprojection: All inputs are reprojected to the common projection as needed</li> <li>Resampling: Pixels are resampled using nearest neighbor (default), bilinear, or cubic methods as specified</li> </ol> <p>This automatic alignment eliminates the need for manual reprojection steps that are common in traditional GIS workflows.</p>"},{"location":"gee/scale_projection/#example-combining-landsat-and-sentinel-2-data","title":"Example: Combining Landsat and Sentinel-2 Data","text":"<p>When combining Landsat (UTM projection) and Sentinel-2 (also UTM but potentially different zones) imagery:</p> <pre><code>// These images have different native projections\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar sentinel = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\n\n// GEE automatically aligns them when used together\nvar ndvi_landsat = landsat.normalizedDifference(['B5', 'B4']);\nvar ndvi_sentinel = sentinel.normalizedDifference(['B8', 'B4']);\n\n// The output uses the projection specified here\nvar difference = ndvi_sentinel.subtract(ndvi_landsat)\n  .reproject({\n    crs: 'EPSG:3857',\n    scale: 30\n  });\n</code></pre> <p>In this example, GEE handles all the necessary reprojection to align the datasets before computing their difference.</p>"},{"location":"gee/scale_projection/#when-gee-uses-default-projections-wgs84","title":"When GEE Uses Default Projections (WGS84)","text":"<p>While GEE's automatic projection handling is powerful, there are situations where the system defaults to using WGS84 (EPSG:4326) with 1-degree scale:</p> <ol> <li>Image collections with mixed projections: When reducing an <code>ImageCollection</code> containing images with different projections</li> <li>Composite creation: When creating a mosaic or composite from images with different projections</li> <li>Ambiguous operations: When the output projection cannot be clearly determined from inputs or parameters</li> </ol> <p>In these cases, you'll see the default WGS84 projection when you check the projection of the result:</p> <pre><code>var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA');\nvar mosaic = collection.filterDate('2018-01-01', '2019-01-01').mosaic();\nprint(mosaic.projection());  // Shows WGS84 with 1-degree scale\n</code></pre> <p>This default projection is generally not suitable for analysis due to its coarse scale. When you encounter this situation, you should explicitly specify an appropriate projection and scale for your analysis.</p>"},{"location":"gee/scale_projection/#practical-implications-of-gees-projection-handling","title":"Practical Implications of GEE's Projection Handling","text":"<p>GEE's approach to projections has several practical implications for your workflows:</p> <ol> <li>Simplified code: You rarely need to include explicit reprojection steps</li> <li>Computational efficiency: The system optimizes reprojection operations behind the scenes</li> <li>Flexibility: You can easily work with datasets in different projections without manual conversion</li> <li>Output control: You maintain control over the final projection through export parameters</li> </ol> <p>In the next section, we'll explore how GEE handles scale using a similar \"pull\" approach, which complements its projection handling system.</p>"},{"location":"gee/scale_projection/#4-understanding-scale-in-google-earth-engine","title":"4. Understanding Scale in Google Earth Engine","text":"<p>Scale is a fundamental concept in Google Earth Engine that significantly impacts both the accuracy of your analyses and the computational resources required. In this section, we'll explore how GEE uniquely handles scale, the concept of image pyramids, and how scale affects your analytical results.</p>"},{"location":"gee/scale_projection/#the-pull-basis-concept-for-scale-determination","title":"The \"Pull\" Basis Concept for Scale Determination","text":"<p>Similar to its approach with projections, Google Earth Engine handles scale using a \"pull\" basis rather than the \"push\" approach used in traditional GIS platforms:</p> <ul> <li>Traditional GIS (push): The resolution of input data determines the resolution of processing and output</li> <li>GEE (pull): The scale specified for the output determines what resolution of input data is used</li> </ul> <p>This pull-based approach means that the scale at which computations occur is determined by:</p> <ol> <li>Explicit scale parameters: When you specify a <code>scale</code> parameter in functions like <code>reduceRegion()</code> or <code>Export.image</code></li> <li>Display context: The zoom level of the map when visualizing results</li> <li>Reprojection settings: When you use the <code>reproject()</code> method with a scale parameter</li> </ol> <p>This approach gives you flexibility to work with the same data at different scales without duplicating datasets.</p>"},{"location":"gee/scale_projection/#image-pyramids-and-how-they-work","title":"Image Pyramids and How They Work","text":"<p>Google Earth Engine stores raster data in multi-resolution structures called image pyramids. Understanding these pyramids is key to grasping how GEE handles scale:</p>"},{"location":"gee/scale_projection/#structure-of-image-pyramids","title":"Structure of Image Pyramids","text":"<p>An image pyramid consists of the same image stored at multiple resolutions:</p> <ul> <li>Level 0: The original, full-resolution image (native resolution)</li> <li>Level 1: A downsampled version, typically with pixels representing 2x the area of Level 0</li> <li>Level 2, 3, etc.: Progressively more downsampled versions</li> </ul> <p>Each level of the pyramid contains the same geographic extent but with fewer pixels, making computation more efficient at coarser scales.</p>"},{"location":"gee/scale_projection/#pyramiding-policies","title":"Pyramiding Policies","text":"<p>How pixel values are aggregated when creating higher levels of the pyramid depends on the pyramiding policy of the dataset:</p> <ul> <li>Mean: For continuous data (like reflectance values), pixel values are averaged</li> <li>Mode: For categorical data (like land cover classes), the most common value is used</li> <li>Sample: A single pixel (often the top-left) is selected to represent the block</li> <li>Min/Max: The minimum or maximum value in the block is used</li> </ul> <p>Different bands of the same image can have different pyramiding policies based on their data type.</p>"},{"location":"gee/scale_projection/#how-gee-selects-pyramid-levels","title":"How GEE Selects Pyramid Levels","text":"<p>When you request data at a specific scale, GEE:</p> <ol> <li>Identifies the pyramid level with resolution closest to (but not finer than) your requested scale</li> <li>Resamples that level as needed to match your exact scale requirement</li> <li>Performs computations at that resolution</li> </ol> <p>This approach optimizes performance by avoiding unnecessary processing of high-resolution data when lower resolution is sufficient.</p>"},{"location":"gee/scale_projection/#how-scale-affects-analysis-results","title":"How Scale Affects Analysis Results","text":"<p>The scale at which you perform analysis can dramatically affect your results:</p>"},{"location":"gee/scale_projection/#pixel-value-variation","title":"Pixel Value Variation","text":"<p>As demonstrated in the official GEE documentation, the same location can return different pixel values depending on the scale:</p> <pre><code>var image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select('B4');\n\nvar printAtScale = function(scale) {\n  print('Pixel value at '+scale+' meters scale',\n    image.reduceRegion({\n      reducer: ee.Reducer.first(),\n      geometry: image.geometry().centroid(),\n      scale: scale\n  }).get('B4'));\n};\n\nprintAtScale(10);  // 0.10394100844860077\nprintAtScale(30);  // 0.10394100844860077 (native resolution)\nprintAtScale(50);  // 0.09130698442459106\nprintAtScale(70);  // 0.1150854229927063\nprintAtScale(200); // 0.102478988468647\nprintAtScale(500); // 0.09072770178318024\n</code></pre> <p>This variation occurs because different pyramid levels are selected and resampled based on the requested scale.</p>"},{"location":"gee/scale_projection/#classification-accuracy","title":"Classification Accuracy","text":"<p>Scale significantly impacts classification results:</p> <ul> <li>Finer scales capture more spatial detail but may introduce noise</li> <li>Coarser scales smooth out variation but may miss important features</li> <li>Mixed pixels become more prevalent at coarser scales, affecting class boundaries</li> </ul>"},{"location":"gee/scale_projection/#area-calculations","title":"Area Calculations","text":"<p>The scale at which you calculate areas affects the precision of your measurements:</p> <ul> <li>Finer scales generally provide more accurate area estimates, especially for small or irregularly shaped features</li> <li>Coarser scales may miss fine details of boundaries, leading to under or overestimation</li> </ul>"},{"location":"gee/scale_projection/#statistical-aggregations","title":"Statistical Aggregations","text":"<p>When computing statistics over regions:</p> <ul> <li>Scale determines sampling density: Finer scales include more samples in the calculation</li> <li>Spatial patterns: Coarser scales may obscure spatial patterns visible at finer resolutions</li> <li>Computational intensity: Finer scales require more computation but may provide more accurate results</li> </ul>"},{"location":"gee/scale_projection/#relationship-between-zoom-levels-and-scale-in-the-map-interface","title":"Relationship Between Zoom Levels and Scale in the Map Interface","text":"<p>When visualizing data in the Code Editor or geemap, the scale of displayed data is directly related to the map's zoom level:</p>"},{"location":"gee/scale_projection/#zoom-level-to-scale-relationship","title":"Zoom Level to Scale Relationship","text":"<p>Each zoom level corresponds to a specific scale in Web Mercator projection:</p> <ul> <li>Zoom level 0: Entire world (~156,000 meters/pixel at equator)</li> <li>Zoom level 10: City level (~150 meters/pixel at equator)</li> <li>Zoom level 15: Neighborhood level (~5 meters/pixel at equator)</li> <li>Zoom level 20: Building level (~0.15 meters/pixel at equator)</li> </ul>"},{"location":"gee/scale_projection/#dynamic-resolution-loading","title":"Dynamic Resolution Loading","text":"<p>As you zoom in and out:</p> <ol> <li>GEE automatically selects the appropriate pyramid level for display</li> <li>More detailed data is loaded as you zoom in</li> <li>Data is aggregated as you zoom out</li> </ol> <p>This dynamic loading optimizes both display performance and network usage.</p>"},{"location":"gee/scale_projection/#scale-bar-interpretation","title":"Scale Bar Interpretation","text":"<p>The scale bar in the map interface shows the actual ground distance at the current latitude:</p> <ul> <li>Due to Web Mercator distortion, the same pixel size represents different ground distances at different latitudes</li> <li>Near the equator, scale is relatively accurate</li> <li>Near the poles, significant distortion occurs</li> </ul>"},{"location":"gee/scale_projection/#scale-considerations-for-different-types-of-analyses","title":"Scale Considerations for Different Types of Analyses","text":"<p>Different types of analyses have different optimal scale considerations:</p>"},{"location":"gee/scale_projection/#land-cover-classification","title":"Land Cover Classification","text":"<ul> <li>Recommended scale: Depends on the minimum mapping unit required</li> <li>Considerations: Finer scales capture more detail but may introduce noise and increase computation time</li> <li>Example: 30m for regional land cover, 10m for detailed urban mapping</li> </ul>"},{"location":"gee/scale_projection/#change-detection","title":"Change Detection","text":"<ul> <li>Recommended scale: Should match or be slightly coarser than the native resolution of input data</li> <li>Considerations: Consistent scale across time periods is crucial</li> <li>Example: 30m for Landsat-based change detection</li> </ul>"},{"location":"gee/scale_projection/#spectral-indices-ndvi-evi-etc","title":"Spectral Indices (NDVI, EVI, etc.)","text":"<ul> <li>Recommended scale: Native resolution of input bands</li> <li>Considerations: Mixing resolutions can introduce artifacts</li> <li>Example: 10m for Sentinel-2 based indices</li> </ul>"},{"location":"gee/scale_projection/#terrain-analysis","title":"Terrain Analysis","text":"<ul> <li>Recommended scale: Depends on the terrain features of interest</li> <li>Considerations: Too coarse a scale will smooth out important terrain features</li> <li>Example: 30m for general topographic analysis, finer for detailed hydrological modeling</li> </ul> <p>In the next section, we'll explore when you should manually specify projections and scale in your GEE workflows, rather than relying on the automatic handling.</p>"},{"location":"gee/scale_projection/#5-when-to-specify-projections-and-scale-manually","title":"5. When to Specify Projections and Scale Manually","text":"<p>While Google Earth Engine's automatic handling of projections and scale is powerful and convenient, there are specific scenarios where manually specifying these parameters is necessary for accurate results or optimal performance. This section explores when and how to take control of projection and scale settings in your GEE workflows.</p>"},{"location":"gee/scale_projection/#exporting-data-scenarios","title":"Exporting Data Scenarios","text":"<p>When exporting data from GEE, explicitly defining projection and scale ensures consistency and accuracy:</p>"},{"location":"gee/scale_projection/#exporting-images","title":"Exporting Images","text":"<p>When using <code>Export.image.toDrive()</code>, <code>Export.image.toAsset()</code>, or <code>Export.image.toCloudStorage()</code>, you should specify:</p> <pre><code>Export.image.toDrive({\n  image: myImage,\n  description: 'exported_image',\n  scale: 30,  // Resolution in meters\n  crs: 'EPSG:4326',  // WGS84 coordinate system\n  region: myStudyArea,\n  maxPixels: 1e13\n});\n</code></pre> <p>Specifying these parameters ensures: - The exported data has a consistent resolution - The coordinate system is appropriate for your needs - The data can be seamlessly integrated with other GIS software</p>"},{"location":"gee/scale_projection/#exporting-vector-data","title":"Exporting Vector Data","text":"<p>When exporting vector data with <code>Export.table</code>, projection settings affect the coordinate system of the output:</p> <pre><code>Export.table.toDrive({\n  collection: myFeatureCollection,\n  description: 'exported_vectors',\n  fileFormat: 'SHP',\n  selectors: ['property1', 'property2'],\n  driveFolder: 'GEE_Exports'\n});\n</code></pre> <p>While vector exports don't require scale parameters, the coordinate system defaults to WGS84 (EPSG:4326).</p>"},{"location":"gee/scale_projection/#working-with-multiple-datasets-with-different-projections","title":"Working with Multiple Datasets with Different Projections","text":"<p>When combining datasets with different native projections, explicitly specifying a common projection ensures proper alignment:</p>"},{"location":"gee/scale_projection/#combining-optical-and-radar-data","title":"Combining Optical and Radar Data","text":"<p>Optical sensors (like Landsat) and radar sensors (like Sentinel-1) often use different native projections:</p> <pre><code>var landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar sentinel1 = ee.Image('COPERNICUS/S1_GRD/S1A_IW_GRDH_1SDV_20180504T043029_20180504T043054_021743_02582F_FBAB');\n\n// Specify a common projection for analysis\nvar commonScale = 30;\nvar commonCRS = 'EPSG:3857';\n\n// Reproject both datasets to the common projection\nvar landsatReprojected = landsat.select('B4').reproject({\n  crs: commonCRS,\n  scale: commonScale\n});\n\nvar sentinel1Reprojected = sentinel1.select('VV').reproject({\n  crs: commonCRS,\n  scale: commonScale\n});\n\n// Now they can be reliably combined\nvar combined = landsatReprojected.addBands(sentinel1Reprojected);\n</code></pre>"},{"location":"gee/scale_projection/#multi-temporal-analysis","title":"Multi-Temporal Analysis","text":"<p>When analyzing changes over time with data from different sensors or different acquisition geometries:</p> <pre><code>var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterBounds(region)\n  .filterDate('2015-01-01', '2020-01-01');\n\n// Force consistent projection and scale for time series analysis\nvar consistentCollection = collection.map(function(image) {\n  return image.reproject({\n    crs: 'EPSG:4326',\n    scale: 30\n  });\n});\n</code></pre>"},{"location":"gee/scale_projection/#calculating-accurate-areas-and-distances","title":"Calculating Accurate Areas and Distances","text":"<p>For accurate area and distance measurements, using an equal-area projection is essential:</p>"},{"location":"gee/scale_projection/#area-calculation","title":"Area Calculation","text":"<p>The default Web Mercator projection significantly distorts areas, especially at high latitudes. For accurate area calculations:</p> <pre><code>var forest = ee.Image('UMD/hansen/global_forest_change_2020_v1_8')\n  .select('treecover2000')\n  .gt(30);  // Areas with &gt;30% tree cover\n\n// Calculate area using an equal-area projection\nvar forestArea = forest.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: studyRegion,\n  scale: 30,\n  crs: 'EPSG:6933',  // Equal Earth projection\n  maxPixels: 1e13\n});\n\nprint('Forest area (square meters):', forestArea.get('treecover2000'));\n</code></pre>"},{"location":"gee/scale_projection/#distance-measurement","title":"Distance Measurement","text":"<p>For accurate distance calculations, especially over large areas:</p> <pre><code>// Create a function to calculate distance with appropriate projection\nfunction calculateDistance(point1, point2) {\n  // Use a projection appropriate for the region\n  var crs = 'EPSG:6933';  // Equal Earth projection\n\n  // Create a line between points\n  var line = ee.Geometry.LineString([point1, point2]);\n\n  // Calculate length with the specified projection\n  return line.length({\n    proj: crs\n  });\n}\n\nvar distance = calculateDistance(\n  [-122.4194, 37.7749],  // San Francisco\n  [-74.0060, 40.7128]    // New York\n);\nprint('Distance (meters):', distance);\n</code></pre>"},{"location":"gee/scale_projection/#custom-visualization-needs","title":"Custom Visualization Needs","text":"<p>For specific visualization requirements, controlling projection and scale ensures consistent display:</p>"},{"location":"gee/scale_projection/#creating-high-resolution-thumbnails","title":"Creating High-Resolution Thumbnails","text":"<pre><code>// Generate a high-resolution thumbnail with specific projection\nvar thumbnail = myImage.visualize({\n  bands: ['B4', 'B3', 'B2'],\n  min: 0,\n  max: 0.3\n}).reproject({\n  crs: 'EPSG:3857',\n  scale: 10  // 10-meter resolution\n});\n\n// Get the thumbnail URL\nvar thumbnailUrl = thumbnail.getThumbURL({\n  dimensions: 1024,\n  region: studyArea\n});\n</code></pre>"},{"location":"gee/scale_projection/#consistent-multi-panel-visualizations","title":"Consistent Multi-Panel Visualizations","text":"<p>When creating multiple map panels for comparison:</p> <pre><code>// Ensure all images are displayed at the same scale and projection\nvar visParams = {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3};\nvar reprojectionParams = {crs: 'EPSG:3857', scale: 30};\n\nMap.addLayer(\n  image1.reproject(reprojectionParams).visualize(visParams),\n  {},\n  'Image 1'\n);\n\nMap.addLayer(\n  image2.reproject(reprojectionParams).visualize(visParams),\n  {},\n  'Image 2'\n);\n</code></pre>"},{"location":"gee/scale_projection/#resampling-and-aggregation-operations","title":"Resampling and Aggregation Operations","text":"<p>When changing the resolution of an image or aggregating data, explicit projection control is necessary:</p>"},{"location":"gee/scale_projection/#reducing-resolution","title":"Reducing Resolution","text":"<p>The <code>reduceResolution()</code> function requires explicit scale parameters:</p> <pre><code>// Aggregate 10m Sentinel-2 data to 30m resolution\nvar sentinel2 = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\nvar ndvi = sentinel2.normalizedDifference(['B8', 'B4']);\n\n// Reduce resolution with mean aggregation\nvar aggregated = ndvi.reduceResolution({\n  reducer: ee.Reducer.mean(),\n  maxPixels: 1024\n}).reproject({\n  crs: 'EPSG:3857',\n  scale: 30  // Target resolution\n});\n</code></pre>"},{"location":"gee/scale_projection/#upsampling-for-consistent-analysis","title":"Upsampling for Consistent Analysis","text":"<p>When combining datasets with different resolutions:</p> <pre><code>// Upsample coarse resolution data to match finer resolution\nvar modisLST = ee.Image('MODIS/006/MOD11A2/2019_01_01').select('LST_Day_1km');\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20190105');\n\n// Reproject MODIS to Landsat resolution\nvar modisUpsampled = modisLST.reproject({\n  crs: landsat.projection(),\n  scale: 30  // Landsat resolution\n});\n\n// Now they can be analyzed together\nvar combined = landsat.select('B10').addBands(modisUpsampled);\n</code></pre>"},{"location":"gee/scale_projection/#regional-analysis-considerations","title":"Regional Analysis Considerations","text":"<p>Different geographic regions may require specific projections for optimal analysis:</p>"},{"location":"gee/scale_projection/#polar-regions","title":"Polar Regions","text":"<p>Standard projections like Web Mercator perform poorly near the poles. For polar studies:</p> <pre><code>// Use a polar stereographic projection for Antarctica\nvar antarctica = ee.Image('ECMWF/ERA5/MONTHLY/2019010100')\n  .select('temperature_2m')\n  .reproject({\n    crs: 'EPSG:3031',  // Antarctic Polar Stereographic\n    scale: 10000\n  });\n</code></pre>"},{"location":"gee/scale_projection/#continental-scale-analysis","title":"Continental-Scale Analysis","text":"<p>For large continental areas, equal-area projections preserve accurate area relationships:</p> <pre><code>// Continental US analysis with Albers equal-area projection\nvar usAlbers = 'EPSG:5070';  // NAD83 / Conus Albers\nvar landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover');\n\nvar agricultureArea = landcover.eq(82).multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: continentalUS,\n  scale: 30,\n  crs: usAlbers,\n  maxPixels: 1e13\n});\n</code></pre> <p>In the next section, we'll explore best practices for handling projection and scale in GEE to ensure accurate results while optimizing computational efficiency.</p>"},{"location":"gee/scale_projection/#6-best-practices-for-projection-and-scale-in-gee","title":"6. Best Practices for Projection and Scale in GEE","text":"<p>Implementing best practices for handling projection and scale in Google Earth Engine ensures accurate results while optimizing computational efficiency. This section provides practical guidelines for managing these critical aspects of geospatial analysis in GEE.</p>"},{"location":"gee/scale_projection/#letting-gee-handle-projections-dynamically","title":"Letting GEE Handle Projections Dynamically","text":"<p>In most cases, allowing GEE to manage projections automatically is the most efficient approach:</p>"},{"location":"gee/scale_projection/#when-to-rely-on-automatic-handling","title":"When to Rely on Automatic Handling","text":"<ul> <li>For exploratory analysis and visualization</li> <li>When working with a single dataset or multiple datasets in the same projection</li> <li>For operations that don't require precise area or distance measurements</li> <li>When computational efficiency is a priority</li> </ul>"},{"location":"gee/scale_projection/#example-efficient-visualization","title":"Example: Efficient Visualization","text":"<pre><code>// Let GEE handle projection automatically for visualization\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nMap.centerObject(landsat, 9);\nMap.addLayer(landsat, {bands: ['B4', 'B3', 'B2'], max: 0.3}, 'Landsat 8');\n\n// No need to specify projection - GEE will use Web Mercator for display\n</code></pre>"},{"location":"gee/scale_projection/#example-simple-band-calculations","title":"Example: Simple Band Calculations","text":"<pre><code>// For simple band calculations, let GEE handle projection\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']);\nMap.addLayer(ndvi, {min: -1, max: 1, palette: ['blue', 'white', 'green']}, 'NDVI');\n</code></pre>"},{"location":"gee/scale_projection/#checking-native-projections-before-operations","title":"Checking Native Projections Before Operations","text":"<p>Before performing operations, especially with unfamiliar datasets, check the native projection:</p>"},{"location":"gee/scale_projection/#how-to-check-projections","title":"How to Check Projections","text":"<pre><code>// Check the projection of an image\nvar image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar proj = image.projection();\nprint('Image Projection:', proj);\nprint('Scale in meters:', proj.nominalScale());\n\n// For image collections, check projection of a sample image\nvar collection = ee.ImageCollection('MODIS/006/MOD13Q1');\nvar sampleImage = collection.first();\nprint('Sample Image Projection:', sampleImage.projection());\n</code></pre>"},{"location":"gee/scale_projection/#checking-for-projection-mismatches","title":"Checking for Projection Mismatches","text":"<p>When working with multiple datasets:</p> <pre><code>// Check projections of multiple datasets\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar sentinel = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\n\nprint('Landsat Projection:', landsat.projection());\nprint('Sentinel-2 Projection:', sentinel.projection());\n\n// If projections differ significantly, consider explicit reprojection for critical analyses\n</code></pre>"},{"location":"gee/scale_projection/#using-appropriate-projections-for-area-calculations","title":"Using Appropriate Projections for Area Calculations","text":"<p>For accurate area calculations, always use an equal-area projection:</p>"},{"location":"gee/scale_projection/#equal-area-projections-in-gee","title":"Equal-Area Projections in GEE","text":"<ul> <li>EPSG:6933 (Equal Earth) - Good for global analyses</li> <li>EPSG:5070 (NAD83 / Conus Albers) - Optimized for continental US</li> <li>EPSG:3035 (ETRS89-extended / LAEA Europe) - Optimized for Europe</li> </ul>"},{"location":"gee/scale_projection/#example-accurate-forest-area-calculation","title":"Example: Accurate Forest Area Calculation","text":"<pre><code>// Calculate forest area using an equal-area projection\nvar hansen = ee.Image('UMD/hansen/global_forest_change_2020_v1_8');\nvar treecover = hansen.select('treecover2000');\nvar forest = treecover.gt(30);  // Areas with &gt;30% tree cover\n\n// Use pixelArea() and an equal-area projection\nvar forestArea = forest.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: studyRegion,\n  scale: 30,\n  crs: 'EPSG:6933',  // Equal Earth projection\n  maxPixels: 1e13\n});\n\nprint('Forest area (square meters):', forestArea.get('treecover2000'));\n</code></pre>"},{"location":"gee/scale_projection/#example-regional-area-calculation","title":"Example: Regional Area Calculation","text":"<pre><code>// For regional analysis, use a regionally optimized equal-area projection\nvar usStates = ee.FeatureCollection('TIGER/2018/States');\nvar california = usStates.filter(ee.Filter.eq('NAME', 'California'));\n\nvar landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover');\nvar urban = landcover.eq(23).or(landcover.eq(24));  // Urban land cover classes\n\nvar urbanArea = urban.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: california,\n  scale: 30,\n  crs: 'EPSG:5070',  // NAD83 / Conus Albers (optimized for US)\n  maxPixels: 1e13\n});\n\nprint('Urban area in California (square meters):', urbanArea.get('landcover'));\n</code></pre>"},{"location":"gee/scale_projection/#specifying-scale-parameters-correctly","title":"Specifying Scale Parameters Correctly","text":"<p>Proper scale specification is crucial for accurate and efficient analysis:</p>"},{"location":"gee/scale_projection/#guidelines-for-scale-selection","title":"Guidelines for Scale Selection","text":"<ol> <li>Match the analysis purpose: Use finer scales for detailed analysis, coarser scales for regional patterns</li> <li>Consider native resolution: Start with the native resolution of your primary dataset</li> <li>Balance accuracy and performance: Finer scales increase accuracy but require more computation</li> <li>Be consistent: Use the same scale for comparative analyses</li> </ol>"},{"location":"gee/scale_projection/#example-appropriate-scale-for-different-sensors","title":"Example: Appropriate Scale for Different Sensors","text":"<pre><code>// Use appropriate scales based on sensor resolution\nfunction analyzeWithAppropriateScale(image, sensor) {\n  var scale;\n\n  // Set scale based on sensor type\n  if (sensor === 'landsat') {\n    scale = 30;  // Landsat optical bands are 30m\n  } else if (sensor === 'sentinel2') {\n    scale = 10;  // Sentinel-2 visible bands are 10m\n  } else if (sensor === 'modis') {\n    scale = 250;  // MODIS NDVI is 250m\n  } else {\n    scale = 100;  // Default scale\n  }\n\n  // Perform analysis at the appropriate scale\n  var ndvi = image.normalizedDifference(['nir', 'red']);\n  var stats = ndvi.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: studyArea,\n    scale: scale,\n    maxPixels: 1e13\n  });\n\n  return stats;\n}\n</code></pre>"},{"location":"gee/scale_projection/#example-scale-parameter-in-common-functions","title":"Example: Scale Parameter in Common Functions","text":"<pre><code>// Properly specify scale in common GEE functions\nvar image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// For reduceRegion\nvar stats = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: studyArea,\n  scale: 30,  // Explicitly set scale to Landsat resolution\n  maxPixels: 1e13\n});\n\n// For sample\nvar samples = image.sample({\n  region: studyArea,\n  scale: 30,\n  numPixels: 500,\n  seed: 123\n});\n\n// For export\nExport.image.toDrive({\n  image: image.select(['B4', 'B3', 'B2']),\n  description: 'landsat_rgb',\n  scale: 30,\n  region: studyArea,\n  maxPixels: 1e13\n});\n</code></pre>"},{"location":"gee/scale_projection/#avoiding-unnecessary-reprojection","title":"Avoiding Unnecessary Reprojection","text":"<p>Unnecessary reprojection can significantly impact performance and should be avoided:</p>"},{"location":"gee/scale_projection/#when-to-avoid-reproject","title":"When to Avoid reproject()","text":"<ul> <li>For visualization purposes (GEE handles this automatically)</li> <li>When working with a single dataset</li> <li>For exploratory analysis</li> <li>When the default projection is suitable for your analysis</li> </ul>"},{"location":"gee/scale_projection/#example-inefficient-vs-efficient-approach","title":"Example: Inefficient vs. Efficient Approach","text":"<pre><code>// INEFFICIENT: Unnecessary reprojection\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar reprojected = landsat.reproject({\n  crs: 'EPSG:4326',\n  scale: 30\n});\nvar ndvi = reprojected.normalizedDifference(['B5', 'B4']);\n\n// EFFICIENT: Let GEE handle projection\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']);\n// Only specify projection when exporting or for specific analysis needs\n</code></pre>"},{"location":"gee/scale_projection/#using-reduceresolution-for-aggregation","title":"Using reduceResolution() for Aggregation","text":"<p>For changing resolution, <code>reduceResolution()</code> is more appropriate than <code>reproject()</code>:</p>"},{"location":"gee/scale_projection/#example-proper-resolution-reduction","title":"Example: Proper Resolution Reduction","text":"<pre><code>// Aggregate Sentinel-2 10m bands to 30m resolution\nvar sentinel2 = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\nvar rgb = sentinel2.select(['B4', 'B3', 'B2']);\n\n// RECOMMENDED: Use reduceResolution for aggregation\nvar aggregated = rgb.reduceResolution({\n  reducer: ee.Reducer.mean(),\n  maxPixels: 1024\n}).reproject({\n  crs: rgb.projection(),\n  scale: 30\n});\n\n// NOT RECOMMENDED: Using only reproject for aggregation\nvar reprojectedOnly = rgb.reproject({\n  crs: rgb.projection(),\n  scale: 30\n});\n</code></pre>"},{"location":"gee/scale_projection/#optimizing-computation-with-proper-scale-settings","title":"Optimizing Computation with Proper Scale Settings","text":"<p>Strategic scale selection can dramatically improve performance:</p>"},{"location":"gee/scale_projection/#multi-scale-analysis-approach","title":"Multi-Scale Analysis Approach","text":"<p>For complex analyses, consider a multi-scale approach:</p> <pre><code>// Multi-scale analysis approach\n// 1. Initial coarse-scale analysis for the entire region\nvar coarseResults = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: largeRegion,\n  scale: 1000,  // Coarse scale for efficiency\n  maxPixels: 1e13\n});\n\n// 2. Identify areas of interest based on coarse results\nvar threshold = 0.5;\nvar areasOfInterest = image.gt(threshold);\n\n// 3. Detailed analysis only in areas of interest\nvar detailedResults = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: areasOfInterest.geometry(),\n  scale: 30,  // Fine scale for accuracy\n  maxPixels: 1e13\n});\n</code></pre>"},{"location":"gee/scale_projection/#progressive-loading-for-visualization","title":"Progressive Loading for Visualization","text":"<p>For visualizing large datasets:</p> <pre><code>// Progressive loading at different scales\nMap.setOptions('HYBRID');\n\n// Add coarse overview layer (loads quickly)\nMap.addLayer(\n  image.reproject({scale: 500}),\n  visualizationParams,\n  'Overview (coarse)',\n  false\n);\n\n// Add medium resolution layer\nMap.addLayer(\n  image.reproject({scale: 100}),\n  visualizationParams,\n  'Medium resolution',\n  false\n);\n\n// Add full resolution layer (loads at native resolution when zoomed in)\nMap.addLayer(\n  image,\n  visualizationParams,\n  'Full resolution'\n);\n</code></pre>"},{"location":"gee/scale_projection/#documentation-and-reproducibility","title":"Documentation and Reproducibility","text":"<p>Proper documentation of projection and scale choices ensures reproducibility:</p>"},{"location":"gee/scale_projection/#example-self-documenting-code","title":"Example: Self-Documenting Code","text":"<pre><code>// Self-documenting projection and scale choices\nvar analysisParams = {\n  // Document why this projection was chosen\n  crs: 'EPSG:6933',  // Equal Earth projection for accurate global area calculation\n\n  // Document why this scale was chosen\n  scale: 30,  // Using Landsat native resolution to match input data\n\n  // Other parameters\n  maxPixels: 1e13\n};\n\n// Use the documented parameters\nvar results = image.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: studyRegion,\n  scale: analysisParams.scale,\n  crs: analysisParams.crs,\n  maxPixels: analysisParams.maxPixels\n});\n\n// Print parameters for reproducibility\nprint('Analysis parameters:', analysisParams);\n</code></pre> <p>By following these best practices, you can ensure accurate results while optimizing computational efficiency in your Google Earth Engine workflows. In the next section, we'll explore common errors related to projection and scale and how to troubleshoot them.</p>"},{"location":"gee/scale_projection/#7-common-errors-and-troubleshooting","title":"7. Common Errors and Troubleshooting","text":"<p>When working with projections and scale in Google Earth Engine, you may encounter various errors and challenges. This section identifies common issues and provides practical solutions to help you troubleshoot effectively.</p>"},{"location":"gee/scale_projection/#default-wgs84-projection-errors","title":"Default WGS84 Projection Errors","text":"<p>One of the most common errors in GEE relates to the default WGS84 projection with 1-degree scale:</p>"},{"location":"gee/scale_projection/#the-error-message","title":"The Error Message","text":"<pre><code>The default WGS84 projection is invalid for aggregations. Specify a scale or crs &amp; crs_transform.\n</code></pre>"},{"location":"gee/scale_projection/#why-it-occurs","title":"Why It Occurs","text":"<p>This error typically happens when: - You're reducing an <code>ImageCollection</code> containing images with different projections - You're creating a composite or mosaic from images with different projections - You're performing an aggregation operation without specifying scale parameters</p>"},{"location":"gee/scale_projection/#how-to-fix-it","title":"How to Fix It","text":"<pre><code>// PROBLEMATIC CODE\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA');\nvar mosaic = collection.filterDate('2018-01-01', '2019-01-01').mosaic();\n// This will have the default WGS84 projection with 1-degree scale\n\n// Trying to calculate statistics will cause an error\nvar stats = mosaic.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: studyArea\n  // Missing scale parameter!\n});\n\n// SOLUTION 1: Specify scale when reducing\nvar stats = mosaic.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: studyArea,\n  scale: 30,  // Explicitly set scale\n  maxPixels: 1e13\n});\n\n// SOLUTION 2: Force a specific projection before reducing\nvar reprojected = mosaic.reproject({\n  crs: 'EPSG:3857',\n  scale: 30\n});\n\nvar stats = reprojected.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: studyArea,\n  scale: 30,\n  maxPixels: 1e13\n});\n</code></pre>"},{"location":"gee/scale_projection/#scale-related-computation-issues","title":"Scale-Related Computation Issues","text":"<p>Inappropriate scale settings can lead to computation errors or unexpected results:</p>"},{"location":"gee/scale_projection/#memory-limit-exceeded","title":"Memory Limit Exceeded","text":"<pre><code>Computation timed out. Error: Computation timed out.\n</code></pre> <p>This often occurs when processing large areas at fine resolution.</p>"},{"location":"gee/scale_projection/#how-to-fix-it_1","title":"How to Fix It","text":"<pre><code>// PROBLEMATIC CODE\nvar stats = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: largeRegion,\n  scale: 10  // Very fine scale for a large region\n});\n\n// SOLUTION 1: Use a coarser scale\nvar stats = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: largeRegion,\n  scale: 100,  // Coarser scale\n  maxPixels: 1e13\n});\n\n// SOLUTION 2: Break the analysis into smaller regions\nvar subregions = largeRegion.geometry().cut(gridSize);\nvar statsCollection = ee.FeatureCollection(subregions).map(function(subregion) {\n  return ee.Feature(null, image.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: subregion,\n    scale: 10,\n    maxPixels: 1e13\n  }));\n});\n</code></pre>"},{"location":"gee/scale_projection/#unexpected-no-data-results","title":"Unexpected \"No Data\" Results","text":"<p>When your analysis returns unexpected null or \"no data\" values:</p> <pre><code>// PROBLEMATIC CODE\nvar point = ee.Geometry.Point([-122.0841, 37.4223]);\nvar value = image.reduceRegion({\n  reducer: ee.Reducer.first(),\n  geometry: point,\n  scale: 1000  // Scale much coarser than image resolution\n}).get('B4');\nprint(value);  // Might return null\n\n// SOLUTION: Use a scale appropriate to the data\nvar value = image.reduceRegion({\n  reducer: ee.Reducer.first(),\n  geometry: point,\n  scale: 30  // Match the image's native resolution\n}).get('B4');\nprint(value);  // Should return a value\n</code></pre>"},{"location":"gee/scale_projection/#handling-images-with-bands-in-different-projections","title":"Handling Images with Bands in Different Projections","text":"<p>Some images have bands with different native projections, which can cause errors:</p>"},{"location":"gee/scale_projection/#the-error-message_1","title":"The Error Message","text":"<pre><code>Image.projection: The bands of the specified image contain different projections. Use Image.select to pick a single band.\n</code></pre>"},{"location":"gee/scale_projection/#how-to-fix-it_2","title":"How to Fix It","text":"<pre><code>// PROBLEMATIC CODE\nvar sentinel2 = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\nprint(sentinel2.projection());  // Error: bands have different projections\n\n// SOLUTION 1: Select specific bands before checking projection\nvar band4 = sentinel2.select('B4');\nprint(band4.projection());  // Works for a single band\n\n// SOLUTION 2: Force a common projection for all bands\nvar reprojected = sentinel2.reproject({\n  crs: 'EPSG:3857',\n  scale: 10\n});\nprint(reprojected.projection());  // All bands now have the same projection\n</code></pre>"},{"location":"gee/scale_projection/#debugging-projection-mismatches","title":"Debugging Projection Mismatches","text":"<p>When combining datasets with different projections, unexpected results can occur:</p>"},{"location":"gee/scale_projection/#visual-misalignment","title":"Visual Misalignment","text":"<p>If layers appear misaligned when visualized together:</p> <pre><code>// PROBLEMATIC VISUALIZATION\nMap.addLayer(dataset1, {}, 'Dataset 1');\nMap.addLayer(dataset2, {}, 'Dataset 2');  // Appears misaligned\n\n// SOLUTION: Ensure consistent projection for visualization\nvar commonProjection = {crs: 'EPSG:3857', scale: 30};\nMap.addLayer(dataset1.reproject(commonProjection), {}, 'Dataset 1');\nMap.addLayer(dataset2.reproject(commonProjection), {}, 'Dataset 2');\n</code></pre>"},{"location":"gee/scale_projection/#unexpected-analysis-results","title":"Unexpected Analysis Results","text":"<p>If analysis results seem incorrect when combining datasets:</p> <pre><code>// PROBLEMATIC ANALYSIS\nvar combined = dataset1.addBands(dataset2);\nvar index = combined.normalizedDifference(['band1', 'band2']);  // Results may be incorrect\n\n// SOLUTION: Ensure consistent projection before analysis\nvar commonProjection = {crs: 'EPSG:3857', scale: 30};\nvar dataset1Reprojected = dataset1.reproject(commonProjection);\nvar dataset2Reprojected = dataset2.reproject(commonProjection);\nvar combined = dataset1Reprojected.addBands(dataset2Reprojected);\nvar index = combined.normalizedDifference(['band1', 'band2']);  // More reliable results\n</code></pre>"},{"location":"gee/scale_projection/#performance-optimization-tips","title":"Performance Optimization Tips","text":"<p>When facing performance issues related to projection and scale:</p>"},{"location":"gee/scale_projection/#slow-computation","title":"Slow Computation","text":"<pre><code>// INEFFICIENT CODE\nvar globalImage = ee.Image('MODIS/006/MOD13Q1/2019_01_01');\nvar reprojected = globalImage.reproject({\n  crs: 'EPSG:4326',\n  scale: 250\n});\nvar stats = reprojected.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: ee.Geometry.Rectangle([-180, -90, 180, 90]),  // Global extent\n  scale: 250\n});\n\n// OPTIMIZED SOLUTION\nvar globalImage = ee.Image('MODIS/006/MOD13Q1/2019_01_01');\n// Only reproject if absolutely necessary\nvar stats = globalImage.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: studyArea,  // Limit to area of interest\n  scale: 1000,  // Use coarser scale for global analysis\n  maxPixels: 1e13\n});\n</code></pre>"},{"location":"gee/scale_projection/#export-failures","title":"Export Failures","text":"<p>When exports fail due to projection or scale issues:</p> <pre><code>// PROBLEMATIC EXPORT\nExport.image.toDrive({\n  image: highResImage,\n  region: largeRegion,\n  scale: 10,  // Very fine scale\n  maxPixels: 1e8  // Default max pixels\n});\n\n// SOLUTION 1: Increase maxPixels\nExport.image.toDrive({\n  image: highResImage,\n  region: largeRegion,\n  scale: 10,\n  maxPixels: 1e13  // Increased limit\n});\n\n// SOLUTION 2: Use a more appropriate scale\nExport.image.toDrive({\n  image: highResImage,\n  region: largeRegion,\n  scale: 30,  // Coarser scale\n  maxPixels: 1e13\n});\n\n// SOLUTION 3: Break into multiple exports\n// Split the region into smaller parts and export each separately\n</code></pre>"},{"location":"gee/scale_projection/#troubleshooting-workflow","title":"Troubleshooting Workflow","text":"<p>When encountering projection or scale-related issues, follow this systematic troubleshooting workflow:</p> <ol> <li>Identify the error message: Understand what specific error you're facing</li> <li> <p>Check projections: Print the projection of all input datasets    <pre><code>print('Dataset 1 projection:', dataset1.projection());\nprint('Dataset 2 projection:', dataset2.projection());\n</code></pre></p> </li> <li> <p>Verify scale parameters: Ensure scale parameters are appropriate for your data and analysis    <pre><code>print('Native scale in meters:', dataset1.projection().nominalScale());\n</code></pre></p> </li> <li> <p>Test with simplified data: Reduce the complexity of your analysis to isolate the issue    <pre><code>// Test with a single band\nvar singleBand = dataset1.select('B4');\n</code></pre></p> </li> <li> <p>Implement explicit projection control: When automatic handling fails, take manual control    <pre><code>var controlled = dataset1.reproject({\n  crs: 'EPSG:3857',\n  scale: 30\n});\n</code></pre></p> </li> <li> <p>Monitor computation resources: Check if you're exceeding memory or processing limits    <pre><code>// Reduce the size of your analysis\nvar smallerRegion = largeRegion.bounds().buffer(-10000);\n</code></pre></p> </li> <li> <p>Optimize step by step: Incrementally improve your code, testing after each change</p> </li> </ol> <p>By understanding these common errors and their solutions, you can effectively troubleshoot projection and scale issues in Google Earth Engine, ensuring accurate results and efficient computation. In the next section, we'll explore practical examples with complete code to demonstrate these concepts in real-world scenarios.</p>"},{"location":"gee/scale_projection/#8-practical-examples-with-code","title":"8. Practical Examples with Code","text":"<p>This section provides complete, practical examples that demonstrate how to effectively handle projection and scale in Google Earth Engine. Each example addresses a common geospatial analysis scenario with fully functional code and detailed explanations.</p>"},{"location":"gee/scale_projection/#example-1-checking-an-images-native-projection-and-scale","title":"Example 1: Checking an Image's Native Projection and Scale","text":"<p>Understanding the native projection and scale of your data is the first step in any GEE analysis. This example demonstrates how to retrieve and interpret this information.</p> <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Get the projection information\nvar projection = landsat.projection();\nprint('Landsat 8 projection:', projection);\n\n// Get the nominal scale (resolution) in meters\nvar scale = projection.nominalScale();\nprint('Nominal scale in meters:', scale);\n\n// Check projection of a specific band\nvar nirBand = landsat.select('B5');\nprint('NIR band projection:', nirBand.projection());\n\n// Load a MODIS image for comparison\nvar modis = ee.Image('MODIS/006/MOD13Q1/2019_01_01');\nprint('MODIS projection:', modis.projection());\nprint('MODIS nominal scale in meters:', modis.projection().nominalScale());\n\n// Visualize the Landsat image\nMap.centerObject(landsat, 9);\nMap.addLayer(landsat, {bands: ['B4', 'B3', 'B2'], max: 0.3}, 'Landsat 8 True Color');\n</code></pre> <p>Key Points: - The <code>projection()</code> method returns an <code>ee.Projection</code> object containing CRS and transformation information - <code>nominalScale()</code> returns the native resolution in meters - Different datasets have different native projections and scales - Understanding these properties helps you make informed decisions about analysis parameters</p>"},{"location":"gee/scale_projection/#example-2-working-with-multiple-datasets-with-different-projections","title":"Example 2: Working with Multiple Datasets with Different Projections","text":"<p>This example demonstrates how to properly combine and analyze datasets with different native projections.</p> <pre><code>// Load datasets with different projections\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar sentinel2 = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\nvar dem = ee.Image('USGS/SRTMGL1_003');\n\n// Print their native projections\nprint('Landsat projection:', landsat.projection());\nprint('Sentinel-2 projection:', sentinel2.select('B4').projection());\nprint('SRTM DEM projection:', dem.projection());\n\n// Define a region of interest where the datasets overlap\nvar roi = landsat.geometry().intersection(sentinel2.geometry());\nMap.centerObject(roi, 10);\n\n// Calculate NDVI from both Landsat and Sentinel-2\nvar landsatNDVI = landsat.normalizedDifference(['B5', 'B4']).rename('landsat_ndvi');\nvar sentinel2NDVI = sentinel2.normalizedDifference(['B8', 'B4']).rename('sentinel2_ndvi');\n\n// Method 1: Let GEE handle projections automatically\nvar ndviDifference = sentinel2NDVI.subtract(landsatNDVI).rename('ndvi_diff');\n\n// Method 2: Explicitly control projection\nvar commonProjection = {\n  crs: 'EPSG:3857',\n  scale: 30\n};\n\nvar landsatNDVI_reprojected = landsatNDVI.reproject(commonProjection);\nvar sentinel2NDVI_reprojected = sentinel2NDVI.reproject(commonProjection);\nvar ndviDifference_controlled = sentinel2NDVI_reprojected.subtract(landsatNDVI_reprojected);\n\n// Add elevation data\nvar elevation = dem.clip(roi);\n\n// Create a composite with multiple datasets\nvar composite = ee.Image.cat([\n  landsatNDVI_reprojected,\n  sentinel2NDVI_reprojected,\n  ndviDifference_controlled,\n  elevation\n]).reproject(commonProjection);\n\n// Visualize results\nMap.addLayer(landsatNDVI, {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, 'Landsat NDVI');\nMap.addLayer(sentinel2NDVI, {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, 'Sentinel-2 NDVI', false);\nMap.addLayer(ndviDifference, {min: -0.2, max: 0.2, palette: ['red', 'white', 'green']}, 'NDVI Difference (Auto)', false);\nMap.addLayer(ndviDifference_controlled, {min: -0.2, max: 0.2, palette: ['red', 'white', 'green']}, 'NDVI Difference (Controlled)');\n</code></pre> <p>Key Points: - GEE can automatically align datasets with different projections - For critical analyses, explicitly controlling projection ensures consistency - When combining multiple datasets, consider using a common projection that minimizes distortion for your study area - Visualize intermediate results to verify proper alignment</p>"},{"location":"gee/scale_projection/#example-3-proper-area-calculation-with-equal-area-projections","title":"Example 3: Proper Area Calculation with Equal-Area Projections","text":"<p>This example demonstrates how to calculate accurate areas using appropriate projections.</p> <pre><code>// Load global forest cover data\nvar hansen = ee.Image('UMD/hansen/global_forest_change_2020_v1_8');\nvar treecover = hansen.select('treecover2000');\nvar forest = treecover.gt(30);  // Areas with &gt;30% tree cover\n\n// Define regions for comparison\nvar equatorial = ee.Geometry.Rectangle([20, -10, 40, 10]);  // Equatorial Africa\nvar highLatitude = ee.Geometry.Rectangle([20, 50, 40, 70]);  // Northern Europe\n\n// Calculate forest area using different projections\nfunction calculateArea(region, name) {\n  // Method 1: Using Web Mercator (INCORRECT for area calculations)\n  var areaWM = forest.multiply(ee.Image.pixelArea()).reduceRegion({\n    reducer: ee.Reducer.sum(),\n    geometry: region,\n    scale: 30,\n    crs: 'EPSG:3857',  // Web Mercator\n    maxPixels: 1e13\n  }).get('treecover2000');\n\n  // Method 2: Using WGS84 (INCORRECT for area calculations)\n  var areaWGS = forest.multiply(ee.Image.pixelArea()).reduceRegion({\n    reducer: ee.Reducer.sum(),\n    geometry: region,\n    scale: 30,\n    crs: 'EPSG:4326',  // WGS84\n    maxPixels: 1e13\n  }).get('treecover2000');\n\n  // Method 3: Using Equal Earth (CORRECT for area calculations)\n  var areaEE = forest.multiply(ee.Image.pixelArea()).reduceRegion({\n    reducer: ee.Reducer.sum(),\n    geometry: region,\n    scale: 30,\n    crs: 'EPSG:6933',  // Equal Earth\n    maxPixels: 1e13\n  }).get('treecover2000');\n\n  // Print results\n  print(name + ' forest area (Web Mercator):', areaWM);\n  print(name + ' forest area (WGS84):', areaWGS);\n  print(name + ' forest area (Equal Earth):', areaEE);\n\n  return ee.Feature(null, {\n    'region': name,\n    'web_mercator': areaWM,\n    'wgs84': areaWGS,\n    'equal_earth': areaEE\n  });\n}\n\n// Calculate and compare areas\nvar equatorialAreas = calculateArea(equatorial, 'Equatorial');\nvar highLatitudeAreas = calculateArea(highLatitude, 'High Latitude');\n\n// Visualize the regions and forest cover\nMap.setCenter(30, 30, 4);\nMap.addLayer(forest.clip(equatorial.union(highLatitude)), {palette: ['black', 'green']}, 'Forest Cover');\nMap.addLayer(equatorial, {color: 'blue'}, 'Equatorial Region');\nMap.addLayer(highLatitude, {color: 'red'}, 'High Latitude Region');\n\n// Create a chart to compare the results\nvar chart = ui.Chart.feature.byFeature([equatorialAreas, highLatitudeAreas], 'region', ['web_mercator', 'wgs84', 'equal_earth'])\n  .setChartType('ColumnChart')\n  .setOptions({\n    title: 'Forest Area by Projection and Region',\n    vAxis: {title: 'Area (square meters)'},\n    hAxis: {title: 'Region'},\n    series: {\n      0: {color: 'blue'},\n      1: {color: 'red'},\n      2: {color: 'green'}\n    }\n  });\nprint(chart);\n</code></pre> <p>Key Points: - Web Mercator (EPSG:3857) significantly distorts areas, especially at high latitudes - WGS84 (EPSG:4326) also introduces area distortions - Equal Earth (EPSG:6933) preserves area relationships and provides accurate measurements - The difference between projections becomes more pronounced at higher latitudes - Always use an equal-area projection for area calculations</p>"},{"location":"gee/scale_projection/#example-4-exporting-data-with-specific-projections-and-scales","title":"Example 4: Exporting Data with Specific Projections and Scales","text":"<p>This example demonstrates how to properly export data with controlled projection and scale settings.</p> <pre><code>// Load and prepare data\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']).rename('ndvi');\nvar rgb = landsat.select(['B4', 'B3', 'B2']);\n\n// Define export region\nvar exportRegion = landsat.geometry().bounds();\nMap.centerObject(exportRegion, 9);\nMap.addLayer(rgb, {max: 0.3}, 'RGB');\nMap.addLayer(ndvi, {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, 'NDVI');\n\n// Example 1: Export at native Landsat resolution in UTM projection\nExport.image.toDrive({\n  image: ndvi,\n  description: 'NDVI_UTM_30m',\n  folder: 'GEE_Exports',\n  region: exportRegion,\n  scale: 30,\n  crs: landsat.projection(),  // Use the native UTM projection\n  maxPixels: 1e13,\n  fileFormat: 'GeoTIFF'\n});\n\n// Example 2: Export at 10m resolution in Web Mercator\nExport.image.toDrive({\n  image: ndvi,\n  description: 'NDVI_WebMercator_10m',\n  folder: 'GEE_Exports',\n  region: exportRegion,\n  scale: 10,  // Higher resolution than native\n  crs: 'EPSG:3857',  // Web Mercator\n  maxPixels: 1e13,\n  fileFormat: 'GeoTIFF'\n});\n\n// Example 3: Export at coarser resolution in WGS84\nExport.image.toDrive({\n  image: ndvi,\n  description: 'NDVI_WGS84_100m',\n  folder: 'GEE_Exports',\n  region: exportRegion,\n  scale: 100,  // Coarser resolution\n  crs: 'EPSG:4326',  // WGS84\n  maxPixels: 1e13,\n  fileFormat: 'GeoTIFF'\n});\n\n// Example 4: Export RGB composite with custom dimensions\nExport.image.toDrive({\n  image: rgb,\n  description: 'RGB_Custom_Dimensions',\n  folder: 'GEE_Exports',\n  region: exportRegion,\n  dimensions: 1024,  // Fixed pixel dimensions instead of scale\n  crs: 'EPSG:3857',\n  maxPixels: 1e13,\n  fileFormat: 'GeoTIFF'\n});\n\n// Print export information\nprint('Export region area (sq km):', exportRegion.area().divide(1e6));\nprint('Native Landsat resolution (m):', landsat.projection().nominalScale());\n</code></pre> <p>Key Points: - The <code>scale</code> parameter determines the pixel size in meters - The <code>crs</code> parameter determines the coordinate reference system - Using the native projection and scale is often optimal for preserving data integrity - Exporting at finer scales than native resolution doesn't add real information but increases file size - The <code>dimensions</code> parameter can be used instead of <code>scale</code> to control output size - Consider file size and intended use when selecting export parameters</p>"},{"location":"gee/scale_projection/#example-5-visualizing-effects-of-different-projections","title":"Example 5: Visualizing Effects of Different Projections","text":"<p>This example demonstrates the visual effects of different projections, particularly for global datasets.</p> <pre><code>// Load a global dataset\nvar worldPopulation = ee.ImageCollection('CIESIN/GPWv411/GPW_Population_Count')\n  .first()\n  .select('population_count');\n\n// Function to reproject and visualize with different projections\nfunction addProjectedLayer(projection, name, center, zoom) {\n  var reprojected = worldPopulation.reproject({\n    crs: projection,\n    scale: 10000\n  });\n\n  Map.addLayer(reprojected, {\n    min: 0,\n    max: 1000,\n    palette: ['blue', 'yellow', 'red']\n  }, name, false);\n\n  // Add a button to center the map on this projection view\n  var button = ui.Button({\n    label: 'View: ' + name,\n    onClick: function() {\n      Map.setCenter(center[0], center[1], zoom);\n    }\n  });\n  panel.add(button);\n}\n\n// Create a panel for projection buttons\nvar panel = ui.Panel({\n  style: {\n    position: 'top-right',\n    padding: '8px'\n  }\n});\nMap.add(panel);\n\n// Add layers with different projections\naddProjectedLayer('EPSG:3857', 'Web Mercator', [0, 0], 2);\naddProjectedLayer('EPSG:4326', 'WGS84', [0, 0], 2);\naddProjectedLayer('EPSG:6933', 'Equal Earth', [0, 0], 2);\naddProjectedLayer('EPSG:3031', 'Antarctic Polar Stereographic', [0, -90], 3);\naddProjectedLayer('EPSG:3995', 'Arctic Polar Stereographic', [0, 90], 3);\naddProjectedLayer('EPSG:54009', 'Mollweide', [0, 0], 2);\n\n// Add country boundaries for reference\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nMap.addLayer(countries, {color: 'white'}, 'Country Boundaries');\n\n// Set initial view\nMap.setCenter(0, 0, 2);\nMap.setOptions('HYBRID');\n</code></pre> <p>Key Points: - Different projections represent the Earth's curved surface in different ways - Web Mercator (EPSG:3857) preserves angles but distorts areas, especially at high latitudes - Equal Earth (EPSG:6933) preserves area relationships but distorts shapes - Polar projections are optimized for high latitudes - The choice of projection affects how data is visualized and analyzed - No single projection is perfect for all purposes</p> <p>These practical examples demonstrate how to effectively handle projection and scale in various Google Earth Engine workflows. By applying these techniques, you can ensure accurate analyses while optimizing computational efficiency. In the next section, we'll explore advanced topics related to projection and scale in GEE.</p>"},{"location":"gee/scale_projection/#9-advanced-topics","title":"9. Advanced Topics","text":"<p>This section explores specialized and advanced concepts related to projection and scale in Google Earth Engine. These topics are particularly relevant for complex analyses, large-scale applications, and users seeking to optimize their GEE workflows.</p>"},{"location":"gee/scale_projection/#working-with-multi-resolution-datasets","title":"Working with Multi-Resolution Datasets","text":"<p>Many remote sensing applications require combining data from sensors with different native resolutions. This presents unique challenges for maintaining data integrity while optimizing computational efficiency.</p>"},{"location":"gee/scale_projection/#strategies-for-multi-resolution-analysis","title":"Strategies for Multi-Resolution Analysis","text":"<p>When working with multi-resolution datasets, consider these approaches:</p> <ol> <li>Resolution Harmonization: Reproject all datasets to a common resolution</li> <li>Typically set to the coarsest resolution among input datasets to avoid creating artificial data</li> <li> <p>Alternatively, set to the finest resolution when detail preservation is critical</p> </li> <li> <p>Resolution-Aware Processing: Process each dataset at its native resolution before combining results</p> </li> <li>Preserves the unique information content of each dataset</li> <li> <p>Reduces computational overhead from unnecessary upsampling</p> </li> <li> <p>Hierarchical Multi-Scale Analysis: Process data at multiple scales sequentially</p> </li> <li>Begin with coarse resolution for broad patterns</li> <li>Progressively refine analysis in areas of interest using finer resolution data</li> </ol>"},{"location":"gee/scale_projection/#example-combining-landsat-and-modis-data","title":"Example: Combining Landsat and MODIS Data","text":"<pre><code>// Load Landsat (30m) and MODIS (500m) data\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar modis = ee.Image('MODIS/006/MOD09GA/2014_03_18');\n\n// Approach 1: Harmonize to coarser resolution (MODIS)\nvar landsatCoarse = landsat.select(['B4', 'B3', 'B2']).reduceResolution({\n  reducer: ee.Reducer.mean(),\n  maxPixels: 1024\n}).reproject({\n  crs: modis.projection(),\n  scale: 500\n});\n\n// Approach 2: Maintain Landsat resolution but incorporate MODIS data\nvar modisUpsampled = modis.select(['sur_refl_b01', 'sur_refl_b04', 'sur_refl_b03'])\n  .reproject({\n    crs: landsat.projection(),\n    scale: 30\n  });\n\n// Approach 3: Multi-scale analysis\n// First identify areas of interest at MODIS scale\nvar modisNDVI = modis.normalizedDifference(['sur_refl_b02', 'sur_refl_b01']);\nvar highNDVIAreas = modisNDVI.gt(0.7);\n\n// Then analyze these areas at Landsat resolution\nvar landsatNDVI = landsat.normalizedDifference(['B5', 'B4']);\nvar detailedAnalysis = landsatNDVI.updateMask(highNDVIAreas);\n</code></pre>"},{"location":"gee/scale_projection/#projection-issues-in-different-geographic-regions","title":"Projection Issues in Different Geographic Regions","text":"<p>Different geographic regions present unique projection challenges that require specialized approaches.</p>"},{"location":"gee/scale_projection/#polar-regions_1","title":"Polar Regions","text":"<p>The poles present particular challenges for projection and scale:</p> <ul> <li>Extreme Distortion: Standard projections like Web Mercator become extremely distorted near the poles</li> <li>Convergence of Meridians: Longitude lines converge at the poles, causing computational issues</li> <li>Crossing the Dateline: Analysis across the 180\u00b0 meridian requires special handling</li> </ul> <p>For polar studies, use specialized polar projections: - Antarctic Polar Stereographic (EPSG:3031) for the South Pole region - Arctic Polar Stereographic (EPSG:3995) for the North Pole region</p> <pre><code>// Antarctic ice sheet analysis\nvar antarctica = ee.Geometry.Rectangle([-180, -90, 180, -60]);\nvar iceVelocity = ee.Image('CPOM/CryoSat2/ANTARCTICA_ICE_VELOCITY_2016');\n\n// Use appropriate polar projection\nvar polarProjection = {\n  crs: 'EPSG:3031',  // Antarctic Polar Stereographic\n  scale: 500\n};\n\n// Analyze with proper projection\nvar iceVelocityStats = iceVelocity.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: antarctica,\n  crs: polarProjection.crs,\n  scale: polarProjection.scale,\n  maxPixels: 1e13\n});\n</code></pre>"},{"location":"gee/scale_projection/#equatorial-regions","title":"Equatorial Regions","text":"<p>Equatorial regions generally have minimal projection distortion in most systems, but considerations include:</p> <ul> <li>UTM Zone Transitions: Studies spanning multiple UTM zones require careful handling</li> <li>Seasonal Sun Angle Variations: Less extreme than polar regions but still relevant for time series</li> </ul>"},{"location":"gee/scale_projection/#continental-scale-analysis_1","title":"Continental-Scale Analysis","text":"<p>For large continental analyses, specialized equal-area projections optimized for specific continents provide the best results:</p> <ul> <li>North America: Albers Equal Area Conic (EPSG:5070)</li> <li>Europe: ETRS89-extended / LAEA Europe (EPSG:3035)</li> <li>Africa: Africa Albers Equal Area Conic (ESRI:102022)</li> </ul> <pre><code>// Continental US analysis with appropriate projection\nvar usStates = ee.FeatureCollection('TIGER/2018/States');\nvar continentalUS = usStates.filter(ee.Filter.inList('NAME', [\n  'Washington', 'Oregon', 'California', 'Nevada', 'Idaho', 'Montana', 'Wyoming',\n  'Utah', 'Colorado', 'Arizona', 'New Mexico', 'North Dakota', 'South Dakota',\n  'Nebraska', 'Kansas', 'Oklahoma', 'Texas', 'Minnesota', 'Iowa', 'Missouri',\n  'Arkansas', 'Louisiana', 'Wisconsin', 'Illinois', 'Michigan', 'Indiana', 'Ohio',\n  'Kentucky', 'Tennessee', 'Mississippi', 'Alabama', 'Georgia', 'Florida',\n  'South Carolina', 'North Carolina', 'Virginia', 'West Virginia', 'Maryland',\n  'Delaware', 'Pennsylvania', 'New Jersey', 'New York', 'Connecticut',\n  'Rhode Island', 'Massachusetts', 'Vermont', 'New Hampshire', 'Maine'\n])).geometry();\n\n// Use Albers Equal Area Conic projection for US\nvar usAnalysis = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\n  .reduceRegion({\n    reducer: ee.Reducer.frequencyHistogram(),\n    geometry: continentalUS,\n    crs: 'EPSG:5070',  // NAD83 / Conus Albers\n    scale: 90,\n    maxPixels: 1e13\n  });\n</code></pre>"},{"location":"gee/scale_projection/#scale-and-projection-considerations-for-time-series-analysis","title":"Scale and Projection Considerations for Time-Series Analysis","text":"<p>Time-series analysis presents unique challenges for maintaining consistent scale and projection across temporal datasets.</p>"},{"location":"gee/scale_projection/#ensuring-temporal-consistency","title":"Ensuring Temporal Consistency","text":"<p>For accurate time-series analysis:</p> <ol> <li>Consistent Projection: Use the same projection for all time points</li> <li>Consistent Scale: Process all images at the same scale</li> <li>Consistent Geometry: Ensure analysis boundaries remain fixed</li> </ol> <pre><code>// Time series analysis with consistent projection and scale\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterBounds(region)\n  .filterDate('2015-01-01', '2020-01-01');\n\n// Define consistent parameters\nvar analysisParams = {\n  crs: 'EPSG:3857',\n  scale: 30\n};\n\n// Process each image with consistent parameters\nvar processedCollection = collection.map(function(image) {\n  var ndvi = image.normalizedDifference(['B5', 'B4']);\n\n  // Force consistent projection and scale\n  return ndvi.reproject({\n    crs: analysisParams.crs,\n    scale: analysisParams.scale\n  }).set({\n    'system:time_start': image.get('system:time_start')\n  });\n});\n\n// Time series chart with consistent processing\nvar chart = ui.Chart.image.series({\n  imageCollection: processedCollection,\n  region: region,\n  reducer: ee.Reducer.mean(),\n  scale: analysisParams.scale\n}).setOptions({\n  title: 'NDVI Time Series',\n  vAxis: {title: 'NDVI'},\n  hAxis: {title: 'Date', format: 'MM-yyyy'}\n});\n</code></pre>"},{"location":"gee/scale_projection/#handling-sensor-transitions","title":"Handling Sensor Transitions","text":"<p>When analyzing time series that span multiple sensors (e.g., Landsat 5 to Landsat 8):</p> <ol> <li>Cross-Calibration: Apply sensor-specific corrections before analysis</li> <li>Resolution Harmonization: Ensure consistent resolution across sensors</li> <li>Projection Alignment: Reproject to a common system</li> </ol> <pre><code>// Harmonized Landsat time series across sensors\nvar landsat5 = ee.ImageCollection('LANDSAT/LT05/C02/T1_TOA')\n  .filterBounds(region)\n  .filterDate('2010-01-01', '2012-01-01');\n\nvar landsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterBounds(region)\n  .filterDate('2013-01-01', '2015-01-01');\n\n// Harmonize Landsat 5 bands to match Landsat 8\nvar processL5 = function(image) {\n  // Cross-calibration coefficients (simplified example)\n  var ndvi = image.normalizedDifference(['B4', 'B3'])\n    .multiply(1.0).add(0.03);  // Adjust NDVI to match L8\n\n  return ndvi.reproject({\n    crs: 'EPSG:3857',\n    scale: 30\n  }).set({\n    'system:time_start': image.get('system:time_start'),\n    'sensor': 'L5'\n  });\n};\n\n// Process Landsat 8 with same projection and scale\nvar processL8 = function(image) {\n  var ndvi = image.normalizedDifference(['B5', 'B4']);\n\n  return ndvi.reproject({\n    crs: 'EPSG:3857',\n    scale: 30\n  }).set({\n    'system:time_start': image.get('system:time_start'),\n    'sensor': 'L8'\n  });\n};\n\n// Create harmonized collection\nvar harmonizedCollection = landsat5.map(processL5)\n  .merge(landsat8.map(processL8))\n  .sort('system:time_start');\n</code></pre>"},{"location":"gee/scale_projection/#custom-projection-transformations","title":"Custom Projection Transformations","text":"<p>For specialized analyses, you may need to create custom projections or transformations.</p>"},{"location":"gee/scale_projection/#creating-custom-projections","title":"Creating Custom Projections","text":"<pre><code>// Create a custom projection centered on a study area\nvar centerPoint = ee.Geometry.Point([35, 0]);\n\n// Create an Albers Equal Area projection centered on the study area\nvar customProjection = ee.Projection('EPSG:4326')\n  .translate(centerPoint.coordinates().get(0), centerPoint.coordinates().get(1))\n  .scale(100, 100);  // 100-meter scale\n\n// Use the custom projection\nvar reprojected = image.reproject({\n  crs: customProjection,\n  scale: 100\n});\n</code></pre>"},{"location":"gee/scale_projection/#working-with-projection-transforms","title":"Working with Projection Transforms","text":"<p>For advanced users, understanding and manipulating projection transforms provides fine-grained control:</p> <pre><code>// Extract and modify projection transform\nvar projection = image.projection();\nvar transform = projection.getInfo().transform;\n\n// Create a modified transform (e.g., to rotate or skew)\nvar modifiedTransform = [\n  transform[0], transform[1], transform[2],\n  transform[3], transform[4], transform[5]\n];\n\n// Apply the modified transform\nvar customProjection = ee.Projection(projection.getInfo().crs, modifiedTransform);\nvar reprojected = image.reproject({\n  crs: customProjection\n});\n</code></pre>"},{"location":"gee/scale_projection/#performance-implications-of-projection-and-scale-choices","title":"Performance Implications of Projection and Scale Choices","text":"<p>Projection and scale choices significantly impact computational performance in GEE.</p>"},{"location":"gee/scale_projection/#memory-usage-optimization","title":"Memory Usage Optimization","text":"<pre><code>// Memory-efficient approach for large-area analysis\nvar globalImage = ee.Image('MODIS/006/MOD13Q1/2019_01_01');\n\n// INEFFICIENT: Process at fine scale globally\nvar inefficient = globalImage.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: ee.Geometry.Rectangle([-180, -90, 180, 90]),\n  scale: 250,  // Fine scale globally requires massive computation\n  maxPixels: 1e13\n});\n\n// EFFICIENT: Two-step approach\n// 1. Process at coarse scale globally\nvar coarseResults = globalImage.reduceResolution({\n  reducer: ee.Reducer.mean(),\n  maxPixels: 1024\n}).reproject({\n  crs: 'EPSG:4326',\n  scale: 1000\n}).reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: ee.Geometry.Rectangle([-180, -90, 180, 90]),\n  scale: 1000,\n  maxPixels: 1e13\n});\n\n// 2. Process at fine scale only for areas of interest\nvar areasOfInterest = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Rectangle([30, -10, 40, 10])),  // East Africa\n  ee.Feature(ee.Geometry.Rectangle([-120, 30, -100, 50]))  // Western US\n]);\n\nvar detailedResults = areasOfInterest.map(function(region) {\n  return globalImage.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: region.geometry(),\n    scale: 250,  // Fine scale only where needed\n    maxPixels: 1e13\n  });\n});\n</code></pre>"},{"location":"gee/scale_projection/#computation-time-optimization","title":"Computation Time Optimization","text":"<p>Strategic projection and scale choices can dramatically reduce computation time:</p> <ol> <li>Progressive Refinement: Start with coarse analyses and refine only in areas of interest</li> <li>Appropriate Scale Selection: Use the coarsest scale that still captures the phenomena of interest</li> <li>Projection Minimization: Avoid unnecessary reprojection operations</li> <li>Tiling Strategies: Break large areas into smaller tiles for parallel processing</li> </ol> <pre><code>// Tiling strategy for large-area analysis\nvar largeRegion = ee.Geometry.Rectangle([30, -10, 45, 10]);\n\n// Create a grid of tiles\nvar tiles = function(region, size) {\n  var bounds = region.bounds();\n  var coords = ee.List(bounds.coordinates().get(0));\n  var ll = ee.List(coords.get(0));\n  var ur = ee.List(coords.get(2));\n  var x0 = ee.Number(ll.get(0));\n  var y0 = ee.Number(ll.get(1));\n  var x1 = ee.Number(ur.get(0));\n  var y1 = ee.Number(ur.get(1));\n  var dx = x1.subtract(x0).divide(size);\n  var dy = y1.subtract(y0).divide(size);\n\n  var grid = ee.FeatureCollection(\n    ee.List.sequence(0, size - 1).map(function(i) {\n      return ee.List.sequence(0, size - 1).map(function(j) {\n        var x = x0.add(dx.multiply(i));\n        var y = y0.add(dy.multiply(j));\n        var rect = ee.Geometry.Rectangle([\n          x, y, x.add(dx), y.add(dy)\n        ]);\n        return ee.Feature(rect);\n      });\n    }).flatten()\n  );\n\n  return grid;\n};\n\n// Create a 4x4 grid of tiles\nvar grid = tiles(largeRegion, 4);\n\n// Process each tile in parallel\nvar results = grid.map(function(tile) {\n  return image.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: tile.geometry(),\n    scale: 30,\n    maxPixels: 1e13\n  });\n});\n</code></pre> <p>By mastering these advanced topics, you can tackle complex geospatial challenges in Google Earth Engine with greater accuracy and efficiency. The concepts presented here build upon the fundamental principles of projection and scale to address specialized analytical needs and optimize performance for demanding applications.</p>"},{"location":"gee/0.%20Supplementary/1.%20Keyboard%20Shortcuts%20for%20Google%20Earth%20Engine/","title":"Google Earth Engine Code Editor Shortcuts","text":""},{"location":"gee/0.%20Supplementary/1.%20Keyboard%20Shortcuts%20for%20Google%20Earth%20Engine/#general-editing-shortcuts","title":"General Editing Shortcuts","text":"Shortcut Action <code>Ctrl + /</code> (or <code>Cmd + /</code>) Toggle comment/uncomment on selected lines <code>Ctrl + Z</code> (or <code>Cmd + Z</code>) Undo <code>Ctrl + Shift + Z</code> (or <code>Cmd + Shift + Z</code>) Redo <code>Ctrl + C</code> (or <code>Cmd + C</code>) Copy selected text <code>Ctrl + X</code> (or <code>Cmd + X</code>) Cut selected text <code>Ctrl + V</code> (or <code>Cmd + V</code>) Paste <code>Ctrl + F</code> (or <code>Cmd + F</code>) Find in code <code>Ctrl + Shift + F</code> (or <code>Cmd + Shift + F</code>) Find and replace <code>Tab</code> Indent selected line(s) <code>Shift + Tab</code> Unindent selected line(s)"},{"location":"gee/0.%20Supplementary/1.%20Keyboard%20Shortcuts%20for%20Google%20Earth%20Engine/#code-navigation-shortcuts","title":"Code Navigation Shortcuts","text":"Shortcut Action <code>Ctrl + Space</code> Trigger code autocomplete <code>Ctrl + Shift + D</code> Duplicate current line or selection <code>Ctrl + [Arrow Up/Down]</code> Move line(s) up or down <code>Ctrl + Home</code> Go to the top of the script <code>Ctrl + End</code> Go to the end of the script <code>Alt + [Arrow Up/Down]</code> Navigate up/down through multi-line selections"},{"location":"gee/0.%20Supplementary/1.%20Keyboard%20Shortcuts%20for%20Google%20Earth%20Engine/#console-output-shortcuts","title":"Console &amp; Output Shortcuts","text":"Shortcut Action <code>Ctrl + Enter</code> Run the script <code>Ctrl + Shift + Enter</code> Save the script and run it <code>Esc</code> Close the current dialog (if any) <code>Shift + Click on Console Panel</code> Toggle console open/close"},{"location":"gee/0.%20Supplementary/1.%20Keyboard%20Shortcuts%20for%20Google%20Earth%20Engine/#map-shortcuts","title":"Map Shortcuts","text":"Shortcut Action <code>Shift + Scroll</code> Zoom in/out <code>Shift + Click + Drag</code> Pan map <code>Double Click on Map</code> Zoom in at clicked location"},{"location":"gee/0.%20Supplementary/1.%20Keyboard%20Shortcuts%20for%20Google%20Earth%20Engine/#help-documentation-shortcuts","title":"Help &amp; Documentation Shortcuts","text":"Shortcut Action <code>Ctrl + Shift + /</code> Open documentation search <code>Ctrl + Shift + P</code> Quick command palette"},{"location":"gee/0.%20Supplementary/10Days/","title":"GEE Training Draft","text":""},{"location":"gee/0.%20Supplementary/10Days/#10-day-google-earth-engine-gee-training-schedule","title":"\ud83d\udcc5 10-Day Google Earth Engine (GEE) Training Schedule","text":""},{"location":"gee/0.%20Supplementary/10Days/#day-1-introduction-to-google-earth-engine-gee","title":"\ud83d\ude80 Day 1: Introduction to Google Earth Engine (GEE)","text":"<p>\ud83d\udd39 What is GEE? Overview of cloud computing for geospatial analysis. \ud83d\udd39 Why GEE? Advantages: time-efficient, cost-effective, and scalable. \ud83d\udd39 How GEE works? Cloud-based processing, parallel computation. \ud83d\udd39 GEE Use Cases: Deforestation monitoring, climate analysis, urban expansion, etc. \ud83d\udd39 GEE Interface Walkthrough: Code Editor UI, Assets, Docs, and Help sections.</p> <p>\ud83d\udccc Hands-on Task: \u2705 Sign up for GEE (https://earthengine.google.com/) \u2705 Explore Code Editor and run a sample script.</p>"},{"location":"gee/0.%20Supplementary/10Days/#day-2-data-types-in-javascript-js-basics-for-gee","title":"\ud83d\udcc5 Day 2: Data Types in JavaScript (JS Basics for GEE)","text":"<p>\ud83d\udd39 Data Types in JS: <code>ee.Number</code>, <code>ee.String</code>, <code>ee.List</code>, <code>ee.Dictionary</code>. \ud83d\udd39 JS Syntax in GEE: Writing scripts for geospatial analysis. \ud83d\udd39 Understanding functions: Basics of function writing.</p> <p>\ud83d\udccc Hands-on Task: \u2705 Write a JavaScript script to define variables and run simple operations in GEE.</p>"},{"location":"gee/0.%20Supplementary/10Days/#day-3-data-types-in-google-earth-engine-gee-specific","title":"\ud83d\udcc5 Day 3: Data Types in Google Earth Engine (GEE Specific)","text":"<p>\ud83d\udd39 GEE Data Types:</p> <ul> <li><code>ee.Geometry</code>, <code>ee.Feature</code>, <code>ee.FeatureCollection</code></li> <li><code>ee.Image</code>, <code>ee.ImageCollection</code>     \ud83d\udd39 Differences between JS and GEE data types.     \ud83d\udd39 Working with FeatureCollections and ImageCollections.</li> </ul> <p>\ud83d\udccc Hands-on Task: \u2705 Load a dataset (e.g., Landsat, MODIS, Sentinel-2) and explore its properties.</p>"},{"location":"gee/0.%20Supplementary/10Days/#day-4-importing-and-exporting-data","title":"\ud83d\udcc5 Day 4: Importing and Exporting Data","text":"<p>\ud83d\udd39 Importing Assets: Uploading shapefiles, CSVs, and images. \ud83d\udd39 Loading Public Datasets: Accessing GEE datasets (Landsat, MODIS, Sentinel, etc.). \ud83d\udd39 Exporting Data:</p> <ul> <li>Exporting images to Google Drive</li> <li>Exporting FeatureCollections to CSV</li> <li>Exporting time-series data</li> </ul> <p>\ud83d\udccc Hands-on Task: \u2705 Export a Landsat  / Sentinel-2 image to Google Drive.</p>"},{"location":"gee/0.%20Supplementary/10Days/#day-5-core-functionality-filtering-and-functions","title":"\ud83d\udcc5 Day 5: Core Functionality \u2013 Filtering and Functions","text":"<p>\ud83d\udd39 Filtering Data:</p> <ul> <li><code>filterBounds()</code>, <code>filterDate()</code>, <code>filter(.....)</code>     \ud83d\udd39 Using Map and Reduce functions.     \ud83d\udd39 Defining and applying user functions.     \ud83d\udd39 Filtering ImageCollections and FeatureCollections.</li> </ul> <p>\ud83d\udccc Hands-on Task: \u2705 Filter Sentinel-2 data for a specific region and time range.</p>"},{"location":"gee/0.%20Supplementary/10Days/#day-6-core-functionality-reducers","title":"\ud83d\udcc5 Day 6: Core Functionality \u2013 Reducers","text":"<p>\ud83d\udd39 Introduction to Reducers:</p> <ul> <li><code>reduceRegion()</code>, <code>reduceColumns()</code>, <code>reduceNeighbors()</code>     \ud83d\udd39 Zonal Statistics (Mean, Max, Min, Sum) using Reducers.     \ud83d\udd39 Reducing ImageCollections to single images.</li> </ul> <p>\ud83d\udccc Hands-on Task: \u2705 Compute NDVI mean for a given region using reducers.</p>"},{"location":"gee/0.%20Supplementary/10Days/#day-7-core-functionality-charts-and-visualization","title":"\ud83d\udcc5 Day 7: Core Functionality \u2013 Charts and Visualization","text":"<p>\ud83d\udd39 Creating Time-Series Charts. \ud83d\udd39 Visualizing trends using <code>ui.Chart.image.series()</code>. \ud83d\udd39 Mapping features and visualizing statistical summaries.</p> <p>\ud83d\udccc Hands-on Task: \u2705 Create a time-series NDVI chart for a location.</p>"},{"location":"gee/0.%20Supplementary/10Days/#day-8-project-time-series-analysis-of-climate-data","title":"\ud83d\udcc5 Day 8: Project \u2013 Time Series Analysis of Climate Data","text":"<p>\ud83d\udd39 Concept of Time-Series Analysis in Remote Sensing. \ud83d\udd39 Extracting time-series data from MODIS, Landsat, or Sentinel. \ud83d\udd39 Analyzing trends in land cover changes, vegetation, temperature, etc.</p> <p>\ud83d\udccc Hands-on Task: \u2705 Perform time-series NDVI analysis for a given region.</p>"},{"location":"gee/0.%20Supplementary/10Days/#day-9-project-machine-learning-land-use-land-cover-lulc","title":"\ud83d\udcc5 Day 9: Project \u2013 Machine Learning (Land Use Land Cover - LULC)","text":"<p>\ud83d\udd39 Machine Learning in GEE:</p> <ul> <li>Supervised Classification (Random Forest, SVM, etc.)</li> <li>Training and Testing Data Preparation     \ud83d\udd39 Creating LULC Maps using Classification Algorithms.</li> </ul> <p>\ud83d\udccc Hands-on Task: \u2705 Classify an area (e.g., urban, water, vegetation) using Random Forest.</p>"},{"location":"gee/0.%20Supplementary/10Days/#day-10-advanced-topics-ai-imd-data-osm-data-import","title":"\ud83d\udcc5 Day 10: Advanced Topics \u2013 AI, IMD Data, OSM Data Import","text":"<p>\ud83d\udd39 Integrating AI Models with GEE. \ud83d\udd39 Importing IMD (Indian Meteorological Department) weather data. \ud83d\udd39 Using OpenStreetMap (OSM) data for urban studies. \ud83d\udd39 Future Scope: Deep Learning &amp; Big Data Analytics in GEE.</p> <p>\ud83d\udccc Hands-on Task: \u2705 Import OSM data and IMD Collection to GEE.</p> <p>Follow me on LinkedIn:   Pulakesh Pradhan</p>"},{"location":"gee/0.%20Supplementary/2.%20Local%20vs%20Server/","title":"2. Local vs Server","text":""},{"location":"gee/0.%20Supplementary/projection/","title":"Comprehensive Guide to Projection and Scale in Google Earth Engine","text":""},{"location":"gee/0.%20Supplementary/projection/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Fundamentals of Geospatial Data in GEE</li> <li>How Google Earth Engine Handles Projections</li> <li>Understanding Scale in Google Earth Engine</li> <li>When to Specify Projections and Scale Manually</li> <li>Best Practices for Projection and Scale in GEE</li> <li>Common Errors and Troubleshooting</li> <li>Practical Examples with Code</li> <li>Advanced Topics</li> <li>Conclusion and Resources</li> </ol>"},{"location":"gee/0.%20Supplementary/projection/#10-conclusion-and-resources","title":"10. Conclusion and Resources","text":""},{"location":"gee/0.%20Supplementary/projection/#summary-of-key-concepts","title":"Summary of Key Concepts","text":"<p>Throughout this comprehensive tutorial, we've explored the critical concepts of projection and scale in Google Earth Engine, from fundamental principles to advanced applications. Let's recap the key points:</p>"},{"location":"gee/0.%20Supplementary/projection/#projection-fundamentals","title":"Projection Fundamentals","text":"<ul> <li>Coordinate Reference Systems (CRS) define how Earth's curved surface is represented on a flat plane</li> <li>Different projections serve different purposes: some preserve angles, others preserve areas</li> <li>EPSG codes provide standardized identifiers for projection systems (e.g., EPSG:4326 for WGS84)</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#scale-concepts","title":"Scale Concepts","text":"<ul> <li>Scale refers to pixel resolution in meters</li> <li>Native resolution is the original pixel size of a dataset</li> <li>Image pyramids store data at multiple resolutions for efficient access</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#gees-unique-approach","title":"GEE's Unique Approach","text":"<ul> <li>GEE uses a \"pull\" basis for both projection and scale</li> <li>The output requirements determine how inputs are processed</li> <li>Dynamic reprojection happens automatically based on analysis needs</li> <li>Lazy computation optimizes resource usage</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#when-to-take-control","title":"When to Take Control","text":"<ul> <li>Exporting data requires explicit projection and scale settings</li> <li>Area calculations should use equal-area projections</li> <li>Multi-dataset analysis may benefit from explicit projection control</li> <li>Performance optimization sometimes requires manual scale management</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#best-practices","title":"Best Practices","text":"<ul> <li>Let GEE handle projections automatically when possible</li> <li>Check native projections before operations</li> <li>Use appropriate projections for specific analytical needs</li> <li>Avoid unnecessary reprojection</li> <li>Select scale parameters based on analysis requirements and computational constraints</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#practical-applications","title":"Practical Applications","text":"<p>The concepts covered in this tutorial apply to numerous Earth science applications:</p> <ul> <li>Land Cover Classification: Ensuring consistent scale across training and classification</li> <li>Change Detection: Maintaining projection consistency for accurate time-series analysis</li> <li>Area Measurement: Using equal-area projections for accurate quantification of deforestation, urbanization, etc.</li> <li>Global Studies: Handling projection distortions at different latitudes</li> <li>Regional Analysis: Selecting regionally optimized projections for specific study areas</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#further-learning-resources","title":"Further Learning Resources","text":""},{"location":"gee/0.%20Supplementary/projection/#official-google-earth-engine-documentation","title":"Official Google Earth Engine Documentation","text":"<ul> <li>Earth Engine Projections Guide</li> <li>Earth Engine Scale Guide</li> <li>Earth Engine API Reference</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#community-resources","title":"Community Resources","text":"<ul> <li>Google Earth Engine Developers Forum</li> <li>GIS Stack Exchange - Earth Engine Tag</li> <li>Earth Engine Community Tutorials on GitHub</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#projection-resources","title":"Projection Resources","text":"<ul> <li>EPSG Registry - Comprehensive database of coordinate reference systems</li> <li>Projection Wizard - Tool to help select appropriate map projections</li> <li>Map Projections: A Working Manual - Classic USGS publication on map projections</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#academic-papers","title":"Academic Papers","text":"<ul> <li>Gorelick, N., Hancher, M., Dixon, M., Ilyushchenko, S., Thau, D., &amp; Moore, R. (2017). Google Earth Engine: Planetary-scale geospatial analysis for everyone. Remote Sensing of Environment, 202, 18-27.</li> <li>Padilla, M., Stehman, S. V., Ramo, R., Corti, D., Hantson, S., Oliva, P., ... &amp; Chuvieco, E. (2015). Comparing the accuracies of remote sensing global burned area products using stratified random sampling and estimation. Remote Sensing of Environment, 160, 114-121.</li> <li>Potere, D. (2008). Horizontal positional accuracy of Google Earth's high-resolution imagery archive. Sensors, 8(12), 7973-7981.</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#books-and-textbooks","title":"Books and Textbooks","text":"<ul> <li>Lovelace, R., Nowosad, J., &amp; Muenchow, J. (2019). Geocomputation with R. CRC Press.</li> <li>Pebesma, E., &amp; Bivand, R. (2023). Spatial Data Science: With Applications in R. Chapman and Hall/CRC.</li> <li>Westra, E. (2016). Python Geospatial Development. Packt Publishing Ltd.</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#final-thoughts","title":"Final Thoughts","text":"<p>Understanding projection and scale in Google Earth Engine is essential for producing accurate, reliable, and computationally efficient geospatial analyses. While GEE's automatic handling of these concepts simplifies many workflows, knowing when and how to take manual control empowers you to optimize your analyses for specific needs.</p> <p>As you continue your journey with Google Earth Engine, remember that projection and scale considerations should be integrated into your analytical thinking from the beginning of a project. By applying the principles and best practices covered in this tutorial, you'll be well-equipped to tackle complex geospatial challenges with confidence and precision.</p> <p>The field of geospatial analysis continues to evolve, with new datasets, methods, and tools emerging regularly. Stay connected with the GEE community, explore the resources provided, and continue experimenting with different approaches to refine your skills and expand your capabilities.</p> <p>Happy mapping and analyzing with Google Earth Engine!</p>"},{"location":"gee/0.%20Supplementary/projection/#1-introduction-to-projection-and-scale-in-google-earth-engine","title":"1. Introduction to Projection and Scale in Google Earth Engine","text":"<p>Google Earth Engine (GEE) is a powerful cloud-based geospatial processing platform that revolutionizes how we analyze satellite imagery and geospatial datasets. By leveraging Google's computational infrastructure, GEE enables users to process and analyze petabytes of satellite imagery and geospatial data with unprecedented speed and efficiency. This capability has transformed how researchers, scientists, and analysts approach large-scale environmental monitoring, land use change detection, climate studies, and numerous other Earth science applications.</p>"},{"location":"gee/0.%20Supplementary/projection/#why-understanding-projection-and-scale-matters","title":"Why Understanding Projection and Scale Matters","text":"<p>When working with geospatial data in GEE, two fundamental concepts significantly impact the accuracy and efficiency of your analyses: projection and scale. These concepts might seem technical at first, but mastering them is essential for anyone seeking to produce reliable results and optimize computational resources in GEE.</p>"},{"location":"gee/0.%20Supplementary/projection/#impact-on-analysis-accuracy","title":"Impact on Analysis Accuracy","text":"<p>Projection and scale directly affect the accuracy of measurements and calculations in your geospatial analyses:</p> <ul> <li>Area calculations can vary significantly depending on the projection used, potentially leading to substantial errors in land cover estimates or deforestation measurements</li> <li>Distance measurements are affected by projection distortions, which can impact analyses like buffer operations or proximity calculations</li> <li>Pixel value aggregations are influenced by scale, affecting statistics derived from imagery such as mean reflectance values or classification results</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#impact-on-computational-efficiency","title":"Impact on Computational Efficiency","text":"<p>GEE's cloud-based architecture is designed to handle massive datasets, but understanding projection and scale helps you optimize your computational resources:</p> <ul> <li>Processing time can increase dramatically with unnecessary reprojection operations or inappropriate scale settings</li> <li>Memory usage is affected by the resolution at which you process data, with finer scales requiring more resources</li> <li>Request quotas in GEE can be quickly consumed by inefficient code that doesn't properly account for projection and scale</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#what-youll-learn-in-this-tutorial","title":"What You'll Learn in This Tutorial","text":"<p>This comprehensive tutorial will guide you through the intricacies of projection and scale in Google Earth Engine, providing both theoretical understanding and practical implementation skills. By the end of this tutorial, you will:</p> <ol> <li>Understand the fundamental concepts of coordinate reference systems and how they relate to GEE</li> <li>Master how GEE uniquely handles projections and scale using its \"pull\" basis approach</li> <li>Know when and how to specify projections and scale manually for different analytical needs</li> <li>Implement best practices to ensure accurate results while optimizing computational efficiency</li> <li>Troubleshoot common projection and scale-related errors in your GEE workflows</li> <li>Apply these concepts through practical code examples for real-world geospatial analysis tasks</li> </ol>"},{"location":"gee/0.%20Supplementary/projection/#tutorial-structure","title":"Tutorial Structure","text":"<p>This tutorial is organized to progressively build your understanding from fundamental concepts to advanced applications:</p> <ol> <li>Introduction (this section)</li> <li>Fundamentals of Geospatial Data in GEE - Core concepts of coordinate systems and pixel resolution</li> <li>How Google Earth Engine Handles Projections - GEE's unique approach to projection management</li> <li>Understanding Scale in Google Earth Engine - The relationship between scale, image pyramids, and analysis</li> <li>When to Specify Projections and Scale Manually - Critical scenarios requiring explicit settings</li> <li>Best Practices for Projection and Scale in GEE - Guidelines for optimal implementation</li> <li>Common Errors and Troubleshooting - Solutions to frequent projection and scale challenges</li> <li>Practical Examples with Code - Real-world applications with detailed code explanations</li> <li>Advanced Topics - Specialized considerations for complex analyses</li> <li>Conclusion and Resources - Summary and further learning materials</li> </ol> <p>Whether you're new to GEE or looking to deepen your expertise, this tutorial will enhance your ability to work with geospatial data accurately and efficiently. Let's begin by exploring the fundamental concepts of geospatial data representation in GEE.</p>"},{"location":"gee/0.%20Supplementary/projection/#2-fundamentals-of-geospatial-data-in-gee","title":"2. Fundamentals of Geospatial Data in GEE","text":"<p>To effectively work with geospatial data in Google Earth Engine, it's essential to understand how the Earth's three-dimensional surface is represented in a two-dimensional computational environment. This section explores the core concepts of coordinate reference systems, projections, and scale that form the foundation of geospatial analysis in GEE.</p>"},{"location":"gee/0.%20Supplementary/projection/#coordinate-reference-systems-crs-explained","title":"Coordinate Reference Systems (CRS) Explained","text":"<p>A Coordinate Reference System (CRS) defines how coordinates on a flat map relate to real locations on the Earth's curved surface. Every CRS consists of several components:</p> <ol> <li>Datum: A model of the Earth's shape (typically an ellipsoid) and its orientation in space</li> <li>Coordinate System: A framework that specifies how positions are represented (e.g., using latitude/longitude or meters)</li> <li>Projection: A mathematical transformation that converts the Earth's curved surface to a flat representation</li> </ol> <p>In GEE, coordinate reference systems are typically identified using EPSG codes, which are standardized numerical identifiers maintained by the International Association of Oil &amp; Gas Producers (IOGP). For example, \"EPSG:4326\" refers to the WGS84 geographic coordinate system, which uses latitude and longitude coordinates.</p>"},{"location":"gee/0.%20Supplementary/projection/#common-projection-systems-used-in-gee","title":"Common Projection Systems Used in GEE","text":"<p>Google Earth Engine supports numerous projection systems, but several are particularly important to understand:</p>"},{"location":"gee/0.%20Supplementary/projection/#epsg4326-wgs84","title":"EPSG:4326 (WGS84)","text":"<ul> <li>The World Geodetic System 1984, which uses latitude and longitude coordinates</li> <li>The default projection for many global datasets and the GEE default when no projection is specified</li> <li>Not an equal-area projection, meaning area calculations can be distorted, especially near the poles</li> <li>Example in GEE: <code>ee.Projection('EPSG:4326')</code></li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#epsg3857-web-mercator","title":"EPSG:3857 (Web Mercator)","text":"<ul> <li>The projection used by Google Maps, Bing Maps, and most web mapping applications</li> <li>Used by default for visualization in the GEE Code Editor and geemap</li> <li>Preserves angles but significantly distorts areas, especially at high latitudes</li> <li>Example in GEE: <code>ee.Projection('EPSG:3857')</code></li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#epsg6933-equal-earth","title":"EPSG:6933 (Equal Earth)","text":"<ul> <li>An equal-area projection that preserves the relative size of areas</li> <li>Ideal for accurate area calculations in global analyses</li> <li>Minimizes distortion of shapes while maintaining equal area</li> <li>Example in GEE: <code>ee.Projection('EPSG:6933')</code></li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#sinusoidal-projections","title":"Sinusoidal Projections","text":"<ul> <li>Used by several satellite data products, including MODIS</li> <li>An equal-area projection that preserves areas but distorts shapes away from the central meridian</li> <li>Example in GEE: MODIS datasets use a custom sinusoidal projection (SR-ORG:6974)</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#understanding-scale-as-pixel-resolution","title":"Understanding Scale as Pixel Resolution","text":"<p>In Google Earth Engine, scale refers to the spatial resolution of raster data\u2014essentially, the size of each pixel in meters. Scale is a critical concept that affects both the accuracy of your analysis and the computational resources required:</p> <ul> <li>Native resolution: The original pixel size of a dataset (e.g., 30 meters for Landsat, 10 meters for Sentinel-2)</li> <li>Analysis scale: The resolution at which computations are performed, which may differ from native resolution</li> <li>Output scale: The resolution of your final results or exports</li> </ul> <p>Scale in GEE is typically expressed in meters, representing the side length of a square pixel. For example:</p> <ul> <li>Landsat 8 optical bands: 30 meters</li> <li>Sentinel-2 optical bands: 10-20 meters (depending on the band)</li> <li>MODIS land surface temperature: 1000 meters</li> <li>Digital Elevation Models: Various resolutions from 30 meters to 90 meters</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#relationship-between-projection-and-scale","title":"Relationship Between Projection and Scale","text":"<p>Projection and scale are interrelated concepts in GEE that together determine how accurately your analysis represents the Earth's surface:</p> <ol> <li>Scale varies with projection: In some projections (like Mercator), the actual ground distance represented by a pixel varies with latitude</li> <li>Reprojection affects scale: When data is reprojected, pixels may be resampled, potentially changing their values</li> <li>Analysis consistency: Using consistent projections and scales across datasets is crucial for accurate comparative analyses</li> </ol>"},{"location":"gee/0.%20Supplementary/projection/#example-scale-variation-in-web-mercator","title":"Example: Scale Variation in Web Mercator","text":"<p>In the Web Mercator projection (EPSG:3857), the actual ground distance represented by a \"30-meter\" pixel increases as you move away from the equator:</p> <ul> <li>At the equator: 30 meters is 30 meters on the ground</li> <li>At 60\u00b0 latitude: 30 meters in the projection represents about 60 meters on the ground</li> <li>Near the poles: The distortion becomes extreme</li> </ul> <p>This variation has significant implications for area calculations, distance measurements, and any analysis that depends on accurate spatial relationships.</p>"},{"location":"gee/0.%20Supplementary/projection/#practical-implications-for-gee-analysis","title":"Practical Implications for GEE Analysis","text":"<p>Understanding these fundamental concepts has direct practical implications for your work in Google Earth Engine:</p> <ol> <li>Accuracy of measurements: Using inappropriate projections can lead to significant errors in area and distance calculations</li> <li>Computational efficiency: Processing at unnecessarily fine scales can dramatically increase computation time and resource usage</li> <li>Data compatibility: Working with multiple datasets requires understanding their native projections and scales</li> <li>Result interpretation: The choice of projection and scale affects how results should be interpreted and presented</li> </ol> <p>In the next section, we'll explore how Google Earth Engine uniquely handles projections using its \"pull\" basis approach, which differs significantly from traditional GIS platforms.</p>"},{"location":"gee/0.%20Supplementary/projection/#3-how-google-earth-engine-handles-projections","title":"3. How Google Earth Engine Handles Projections","text":"<p>Google Earth Engine's approach to handling projections differs significantly from traditional GIS and image processing platforms. Understanding this unique approach is crucial for effective and efficient geospatial analysis in GEE. This section explores how GEE manages projections dynamically and what that means for your workflows.</p>"},{"location":"gee/0.%20Supplementary/projection/#the-pull-basis-concept-for-projection-handling","title":"The \"Pull\" Basis Concept for Projection Handling","text":"<p>In traditional GIS software, users typically need to ensure all input data layers share the same projection before analysis\u2014a \"push\" approach where inputs determine the processing projection. Google Earth Engine inverts this paradigm with a \"pull\" approach:</p> <ul> <li>Output determines input: The projection of the output (what you're requesting) determines how inputs are processed</li> <li>Dynamic reprojection: GEE reprojects inputs on-the-fly based on the output's requirements</li> <li>Lazy computation: Projections aren't applied until results are actually needed (for display or export)</li> </ul> <p>This pull-based approach means that in most cases, you don't need to manually reproject your data in GEE. Instead, the system intelligently handles projections based on what you're trying to accomplish.</p>"},{"location":"gee/0.%20Supplementary/projection/#automatic-projection-handling-in-gee","title":"Automatic Projection Handling in GEE","text":"<p>When you perform operations in Earth Engine, the system automatically manages projections through several mechanisms:</p>"},{"location":"gee/0.%20Supplementary/projection/#1-projection-inference","title":"1. Projection Inference","text":"<p>GEE determines the appropriate projection for computation based on:</p> <ul> <li>Function parameters: When you specify a <code>crs</code> parameter in functions like <code>reduceRegion()</code> or <code>Export.image</code></li> <li>Display context: The Code Editor and geemap use Web Mercator (EPSG:3857) for visualization</li> <li>Explicit reprojection: When you use the <code>reproject()</code> method to force a specific projection</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#2-projection-propagation","title":"2. Projection Propagation","text":"<p>When you chain operations together, projection information flows backward through your computation:</p> <pre><code>Input Image \u2192 Operation 1 \u2192 Operation 2 \u2192 ... \u2192 Output (with specified projection)\n                                                      \u2191\n                                        Projection requirements flow backward\n</code></pre> <p>This means the projection specified at the end of your computation chain determines how all previous operations are handled.</p>"},{"location":"gee/0.%20Supplementary/projection/#3-on-demand-resampling","title":"3. On-Demand Resampling","text":"<p>GEE doesn't actually perform reprojection until results are needed:</p> <ul> <li>When you visualize an image on the map</li> <li>When you export data</li> <li>When you request statistics with reducers</li> </ul> <p>This lazy evaluation approach optimizes computational resources by avoiding unnecessary reprojection operations.</p>"},{"location":"gee/0.%20Supplementary/projection/#visualization-vs-computation-projections","title":"Visualization vs. Computation Projections","text":"<p>An important distinction in GEE is that visualization and computation may use different projections:</p>"},{"location":"gee/0.%20Supplementary/projection/#visualization-projection","title":"Visualization Projection","text":"<ul> <li>The Code Editor and geemap maps use Web Mercator (EPSG:3857) for display</li> <li>This projection is optimized for web mapping but distorts areas, especially at high latitudes</li> <li>When you add an image to the map, GEE automatically reprojects it to Web Mercator regardless of its native projection</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#computation-projection","title":"Computation Projection","text":"<ul> <li>Analyses and calculations use the projection specified in your code or the native projection of the input data</li> <li>For accurate area calculations, you should specify an equal-area projection like EPSG:6933</li> <li>Statistical operations through reducers use the projection specified in the <code>crs</code> parameter</li> </ul> <p>This separation allows GEE to optimize both display performance and analytical accuracy.</p>"},{"location":"gee/0.%20Supplementary/projection/#how-gee-aligns-multiple-datasets-with-different-projections","title":"How GEE Aligns Multiple Datasets with Different Projections","text":"<p>When working with multiple datasets that have different native projections, GEE automatically aligns them based on the output requirements:</p> <ol> <li>Common projection determination: GEE identifies the target projection from your code or defaults to the first input's projection</li> <li>Dynamic reprojection: All inputs are reprojected to the common projection as needed</li> <li>Resampling: Pixels are resampled using nearest neighbor (default), bilinear, or cubic methods as specified</li> </ol> <p>This automatic alignment eliminates the need for manual reprojection steps that are common in traditional GIS workflows.</p>"},{"location":"gee/0.%20Supplementary/projection/#example-combining-landsat-and-sentinel-2-data","title":"Example: Combining Landsat and Sentinel-2 Data","text":"<p>When combining Landsat (UTM projection) and Sentinel-2 (also UTM but potentially different zones) imagery:</p> <pre><code>// These images have different native projections\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar sentinel = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\n\n// GEE automatically aligns them when used together\nvar ndvi_landsat = landsat.normalizedDifference(['B5', 'B4']);\nvar ndvi_sentinel = sentinel.normalizedDifference(['B8', 'B4']);\n\n// The output uses the projection specified here\nvar difference = ndvi_sentinel.subtract(ndvi_landsat)\n  .reproject({\n    crs: 'EPSG:3857',\n    scale: 30\n  });\n</code></pre> <p>In this example, GEE handles all the necessary reprojection to align the datasets before computing their difference.</p>"},{"location":"gee/0.%20Supplementary/projection/#when-gee-uses-default-projections-wgs84","title":"When GEE Uses Default Projections (WGS84)","text":"<p>While GEE's automatic projection handling is powerful, there are situations where the system defaults to using WGS84 (EPSG:4326) with 1-degree scale:</p> <ol> <li>Image collections with mixed projections: When reducing an <code>ImageCollection</code> containing images with different projections</li> <li>Composite creation: When creating a mosaic or composite from images with different projections</li> <li>Ambiguous operations: When the output projection cannot be clearly determined from inputs or parameters</li> </ol> <p>In these cases, you'll see the default WGS84 projection when you check the projection of the result:</p> <pre><code>var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA');\nvar mosaic = collection.filterDate('2018-01-01', '2019-01-01').mosaic();\nprint(mosaic.projection());  // Shows WGS84 with 1-degree scale\n</code></pre> <p>This default projection is generally not suitable for analysis due to its coarse scale. When you encounter this situation, you should explicitly specify an appropriate projection and scale for your analysis.</p>"},{"location":"gee/0.%20Supplementary/projection/#practical-implications-of-gees-projection-handling","title":"Practical Implications of GEE's Projection Handling","text":"<p>GEE's approach to projections has several practical implications for your workflows:</p> <ol> <li>Simplified code: You rarely need to include explicit reprojection steps</li> <li>Computational efficiency: The system optimizes reprojection operations behind the scenes</li> <li>Flexibility: You can easily work with datasets in different projections without manual conversion</li> <li>Output control: You maintain control over the final projection through export parameters</li> </ol> <p>In the next section, we'll explore how GEE handles scale using a similar \"pull\" approach, which complements its projection handling system.</p>"},{"location":"gee/0.%20Supplementary/projection/#4-understanding-scale-in-google-earth-engine","title":"4. Understanding Scale in Google Earth Engine","text":"<p>Scale is a fundamental concept in Google Earth Engine that significantly impacts both the accuracy of your analyses and the computational resources required. In this section, we'll explore how GEE uniquely handles scale, the concept of image pyramids, and how scale affects your analytical results.</p>"},{"location":"gee/0.%20Supplementary/projection/#the-pull-basis-concept-for-scale-determination","title":"The \"Pull\" Basis Concept for Scale Determination","text":"<p>Similar to its approach with projections, Google Earth Engine handles scale using a \"pull\" basis rather than the \"push\" approach used in traditional GIS platforms:</p> <ul> <li>Traditional GIS (push): The resolution of input data determines the resolution of processing and output</li> <li>GEE (pull): The scale specified for the output determines what resolution of input data is used</li> </ul> <p>This pull-based approach means that the scale at which computations occur is determined by:</p> <ol> <li>Explicit scale parameters: When you specify a <code>scale</code> parameter in functions like <code>reduceRegion()</code> or <code>Export.image</code></li> <li>Display context: The zoom level of the map when visualizing results</li> <li>Reprojection settings: When you use the <code>reproject()</code> method with a scale parameter</li> </ol> <p>This approach gives you flexibility to work with the same data at different scales without duplicating datasets.</p>"},{"location":"gee/0.%20Supplementary/projection/#image-pyramids-and-how-they-work","title":"Image Pyramids and How They Work","text":"<p>Google Earth Engine stores raster data in multi-resolution structures called image pyramids. Understanding these pyramids is key to grasping how GEE handles scale:</p>"},{"location":"gee/0.%20Supplementary/projection/#structure-of-image-pyramids","title":"Structure of Image Pyramids","text":"<p>An image pyramid consists of the same image stored at multiple resolutions:</p> <ul> <li>Level 0: The original, full-resolution image (native resolution)</li> <li>Level 1: A downsampled version, typically with pixels representing 2x the area of Level 0</li> <li>Level 2, 3, etc.: Progressively more downsampled versions</li> </ul> <p>Each level of the pyramid contains the same geographic extent but with fewer pixels, making computation more efficient at coarser scales.</p>"},{"location":"gee/0.%20Supplementary/projection/#pyramiding-policies","title":"Pyramiding Policies","text":"<p>How pixel values are aggregated when creating higher levels of the pyramid depends on the pyramiding policy of the dataset:</p> <ul> <li>Mean: For continuous data (like reflectance values), pixel values are averaged</li> <li>Mode: For categorical data (like land cover classes), the most common value is used</li> <li>Sample: A single pixel (often the top-left) is selected to represent the block</li> <li>Min/Max: The minimum or maximum value in the block is used</li> </ul> <p>Different bands of the same image can have different pyramiding policies based on their data type.</p>"},{"location":"gee/0.%20Supplementary/projection/#how-gee-selects-pyramid-levels","title":"How GEE Selects Pyramid Levels","text":"<p>When you request data at a specific scale, GEE:</p> <ol> <li>Identifies the pyramid level with resolution closest to (but not finer than) your requested scale</li> <li>Resamples that level as needed to match your exact scale requirement</li> <li>Performs computations at that resolution</li> </ol> <p>This approach optimizes performance by avoiding unnecessary processing of high-resolution data when lower resolution is sufficient.</p>"},{"location":"gee/0.%20Supplementary/projection/#how-scale-affects-analysis-results","title":"How Scale Affects Analysis Results","text":"<p>The scale at which you perform analysis can dramatically affect your results:</p>"},{"location":"gee/0.%20Supplementary/projection/#pixel-value-variation","title":"Pixel Value Variation","text":"<p>As demonstrated in the official GEE documentation, the same location can return different pixel values depending on the scale:</p> <pre><code>var image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select('B4');\n\nvar printAtScale = function(scale) {\n  print('Pixel value at '+scale+' meters scale',\n    image.reduceRegion({\n      reducer: ee.Reducer.first(),\n      geometry: image.geometry().centroid(),\n      scale: scale\n  }).get('B4'));\n};\n\nprintAtScale(10);  // 0.10394100844860077\nprintAtScale(30);  // 0.10394100844860077 (native resolution)\nprintAtScale(50);  // 0.09130698442459106\nprintAtScale(70);  // 0.1150854229927063\nprintAtScale(200); // 0.102478988468647\nprintAtScale(500); // 0.09072770178318024\n</code></pre> <p>This variation occurs because different pyramid levels are selected and resampled based on the requested scale.</p>"},{"location":"gee/0.%20Supplementary/projection/#classification-accuracy","title":"Classification Accuracy","text":"<p>Scale significantly impacts classification results:</p> <ul> <li>Finer scales capture more spatial detail but may introduce noise</li> <li>Coarser scales smooth out variation but may miss important features</li> <li>Mixed pixels become more prevalent at coarser scales, affecting class boundaries</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#area-calculations","title":"Area Calculations","text":"<p>The scale at which you calculate areas affects the precision of your measurements:</p> <ul> <li>Finer scales generally provide more accurate area estimates, especially for small or irregularly shaped features</li> <li>Coarser scales may miss fine details of boundaries, leading to under or overestimation</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#statistical-aggregations","title":"Statistical Aggregations","text":"<p>When computing statistics over regions:</p> <ul> <li>Scale determines sampling density: Finer scales include more samples in the calculation</li> <li>Spatial patterns: Coarser scales may obscure spatial patterns visible at finer resolutions</li> <li>Computational intensity: Finer scales require more computation but may provide more accurate results</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#relationship-between-zoom-levels-and-scale-in-the-map-interface","title":"Relationship Between Zoom Levels and Scale in the Map Interface","text":"<p>When visualizing data in the Code Editor or geemap, the scale of displayed data is directly related to the map's zoom level:</p>"},{"location":"gee/0.%20Supplementary/projection/#zoom-level-to-scale-relationship","title":"Zoom Level to Scale Relationship","text":"<p>Each zoom level corresponds to a specific scale in Web Mercator projection:</p> <ul> <li>Zoom level 0: Entire world (~156,000 meters/pixel at equator)</li> <li>Zoom level 10: City level (~150 meters/pixel at equator)</li> <li>Zoom level 15: Neighborhood level (~5 meters/pixel at equator)</li> <li>Zoom level 20: Building level (~0.15 meters/pixel at equator)</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#dynamic-resolution-loading","title":"Dynamic Resolution Loading","text":"<p>As you zoom in and out:</p> <ol> <li>GEE automatically selects the appropriate pyramid level for display</li> <li>More detailed data is loaded as you zoom in</li> <li>Data is aggregated as you zoom out</li> </ol> <p>This dynamic loading optimizes both display performance and network usage.</p>"},{"location":"gee/0.%20Supplementary/projection/#scale-bar-interpretation","title":"Scale Bar Interpretation","text":"<p>The scale bar in the map interface shows the actual ground distance at the current latitude:</p> <ul> <li>Due to Web Mercator distortion, the same pixel size represents different ground distances at different latitudes</li> <li>Near the equator, scale is relatively accurate</li> <li>Near the poles, significant distortion occurs</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#scale-considerations-for-different-types-of-analyses","title":"Scale Considerations for Different Types of Analyses","text":"<p>Different types of analyses have different optimal scale considerations:</p>"},{"location":"gee/0.%20Supplementary/projection/#land-cover-classification","title":"Land Cover Classification","text":"<ul> <li>Recommended scale: Depends on the minimum mapping unit required</li> <li>Considerations: Finer scales capture more detail but may introduce noise and increase computation time</li> <li>Example: 30m for regional land cover, 10m for detailed urban mapping</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#change-detection","title":"Change Detection","text":"<ul> <li>Recommended scale: Should match or be slightly coarser than the native resolution of input data</li> <li>Considerations: Consistent scale across time periods is crucial</li> <li>Example: 30m for Landsat-based change detection</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#spectral-indices-ndvi-evi-etc","title":"Spectral Indices (NDVI, EVI, etc.)","text":"<ul> <li>Recommended scale: Native resolution of input bands</li> <li>Considerations: Mixing resolutions can introduce artifacts</li> <li>Example: 10m for Sentinel-2 based indices</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#terrain-analysis","title":"Terrain Analysis","text":"<ul> <li>Recommended scale: Depends on the terrain features of interest</li> <li>Considerations: Too coarse a scale will smooth out important terrain features</li> <li>Example: 30m for general topographic analysis, finer for detailed hydrological modeling</li> </ul> <p>In the next section, we'll explore when you should manually specify projections and scale in your GEE workflows, rather than relying on the automatic handling.</p>"},{"location":"gee/0.%20Supplementary/projection/#5-when-to-specify-projections-and-scale-manually","title":"5. When to Specify Projections and Scale Manually","text":"<p>While Google Earth Engine's automatic handling of projections and scale is powerful and convenient, there are specific scenarios where manually specifying these parameters is necessary for accurate results or optimal performance. This section explores when and how to take control of projection and scale settings in your GEE workflows.</p>"},{"location":"gee/0.%20Supplementary/projection/#exporting-data-scenarios","title":"Exporting Data Scenarios","text":"<p>When exporting data from GEE, explicitly defining projection and scale ensures consistency and accuracy:</p>"},{"location":"gee/0.%20Supplementary/projection/#exporting-images","title":"Exporting Images","text":"<p>When using <code>Export.image.toDrive()</code>, <code>Export.image.toAsset()</code>, or <code>Export.image.toCloudStorage()</code>, you should specify:</p> <pre><code>Export.image.toDrive({\n  image: myImage,\n  description: 'exported_image',\n  scale: 30,  // Resolution in meters\n  crs: 'EPSG:4326',  // WGS84 coordinate system\n  region: myStudyArea,\n  maxPixels: 1e13\n});\n</code></pre> <p>Specifying these parameters ensures: - The exported data has a consistent resolution - The coordinate system is appropriate for your needs - The data can be seamlessly integrated with other GIS software</p>"},{"location":"gee/0.%20Supplementary/projection/#exporting-vector-data","title":"Exporting Vector Data","text":"<p>When exporting vector data with <code>Export.table</code>, projection settings affect the coordinate system of the output:</p> <pre><code>Export.table.toDrive({\n  collection: myFeatureCollection,\n  description: 'exported_vectors',\n  fileFormat: 'SHP',\n  selectors: ['property1', 'property2'],\n  driveFolder: 'GEE_Exports'\n});\n</code></pre> <p>While vector exports don't require scale parameters, the coordinate system defaults to WGS84 (EPSG:4326).</p>"},{"location":"gee/0.%20Supplementary/projection/#working-with-multiple-datasets-with-different-projections","title":"Working with Multiple Datasets with Different Projections","text":"<p>When combining datasets with different native projections, explicitly specifying a common projection ensures proper alignment:</p>"},{"location":"gee/0.%20Supplementary/projection/#combining-optical-and-radar-data","title":"Combining Optical and Radar Data","text":"<p>Optical sensors (like Landsat) and radar sensors (like Sentinel-1) often use different native projections:</p> <pre><code>var landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar sentinel1 = ee.Image('COPERNICUS/S1_GRD/S1A_IW_GRDH_1SDV_20180504T043029_20180504T043054_021743_02582F_FBAB');\n\n// Specify a common projection for analysis\nvar commonScale = 30;\nvar commonCRS = 'EPSG:3857';\n\n// Reproject both datasets to the common projection\nvar landsatReprojected = landsat.select('B4').reproject({\n  crs: commonCRS,\n  scale: commonScale\n});\n\nvar sentinel1Reprojected = sentinel1.select('VV').reproject({\n  crs: commonCRS,\n  scale: commonScale\n});\n\n// Now they can be reliably combined\nvar combined = landsatReprojected.addBands(sentinel1Reprojected);\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#multi-temporal-analysis","title":"Multi-Temporal Analysis","text":"<p>When analyzing changes over time with data from different sensors or different acquisition geometries:</p> <pre><code>var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterBounds(region)\n  .filterDate('2015-01-01', '2020-01-01');\n\n// Force consistent projection and scale for time series analysis\nvar consistentCollection = collection.map(function(image) {\n  return image.reproject({\n    crs: 'EPSG:4326',\n    scale: 30\n  });\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#calculating-accurate-areas-and-distances","title":"Calculating Accurate Areas and Distances","text":"<p>For accurate area and distance measurements, using an equal-area projection is essential:</p>"},{"location":"gee/0.%20Supplementary/projection/#area-calculation","title":"Area Calculation","text":"<p>The default Web Mercator projection significantly distorts areas, especially at high latitudes. For accurate area calculations:</p> <pre><code>var forest = ee.Image('UMD/hansen/global_forest_change_2020_v1_8')\n  .select('treecover2000')\n  .gt(30);  // Areas with &gt;30% tree cover\n\n// Calculate area using an equal-area projection\nvar forestArea = forest.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: studyRegion,\n  scale: 30,\n  crs: 'EPSG:6933',  // Equal Earth projection\n  maxPixels: 1e13\n});\n\nprint('Forest area (square meters):', forestArea.get('treecover2000'));\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#distance-measurement","title":"Distance Measurement","text":"<p>For accurate distance calculations, especially over large areas:</p> <pre><code>// Create a function to calculate distance with appropriate projection\nfunction calculateDistance(point1, point2) {\n  // Use a projection appropriate for the region\n  var crs = 'EPSG:6933';  // Equal Earth projection\n\n  // Create a line between points\n  var line = ee.Geometry.LineString([point1, point2]);\n\n  // Calculate length with the specified projection\n  return line.length({\n    proj: crs\n  });\n}\n\nvar distance = calculateDistance(\n  [-122.4194, 37.7749],  // San Francisco\n  [-74.0060, 40.7128]    // New York\n);\nprint('Distance (meters):', distance);\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#custom-visualization-needs","title":"Custom Visualization Needs","text":"<p>For specific visualization requirements, controlling projection and scale ensures consistent display:</p>"},{"location":"gee/0.%20Supplementary/projection/#creating-high-resolution-thumbnails","title":"Creating High-Resolution Thumbnails","text":"<pre><code>// Generate a high-resolution thumbnail with specific projection\nvar thumbnail = myImage.visualize({\n  bands: ['B4', 'B3', 'B2'],\n  min: 0,\n  max: 0.3\n}).reproject({\n  crs: 'EPSG:3857',\n  scale: 10  // 10-meter resolution\n});\n\n// Get the thumbnail URL\nvar thumbnailUrl = thumbnail.getThumbURL({\n  dimensions: 1024,\n  region: studyArea\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#consistent-multi-panel-visualizations","title":"Consistent Multi-Panel Visualizations","text":"<p>When creating multiple map panels for comparison:</p> <pre><code>// Ensure all images are displayed at the same scale and projection\nvar visParams = {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3};\nvar reprojectionParams = {crs: 'EPSG:3857', scale: 30};\n\nMap.addLayer(\n  image1.reproject(reprojectionParams).visualize(visParams),\n  {},\n  'Image 1'\n);\n\nMap.addLayer(\n  image2.reproject(reprojectionParams).visualize(visParams),\n  {},\n  'Image 2'\n);\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#resampling-and-aggregation-operations","title":"Resampling and Aggregation Operations","text":"<p>When changing the resolution of an image or aggregating data, explicit projection control is necessary:</p>"},{"location":"gee/0.%20Supplementary/projection/#reducing-resolution","title":"Reducing Resolution","text":"<p>The <code>reduceResolution()</code> function requires explicit scale parameters:</p> <pre><code>// Aggregate 10m Sentinel-2 data to 30m resolution\nvar sentinel2 = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\nvar ndvi = sentinel2.normalizedDifference(['B8', 'B4']);\n\n// Reduce resolution with mean aggregation\nvar aggregated = ndvi.reduceResolution({\n  reducer: ee.Reducer.mean(),\n  maxPixels: 1024\n}).reproject({\n  crs: 'EPSG:3857',\n  scale: 30  // Target resolution\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#upsampling-for-consistent-analysis","title":"Upsampling for Consistent Analysis","text":"<p>When combining datasets with different resolutions:</p> <pre><code>// Upsample coarse resolution data to match finer resolution\nvar modisLST = ee.Image('MODIS/006/MOD11A2/2019_01_01').select('LST_Day_1km');\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20190105');\n\n// Reproject MODIS to Landsat resolution\nvar modisUpsampled = modisLST.reproject({\n  crs: landsat.projection(),\n  scale: 30  // Landsat resolution\n});\n\n// Now they can be analyzed together\nvar combined = landsat.select('B10').addBands(modisUpsampled);\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#regional-analysis-considerations","title":"Regional Analysis Considerations","text":"<p>Different geographic regions may require specific projections for optimal analysis:</p>"},{"location":"gee/0.%20Supplementary/projection/#polar-regions","title":"Polar Regions","text":"<p>Standard projections like Web Mercator perform poorly near the poles. For polar studies:</p> <pre><code>// Use a polar stereographic projection for Antarctica\nvar antarctica = ee.Image('ECMWF/ERA5/MONTHLY/2019010100')\n  .select('temperature_2m')\n  .reproject({\n    crs: 'EPSG:3031',  // Antarctic Polar Stereographic\n    scale: 10000\n  });\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#continental-scale-analysis","title":"Continental-Scale Analysis","text":"<p>For large continental areas, equal-area projections preserve accurate area relationships:</p> <pre><code>// Continental US analysis with Albers equal-area projection\nvar usAlbers = 'EPSG:5070';  // NAD83 / Conus Albers\nvar landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover');\n\nvar agricultureArea = landcover.eq(82).multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: continentalUS,\n  scale: 30,\n  crs: usAlbers,\n  maxPixels: 1e13\n});\n</code></pre> <p>In the next section, we'll explore best practices for handling projection and scale in GEE to ensure accurate results while optimizing computational efficiency.</p>"},{"location":"gee/0.%20Supplementary/projection/#6-best-practices-for-projection-and-scale-in-gee","title":"6. Best Practices for Projection and Scale in GEE","text":"<p>Implementing best practices for handling projection and scale in Google Earth Engine ensures accurate results while optimizing computational efficiency. This section provides practical guidelines for managing these critical aspects of geospatial analysis in GEE.</p>"},{"location":"gee/0.%20Supplementary/projection/#letting-gee-handle-projections-dynamically","title":"Letting GEE Handle Projections Dynamically","text":"<p>In most cases, allowing GEE to manage projections automatically is the most efficient approach:</p>"},{"location":"gee/0.%20Supplementary/projection/#when-to-rely-on-automatic-handling","title":"When to Rely on Automatic Handling","text":"<ul> <li>For exploratory analysis and visualization</li> <li>When working with a single dataset or multiple datasets in the same projection</li> <li>For operations that don't require precise area or distance measurements</li> <li>When computational efficiency is a priority</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#example-efficient-visualization","title":"Example: Efficient Visualization","text":"<pre><code>// Let GEE handle projection automatically for visualization\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nMap.centerObject(landsat, 9);\nMap.addLayer(landsat, {bands: ['B4', 'B3', 'B2'], max: 0.3}, 'Landsat 8');\n\n// No need to specify projection - GEE will use Web Mercator for display\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#example-simple-band-calculations","title":"Example: Simple Band Calculations","text":"<pre><code>// For simple band calculations, let GEE handle projection\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']);\nMap.addLayer(ndvi, {min: -1, max: 1, palette: ['blue', 'white', 'green']}, 'NDVI');\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#checking-native-projections-before-operations","title":"Checking Native Projections Before Operations","text":"<p>Before performing operations, especially with unfamiliar datasets, check the native projection:</p>"},{"location":"gee/0.%20Supplementary/projection/#how-to-check-projections","title":"How to Check Projections","text":"<pre><code>// Check the projection of an image\nvar image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar proj = image.projection();\nprint('Image Projection:', proj);\nprint('Scale in meters:', proj.nominalScale());\n\n// For image collections, check projection of a sample image\nvar collection = ee.ImageCollection('MODIS/006/MOD13Q1');\nvar sampleImage = collection.first();\nprint('Sample Image Projection:', sampleImage.projection());\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#checking-for-projection-mismatches","title":"Checking for Projection Mismatches","text":"<p>When working with multiple datasets:</p> <pre><code>// Check projections of multiple datasets\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar sentinel = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\n\nprint('Landsat Projection:', landsat.projection());\nprint('Sentinel-2 Projection:', sentinel.projection());\n\n// If projections differ significantly, consider explicit reprojection for critical analyses\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#using-appropriate-projections-for-area-calculations","title":"Using Appropriate Projections for Area Calculations","text":"<p>For accurate area calculations, always use an equal-area projection:</p>"},{"location":"gee/0.%20Supplementary/projection/#equal-area-projections-in-gee","title":"Equal-Area Projections in GEE","text":"<ul> <li>EPSG:6933 (Equal Earth) - Good for global analyses</li> <li>EPSG:5070 (NAD83 / Conus Albers) - Optimized for continental US</li> <li>EPSG:3035 (ETRS89-extended / LAEA Europe) - Optimized for Europe</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#example-accurate-forest-area-calculation","title":"Example: Accurate Forest Area Calculation","text":"<pre><code>// Calculate forest area using an equal-area projection\nvar hansen = ee.Image('UMD/hansen/global_forest_change_2020_v1_8');\nvar treecover = hansen.select('treecover2000');\nvar forest = treecover.gt(30);  // Areas with &gt;30% tree cover\n\n// Use pixelArea() and an equal-area projection\nvar forestArea = forest.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: studyRegion,\n  scale: 30,\n  crs: 'EPSG:6933',  // Equal Earth projection\n  maxPixels: 1e13\n});\n\nprint('Forest area (square meters):', forestArea.get('treecover2000'));\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#example-regional-area-calculation","title":"Example: Regional Area Calculation","text":"<pre><code>// For regional analysis, use a regionally optimized equal-area projection\nvar usStates = ee.FeatureCollection('TIGER/2018/States');\nvar california = usStates.filter(ee.Filter.eq('NAME', 'California'));\n\nvar landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover');\nvar urban = landcover.eq(23).or(landcover.eq(24));  // Urban land cover classes\n\nvar urbanArea = urban.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: california,\n  scale: 30,\n  crs: 'EPSG:5070',  // NAD83 / Conus Albers (optimized for US)\n  maxPixels: 1e13\n});\n\nprint('Urban area in California (square meters):', urbanArea.get('landcover'));\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#specifying-scale-parameters-correctly","title":"Specifying Scale Parameters Correctly","text":"<p>Proper scale specification is crucial for accurate and efficient analysis:</p>"},{"location":"gee/0.%20Supplementary/projection/#guidelines-for-scale-selection","title":"Guidelines for Scale Selection","text":"<ol> <li>Match the analysis purpose: Use finer scales for detailed analysis, coarser scales for regional patterns</li> <li>Consider native resolution: Start with the native resolution of your primary dataset</li> <li>Balance accuracy and performance: Finer scales increase accuracy but require more computation</li> <li>Be consistent: Use the same scale for comparative analyses</li> </ol>"},{"location":"gee/0.%20Supplementary/projection/#example-appropriate-scale-for-different-sensors","title":"Example: Appropriate Scale for Different Sensors","text":"<pre><code>// Use appropriate scales based on sensor resolution\nfunction analyzeWithAppropriateScale(image, sensor) {\n  var scale;\n\n  // Set scale based on sensor type\n  if (sensor === 'landsat') {\n    scale = 30;  // Landsat optical bands are 30m\n  } else if (sensor === 'sentinel2') {\n    scale = 10;  // Sentinel-2 visible bands are 10m\n  } else if (sensor === 'modis') {\n    scale = 250;  // MODIS NDVI is 250m\n  } else {\n    scale = 100;  // Default scale\n  }\n\n  // Perform analysis at the appropriate scale\n  var ndvi = image.normalizedDifference(['nir', 'red']);\n  var stats = ndvi.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: studyArea,\n    scale: scale,\n    maxPixels: 1e13\n  });\n\n  return stats;\n}\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#example-scale-parameter-in-common-functions","title":"Example: Scale Parameter in Common Functions","text":"<pre><code>// Properly specify scale in common GEE functions\nvar image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// For reduceRegion\nvar stats = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: studyArea,\n  scale: 30,  // Explicitly set scale to Landsat resolution\n  maxPixels: 1e13\n});\n\n// For sample\nvar samples = image.sample({\n  region: studyArea,\n  scale: 30,\n  numPixels: 500,\n  seed: 123\n});\n\n// For export\nExport.image.toDrive({\n  image: image.select(['B4', 'B3', 'B2']),\n  description: 'landsat_rgb',\n  scale: 30,\n  region: studyArea,\n  maxPixels: 1e13\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#avoiding-unnecessary-reprojection","title":"Avoiding Unnecessary Reprojection","text":"<p>Unnecessary reprojection can significantly impact performance and should be avoided:</p>"},{"location":"gee/0.%20Supplementary/projection/#when-to-avoid-reproject","title":"When to Avoid reproject()","text":"<ul> <li>For visualization purposes (GEE handles this automatically)</li> <li>When working with a single dataset</li> <li>For exploratory analysis</li> <li>When the default projection is suitable for your analysis</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#example-inefficient-vs-efficient-approach","title":"Example: Inefficient vs. Efficient Approach","text":"<pre><code>// INEFFICIENT: Unnecessary reprojection\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar reprojected = landsat.reproject({\n  crs: 'EPSG:4326',\n  scale: 30\n});\nvar ndvi = reprojected.normalizedDifference(['B5', 'B4']);\n\n// EFFICIENT: Let GEE handle projection\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']);\n// Only specify projection when exporting or for specific analysis needs\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#using-reduceresolution-for-aggregation","title":"Using reduceResolution() for Aggregation","text":"<p>For changing resolution, <code>reduceResolution()</code> is more appropriate than <code>reproject()</code>:</p>"},{"location":"gee/0.%20Supplementary/projection/#example-proper-resolution-reduction","title":"Example: Proper Resolution Reduction","text":"<pre><code>// Aggregate Sentinel-2 10m bands to 30m resolution\nvar sentinel2 = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\nvar rgb = sentinel2.select(['B4', 'B3', 'B2']);\n\n// RECOMMENDED: Use reduceResolution for aggregation\nvar aggregated = rgb.reduceResolution({\n  reducer: ee.Reducer.mean(),\n  maxPixels: 1024\n}).reproject({\n  crs: rgb.projection(),\n  scale: 30\n});\n\n// NOT RECOMMENDED: Using only reproject for aggregation\nvar reprojectedOnly = rgb.reproject({\n  crs: rgb.projection(),\n  scale: 30\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#optimizing-computation-with-proper-scale-settings","title":"Optimizing Computation with Proper Scale Settings","text":"<p>Strategic scale selection can dramatically improve performance:</p>"},{"location":"gee/0.%20Supplementary/projection/#multi-scale-analysis-approach","title":"Multi-Scale Analysis Approach","text":"<p>For complex analyses, consider a multi-scale approach:</p> <pre><code>// Multi-scale analysis approach\n// 1. Initial coarse-scale analysis for the entire region\nvar coarseResults = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: largeRegion,\n  scale: 1000,  // Coarse scale for efficiency\n  maxPixels: 1e13\n});\n\n// 2. Identify areas of interest based on coarse results\nvar threshold = 0.5;\nvar areasOfInterest = image.gt(threshold);\n\n// 3. Detailed analysis only in areas of interest\nvar detailedResults = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: areasOfInterest.geometry(),\n  scale: 30,  // Fine scale for accuracy\n  maxPixels: 1e13\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#progressive-loading-for-visualization","title":"Progressive Loading for Visualization","text":"<p>For visualizing large datasets:</p> <pre><code>// Progressive loading at different scales\nMap.setOptions('HYBRID');\n\n// Add coarse overview layer (loads quickly)\nMap.addLayer(\n  image.reproject({scale: 500}),\n  visualizationParams,\n  'Overview (coarse)',\n  false\n);\n\n// Add medium resolution layer\nMap.addLayer(\n  image.reproject({scale: 100}),\n  visualizationParams,\n  'Medium resolution',\n  false\n);\n\n// Add full resolution layer (loads at native resolution when zoomed in)\nMap.addLayer(\n  image,\n  visualizationParams,\n  'Full resolution'\n);\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#documentation-and-reproducibility","title":"Documentation and Reproducibility","text":"<p>Proper documentation of projection and scale choices ensures reproducibility:</p>"},{"location":"gee/0.%20Supplementary/projection/#example-self-documenting-code","title":"Example: Self-Documenting Code","text":"<pre><code>// Self-documenting projection and scale choices\nvar analysisParams = {\n  // Document why this projection was chosen\n  crs: 'EPSG:6933',  // Equal Earth projection for accurate global area calculation\n\n  // Document why this scale was chosen\n  scale: 30,  // Using Landsat native resolution to match input data\n\n  // Other parameters\n  maxPixels: 1e13\n};\n\n// Use the documented parameters\nvar results = image.multiply(ee.Image.pixelArea()).reduceRegion({\n  reducer: ee.Reducer.sum(),\n  geometry: studyRegion,\n  scale: analysisParams.scale,\n  crs: analysisParams.crs,\n  maxPixels: analysisParams.maxPixels\n});\n\n// Print parameters for reproducibility\nprint('Analysis parameters:', analysisParams);\n</code></pre> <p>By following these best practices, you can ensure accurate results while optimizing computational efficiency in your Google Earth Engine workflows. In the next section, we'll explore common errors related to projection and scale and how to troubleshoot them.</p>"},{"location":"gee/0.%20Supplementary/projection/#7-common-errors-and-troubleshooting","title":"7. Common Errors and Troubleshooting","text":"<p>When working with projections and scale in Google Earth Engine, you may encounter various errors and challenges. This section identifies common issues and provides practical solutions to help you troubleshoot effectively.</p>"},{"location":"gee/0.%20Supplementary/projection/#default-wgs84-projection-errors","title":"Default WGS84 Projection Errors","text":"<p>One of the most common errors in GEE relates to the default WGS84 projection with 1-degree scale:</p>"},{"location":"gee/0.%20Supplementary/projection/#the-error-message","title":"The Error Message","text":"<pre><code>The default WGS84 projection is invalid for aggregations. Specify a scale or crs &amp; crs_transform.\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#why-it-occurs","title":"Why It Occurs","text":"<p>This error typically happens when: - You're reducing an <code>ImageCollection</code> containing images with different projections - You're creating a composite or mosaic from images with different projections - You're performing an aggregation operation without specifying scale parameters</p>"},{"location":"gee/0.%20Supplementary/projection/#how-to-fix-it","title":"How to Fix It","text":"<pre><code>// PROBLEMATIC CODE\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA');\nvar mosaic = collection.filterDate('2018-01-01', '2019-01-01').mosaic();\n// This will have the default WGS84 projection with 1-degree scale\n\n// Trying to calculate statistics will cause an error\nvar stats = mosaic.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: studyArea\n  // Missing scale parameter!\n});\n\n// SOLUTION 1: Specify scale when reducing\nvar stats = mosaic.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: studyArea,\n  scale: 30,  // Explicitly set scale\n  maxPixels: 1e13\n});\n\n// SOLUTION 2: Force a specific projection before reducing\nvar reprojected = mosaic.reproject({\n  crs: 'EPSG:3857',\n  scale: 30\n});\n\nvar stats = reprojected.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: studyArea,\n  scale: 30,\n  maxPixels: 1e13\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#scale-related-computation-issues","title":"Scale-Related Computation Issues","text":"<p>Inappropriate scale settings can lead to computation errors or unexpected results:</p>"},{"location":"gee/0.%20Supplementary/projection/#memory-limit-exceeded","title":"Memory Limit Exceeded","text":"<pre><code>Computation timed out. Error: Computation timed out.\n</code></pre> <p>This often occurs when processing large areas at fine resolution.</p>"},{"location":"gee/0.%20Supplementary/projection/#how-to-fix-it_1","title":"How to Fix It","text":"<pre><code>// PROBLEMATIC CODE\nvar stats = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: largeRegion,\n  scale: 10  // Very fine scale for a large region\n});\n\n// SOLUTION 1: Use a coarser scale\nvar stats = image.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: largeRegion,\n  scale: 100,  // Coarser scale\n  maxPixels: 1e13\n});\n\n// SOLUTION 2: Break the analysis into smaller regions\nvar subregions = largeRegion.geometry().cut(gridSize);\nvar statsCollection = ee.FeatureCollection(subregions).map(function(subregion) {\n  return ee.Feature(null, image.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: subregion,\n    scale: 10,\n    maxPixels: 1e13\n  }));\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#unexpected-no-data-results","title":"Unexpected \"No Data\" Results","text":"<p>When your analysis returns unexpected null or \"no data\" values:</p> <pre><code>// PROBLEMATIC CODE\nvar point = ee.Geometry.Point([-122.0841, 37.4223]);\nvar value = image.reduceRegion({\n  reducer: ee.Reducer.first(),\n  geometry: point,\n  scale: 1000  // Scale much coarser than image resolution\n}).get('B4');\nprint(value);  // Might return null\n\n// SOLUTION: Use a scale appropriate to the data\nvar value = image.reduceRegion({\n  reducer: ee.Reducer.first(),\n  geometry: point,\n  scale: 30  // Match the image's native resolution\n}).get('B4');\nprint(value);  // Should return a value\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#handling-images-with-bands-in-different-projections","title":"Handling Images with Bands in Different Projections","text":"<p>Some images have bands with different native projections, which can cause errors:</p>"},{"location":"gee/0.%20Supplementary/projection/#the-error-message_1","title":"The Error Message","text":"<pre><code>Image.projection: The bands of the specified image contain different projections. Use Image.select to pick a single band.\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#how-to-fix-it_2","title":"How to Fix It","text":"<pre><code>// PROBLEMATIC CODE\nvar sentinel2 = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\nprint(sentinel2.projection());  // Error: bands have different projections\n\n// SOLUTION 1: Select specific bands before checking projection\nvar band4 = sentinel2.select('B4');\nprint(band4.projection());  // Works for a single band\n\n// SOLUTION 2: Force a common projection for all bands\nvar reprojected = sentinel2.reproject({\n  crs: 'EPSG:3857',\n  scale: 10\n});\nprint(reprojected.projection());  // All bands now have the same projection\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#debugging-projection-mismatches","title":"Debugging Projection Mismatches","text":"<p>When combining datasets with different projections, unexpected results can occur:</p>"},{"location":"gee/0.%20Supplementary/projection/#visual-misalignment","title":"Visual Misalignment","text":"<p>If layers appear misaligned when visualized together:</p> <pre><code>// PROBLEMATIC VISUALIZATION\nMap.addLayer(dataset1, {}, 'Dataset 1');\nMap.addLayer(dataset2, {}, 'Dataset 2');  // Appears misaligned\n\n// SOLUTION: Ensure consistent projection for visualization\nvar commonProjection = {crs: 'EPSG:3857', scale: 30};\nMap.addLayer(dataset1.reproject(commonProjection), {}, 'Dataset 1');\nMap.addLayer(dataset2.reproject(commonProjection), {}, 'Dataset 2');\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#unexpected-analysis-results","title":"Unexpected Analysis Results","text":"<p>If analysis results seem incorrect when combining datasets:</p> <pre><code>// PROBLEMATIC ANALYSIS\nvar combined = dataset1.addBands(dataset2);\nvar index = combined.normalizedDifference(['band1', 'band2']);  // Results may be incorrect\n\n// SOLUTION: Ensure consistent projection before analysis\nvar commonProjection = {crs: 'EPSG:3857', scale: 30};\nvar dataset1Reprojected = dataset1.reproject(commonProjection);\nvar dataset2Reprojected = dataset2.reproject(commonProjection);\nvar combined = dataset1Reprojected.addBands(dataset2Reprojected);\nvar index = combined.normalizedDifference(['band1', 'band2']);  // More reliable results\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#performance-optimization-tips","title":"Performance Optimization Tips","text":"<p>When facing performance issues related to projection and scale:</p>"},{"location":"gee/0.%20Supplementary/projection/#slow-computation","title":"Slow Computation","text":"<pre><code>// INEFFICIENT CODE\nvar globalImage = ee.Image('MODIS/006/MOD13Q1/2019_01_01');\nvar reprojected = globalImage.reproject({\n  crs: 'EPSG:4326',\n  scale: 250\n});\nvar stats = reprojected.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: ee.Geometry.Rectangle([-180, -90, 180, 90]),  // Global extent\n  scale: 250\n});\n\n// OPTIMIZED SOLUTION\nvar globalImage = ee.Image('MODIS/006/MOD13Q1/2019_01_01');\n// Only reproject if absolutely necessary\nvar stats = globalImage.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: studyArea,  // Limit to area of interest\n  scale: 1000,  // Use coarser scale for global analysis\n  maxPixels: 1e13\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#export-failures","title":"Export Failures","text":"<p>When exports fail due to projection or scale issues:</p> <pre><code>// PROBLEMATIC EXPORT\nExport.image.toDrive({\n  image: highResImage,\n  region: largeRegion,\n  scale: 10,  // Very fine scale\n  maxPixels: 1e8  // Default max pixels\n});\n\n// SOLUTION 1: Increase maxPixels\nExport.image.toDrive({\n  image: highResImage,\n  region: largeRegion,\n  scale: 10,\n  maxPixels: 1e13  // Increased limit\n});\n\n// SOLUTION 2: Use a more appropriate scale\nExport.image.toDrive({\n  image: highResImage,\n  region: largeRegion,\n  scale: 30,  // Coarser scale\n  maxPixels: 1e13\n});\n\n// SOLUTION 3: Break into multiple exports\n// Split the region into smaller parts and export each separately\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#troubleshooting-workflow","title":"Troubleshooting Workflow","text":"<p>When encountering projection or scale-related issues, follow this systematic troubleshooting workflow:</p> <ol> <li>Identify the error message: Understand what specific error you're facing</li> <li> <p>Check projections: Print the projection of all input datasets    <pre><code>print('Dataset 1 projection:', dataset1.projection());\nprint('Dataset 2 projection:', dataset2.projection());\n</code></pre></p> </li> <li> <p>Verify scale parameters: Ensure scale parameters are appropriate for your data and analysis    <pre><code>print('Native scale in meters:', dataset1.projection().nominalScale());\n</code></pre></p> </li> <li> <p>Test with simplified data: Reduce the complexity of your analysis to isolate the issue    <pre><code>// Test with a single band\nvar singleBand = dataset1.select('B4');\n</code></pre></p> </li> <li> <p>Implement explicit projection control: When automatic handling fails, take manual control    <pre><code>var controlled = dataset1.reproject({\n  crs: 'EPSG:3857',\n  scale: 30\n});\n</code></pre></p> </li> <li> <p>Monitor computation resources: Check if you're exceeding memory or processing limits    <pre><code>// Reduce the size of your analysis\nvar smallerRegion = largeRegion.bounds().buffer(-10000);\n</code></pre></p> </li> <li> <p>Optimize step by step: Incrementally improve your code, testing after each change</p> </li> </ol> <p>By understanding these common errors and their solutions, you can effectively troubleshoot projection and scale issues in Google Earth Engine, ensuring accurate results and efficient computation. In the next section, we'll explore practical examples with complete code to demonstrate these concepts in real-world scenarios.</p>"},{"location":"gee/0.%20Supplementary/projection/#8-practical-examples-with-code","title":"8. Practical Examples with Code","text":"<p>This section provides complete, practical examples that demonstrate how to effectively handle projection and scale in Google Earth Engine. Each example addresses a common geospatial analysis scenario with fully functional code and detailed explanations.</p>"},{"location":"gee/0.%20Supplementary/projection/#example-1-checking-an-images-native-projection-and-scale","title":"Example 1: Checking an Image's Native Projection and Scale","text":"<p>Understanding the native projection and scale of your data is the first step in any GEE analysis. This example demonstrates how to retrieve and interpret this information.</p> <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Get the projection information\nvar projection = landsat.projection();\nprint('Landsat 8 projection:', projection);\n\n// Get the nominal scale (resolution) in meters\nvar scale = projection.nominalScale();\nprint('Nominal scale in meters:', scale);\n\n// Check projection of a specific band\nvar nirBand = landsat.select('B5');\nprint('NIR band projection:', nirBand.projection());\n\n// Load a MODIS image for comparison\nvar modis = ee.Image('MODIS/006/MOD13Q1/2019_01_01');\nprint('MODIS projection:', modis.projection());\nprint('MODIS nominal scale in meters:', modis.projection().nominalScale());\n\n// Visualize the Landsat image\nMap.centerObject(landsat, 9);\nMap.addLayer(landsat, {bands: ['B4', 'B3', 'B2'], max: 0.3}, 'Landsat 8 True Color');\n</code></pre> <p>Key Points: - The <code>projection()</code> method returns an <code>ee.Projection</code> object containing CRS and transformation information - <code>nominalScale()</code> returns the native resolution in meters - Different datasets have different native projections and scales - Understanding these properties helps you make informed decisions about analysis parameters</p>"},{"location":"gee/0.%20Supplementary/projection/#example-2-working-with-multiple-datasets-with-different-projections","title":"Example 2: Working with Multiple Datasets with Different Projections","text":"<p>This example demonstrates how to properly combine and analyze datasets with different native projections.</p> <pre><code>// Load datasets with different projections\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar sentinel2 = ee.Image('COPERNICUS/S2/20190310T105851_20190310T110327_T30UWU');\nvar dem = ee.Image('USGS/SRTMGL1_003');\n\n// Print their native projections\nprint('Landsat projection:', landsat.projection());\nprint('Sentinel-2 projection:', sentinel2.select('B4').projection());\nprint('SRTM DEM projection:', dem.projection());\n\n// Define a region of interest where the datasets overlap\nvar roi = landsat.geometry().intersection(sentinel2.geometry());\nMap.centerObject(roi, 10);\n\n// Calculate NDVI from both Landsat and Sentinel-2\nvar landsatNDVI = landsat.normalizedDifference(['B5', 'B4']).rename('landsat_ndvi');\nvar sentinel2NDVI = sentinel2.normalizedDifference(['B8', 'B4']).rename('sentinel2_ndvi');\n\n// Method 1: Let GEE handle projections automatically\nvar ndviDifference = sentinel2NDVI.subtract(landsatNDVI).rename('ndvi_diff');\n\n// Method 2: Explicitly control projection\nvar commonProjection = {\n  crs: 'EPSG:3857',\n  scale: 30\n};\n\nvar landsatNDVI_reprojected = landsatNDVI.reproject(commonProjection);\nvar sentinel2NDVI_reprojected = sentinel2NDVI.reproject(commonProjection);\nvar ndviDifference_controlled = sentinel2NDVI_reprojected.subtract(landsatNDVI_reprojected);\n\n// Add elevation data\nvar elevation = dem.clip(roi);\n\n// Create a composite with multiple datasets\nvar composite = ee.Image.cat([\n  landsatNDVI_reprojected,\n  sentinel2NDVI_reprojected,\n  ndviDifference_controlled,\n  elevation\n]).reproject(commonProjection);\n\n// Visualize results\nMap.addLayer(landsatNDVI, {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, 'Landsat NDVI');\nMap.addLayer(sentinel2NDVI, {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, 'Sentinel-2 NDVI', false);\nMap.addLayer(ndviDifference, {min: -0.2, max: 0.2, palette: ['red', 'white', 'green']}, 'NDVI Difference (Auto)', false);\nMap.addLayer(ndviDifference_controlled, {min: -0.2, max: 0.2, palette: ['red', 'white', 'green']}, 'NDVI Difference (Controlled)');\n</code></pre> <p>Key Points: - GEE can automatically align datasets with different projections - For critical analyses, explicitly controlling projection ensures consistency - When combining multiple datasets, consider using a common projection that minimizes distortion for your study area - Visualize intermediate results to verify proper alignment</p>"},{"location":"gee/0.%20Supplementary/projection/#example-3-proper-area-calculation-with-equal-area-projections","title":"Example 3: Proper Area Calculation with Equal-Area Projections","text":"<p>This example demonstrates how to calculate accurate areas using appropriate projections.</p> <pre><code>// Load global forest cover data\nvar hansen = ee.Image('UMD/hansen/global_forest_change_2020_v1_8');\nvar treecover = hansen.select('treecover2000');\nvar forest = treecover.gt(30);  // Areas with &gt;30% tree cover\n\n// Define regions for comparison\nvar equatorial = ee.Geometry.Rectangle([20, -10, 40, 10]);  // Equatorial Africa\nvar highLatitude = ee.Geometry.Rectangle([20, 50, 40, 70]);  // Northern Europe\n\n// Calculate forest area using different projections\nfunction calculateArea(region, name) {\n  // Method 1: Using Web Mercator (INCORRECT for area calculations)\n  var areaWM = forest.multiply(ee.Image.pixelArea()).reduceRegion({\n    reducer: ee.Reducer.sum(),\n    geometry: region,\n    scale: 30,\n    crs: 'EPSG:3857',  // Web Mercator\n    maxPixels: 1e13\n  }).get('treecover2000');\n\n  // Method 2: Using WGS84 (INCORRECT for area calculations)\n  var areaWGS = forest.multiply(ee.Image.pixelArea()).reduceRegion({\n    reducer: ee.Reducer.sum(),\n    geometry: region,\n    scale: 30,\n    crs: 'EPSG:4326',  // WGS84\n    maxPixels: 1e13\n  }).get('treecover2000');\n\n  // Method 3: Using Equal Earth (CORRECT for area calculations)\n  var areaEE = forest.multiply(ee.Image.pixelArea()).reduceRegion({\n    reducer: ee.Reducer.sum(),\n    geometry: region,\n    scale: 30,\n    crs: 'EPSG:6933',  // Equal Earth\n    maxPixels: 1e13\n  }).get('treecover2000');\n\n  // Print results\n  print(name + ' forest area (Web Mercator):', areaWM);\n  print(name + ' forest area (WGS84):', areaWGS);\n  print(name + ' forest area (Equal Earth):', areaEE);\n\n  return ee.Feature(null, {\n    'region': name,\n    'web_mercator': areaWM,\n    'wgs84': areaWGS,\n    'equal_earth': areaEE\n  });\n}\n\n// Calculate and compare areas\nvar equatorialAreas = calculateArea(equatorial, 'Equatorial');\nvar highLatitudeAreas = calculateArea(highLatitude, 'High Latitude');\n\n// Visualize the regions and forest cover\nMap.setCenter(30, 30, 4);\nMap.addLayer(forest.clip(equatorial.union(highLatitude)), {palette: ['black', 'green']}, 'Forest Cover');\nMap.addLayer(equatorial, {color: 'blue'}, 'Equatorial Region');\nMap.addLayer(highLatitude, {color: 'red'}, 'High Latitude Region');\n\n// Create a chart to compare the results\nvar chart = ui.Chart.feature.byFeature([equatorialAreas, highLatitudeAreas], 'region', ['web_mercator', 'wgs84', 'equal_earth'])\n  .setChartType('ColumnChart')\n  .setOptions({\n    title: 'Forest Area by Projection and Region',\n    vAxis: {title: 'Area (square meters)'},\n    hAxis: {title: 'Region'},\n    series: {\n      0: {color: 'blue'},\n      1: {color: 'red'},\n      2: {color: 'green'}\n    }\n  });\nprint(chart);\n</code></pre> <p>Key Points: - Web Mercator (EPSG:3857) significantly distorts areas, especially at high latitudes - WGS84 (EPSG:4326) also introduces area distortions - Equal Earth (EPSG:6933) preserves area relationships and provides accurate measurements - The difference between projections becomes more pronounced at higher latitudes - Always use an equal-area projection for area calculations</p>"},{"location":"gee/0.%20Supplementary/projection/#example-4-exporting-data-with-specific-projections-and-scales","title":"Example 4: Exporting Data with Specific Projections and Scales","text":"<p>This example demonstrates how to properly export data with controlled projection and scale settings.</p> <pre><code>// Load and prepare data\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']).rename('ndvi');\nvar rgb = landsat.select(['B4', 'B3', 'B2']);\n\n// Define export region\nvar exportRegion = landsat.geometry().bounds();\nMap.centerObject(exportRegion, 9);\nMap.addLayer(rgb, {max: 0.3}, 'RGB');\nMap.addLayer(ndvi, {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, 'NDVI');\n\n// Example 1: Export at native Landsat resolution in UTM projection\nExport.image.toDrive({\n  image: ndvi,\n  description: 'NDVI_UTM_30m',\n  folder: 'GEE_Exports',\n  region: exportRegion,\n  scale: 30,\n  crs: landsat.projection(),  // Use the native UTM projection\n  maxPixels: 1e13,\n  fileFormat: 'GeoTIFF'\n});\n\n// Example 2: Export at 10m resolution in Web Mercator\nExport.image.toDrive({\n  image: ndvi,\n  description: 'NDVI_WebMercator_10m',\n  folder: 'GEE_Exports',\n  region: exportRegion,\n  scale: 10,  // Higher resolution than native\n  crs: 'EPSG:3857',  // Web Mercator\n  maxPixels: 1e13,\n  fileFormat: 'GeoTIFF'\n});\n\n// Example 3: Export at coarser resolution in WGS84\nExport.image.toDrive({\n  image: ndvi,\n  description: 'NDVI_WGS84_100m',\n  folder: 'GEE_Exports',\n  region: exportRegion,\n  scale: 100,  // Coarser resolution\n  crs: 'EPSG:4326',  // WGS84\n  maxPixels: 1e13,\n  fileFormat: 'GeoTIFF'\n});\n\n// Example 4: Export RGB composite with custom dimensions\nExport.image.toDrive({\n  image: rgb,\n  description: 'RGB_Custom_Dimensions',\n  folder: 'GEE_Exports',\n  region: exportRegion,\n  dimensions: 1024,  // Fixed pixel dimensions instead of scale\n  crs: 'EPSG:3857',\n  maxPixels: 1e13,\n  fileFormat: 'GeoTIFF'\n});\n\n// Print export information\nprint('Export region area (sq km):', exportRegion.area().divide(1e6));\nprint('Native Landsat resolution (m):', landsat.projection().nominalScale());\n</code></pre> <p>Key Points: - The <code>scale</code> parameter determines the pixel size in meters - The <code>crs</code> parameter determines the coordinate reference system - Using the native projection and scale is often optimal for preserving data integrity - Exporting at finer scales than native resolution doesn't add real information but increases file size - The <code>dimensions</code> parameter can be used instead of <code>scale</code> to control output size - Consider file size and intended use when selecting export parameters</p>"},{"location":"gee/0.%20Supplementary/projection/#example-5-visualizing-effects-of-different-projections","title":"Example 5: Visualizing Effects of Different Projections","text":"<p>This example demonstrates the visual effects of different projections, particularly for global datasets.</p> <pre><code>// Load a global dataset\nvar worldPopulation = ee.ImageCollection('CIESIN/GPWv411/GPW_Population_Count')\n  .first()\n  .select('population_count');\n\n// Function to reproject and visualize with different projections\nfunction addProjectedLayer(projection, name, center, zoom) {\n  var reprojected = worldPopulation.reproject({\n    crs: projection,\n    scale: 10000\n  });\n\n  Map.addLayer(reprojected, {\n    min: 0,\n    max: 1000,\n    palette: ['blue', 'yellow', 'red']\n  }, name, false);\n\n  // Add a button to center the map on this projection view\n  var button = ui.Button({\n    label: 'View: ' + name,\n    onClick: function() {\n      Map.setCenter(center[0], center[1], zoom);\n    }\n  });\n  panel.add(button);\n}\n\n// Create a panel for projection buttons\nvar panel = ui.Panel({\n  style: {\n    position: 'top-right',\n    padding: '8px'\n  }\n});\nMap.add(panel);\n\n// Add layers with different projections\naddProjectedLayer('EPSG:3857', 'Web Mercator', [0, 0], 2);\naddProjectedLayer('EPSG:4326', 'WGS84', [0, 0], 2);\naddProjectedLayer('EPSG:6933', 'Equal Earth', [0, 0], 2);\naddProjectedLayer('EPSG:3031', 'Antarctic Polar Stereographic', [0, -90], 3);\naddProjectedLayer('EPSG:3995', 'Arctic Polar Stereographic', [0, 90], 3);\naddProjectedLayer('EPSG:54009', 'Mollweide', [0, 0], 2);\n\n// Add country boundaries for reference\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nMap.addLayer(countries, {color: 'white'}, 'Country Boundaries');\n\n// Set initial view\nMap.setCenter(0, 0, 2);\nMap.setOptions('HYBRID');\n</code></pre> <p>Key Points: - Different projections represent the Earth's curved surface in different ways - Web Mercator (EPSG:3857) preserves angles but distorts areas, especially at high latitudes - Equal Earth (EPSG:6933) preserves area relationships but distorts shapes - Polar projections are optimized for high latitudes - The choice of projection affects how data is visualized and analyzed - No single projection is perfect for all purposes</p> <p>These practical examples demonstrate how to effectively handle projection and scale in various Google Earth Engine workflows. By applying these techniques, you can ensure accurate analyses while optimizing computational efficiency. In the next section, we'll explore advanced topics related to projection and scale in GEE.</p>"},{"location":"gee/0.%20Supplementary/projection/#9-advanced-topics","title":"9. Advanced Topics","text":"<p>This section explores specialized and advanced concepts related to projection and scale in Google Earth Engine. These topics are particularly relevant for complex analyses, large-scale applications, and users seeking to optimize their GEE workflows.</p>"},{"location":"gee/0.%20Supplementary/projection/#working-with-multi-resolution-datasets","title":"Working with Multi-Resolution Datasets","text":"<p>Many remote sensing applications require combining data from sensors with different native resolutions. This presents unique challenges for maintaining data integrity while optimizing computational efficiency.</p>"},{"location":"gee/0.%20Supplementary/projection/#strategies-for-multi-resolution-analysis","title":"Strategies for Multi-Resolution Analysis","text":"<p>When working with multi-resolution datasets, consider these approaches:</p> <ol> <li>Resolution Harmonization: Reproject all datasets to a common resolution</li> <li>Typically set to the coarsest resolution among input datasets to avoid creating artificial data</li> <li> <p>Alternatively, set to the finest resolution when detail preservation is critical</p> </li> <li> <p>Resolution-Aware Processing: Process each dataset at its native resolution before combining results</p> </li> <li>Preserves the unique information content of each dataset</li> <li> <p>Reduces computational overhead from unnecessary upsampling</p> </li> <li> <p>Hierarchical Multi-Scale Analysis: Process data at multiple scales sequentially</p> </li> <li>Begin with coarse resolution for broad patterns</li> <li>Progressively refine analysis in areas of interest using finer resolution data</li> </ol>"},{"location":"gee/0.%20Supplementary/projection/#example-combining-landsat-and-modis-data","title":"Example: Combining Landsat and MODIS Data","text":"<pre><code>// Load Landsat (30m) and MODIS (500m) data\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar modis = ee.Image('MODIS/006/MOD09GA/2014_03_18');\n\n// Approach 1: Harmonize to coarser resolution (MODIS)\nvar landsatCoarse = landsat.select(['B4', 'B3', 'B2']).reduceResolution({\n  reducer: ee.Reducer.mean(),\n  maxPixels: 1024\n}).reproject({\n  crs: modis.projection(),\n  scale: 500\n});\n\n// Approach 2: Maintain Landsat resolution but incorporate MODIS data\nvar modisUpsampled = modis.select(['sur_refl_b01', 'sur_refl_b04', 'sur_refl_b03'])\n  .reproject({\n    crs: landsat.projection(),\n    scale: 30\n  });\n\n// Approach 3: Multi-scale analysis\n// First identify areas of interest at MODIS scale\nvar modisNDVI = modis.normalizedDifference(['sur_refl_b02', 'sur_refl_b01']);\nvar highNDVIAreas = modisNDVI.gt(0.7);\n\n// Then analyze these areas at Landsat resolution\nvar landsatNDVI = landsat.normalizedDifference(['B5', 'B4']);\nvar detailedAnalysis = landsatNDVI.updateMask(highNDVIAreas);\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#projection-issues-in-different-geographic-regions","title":"Projection Issues in Different Geographic Regions","text":"<p>Different geographic regions present unique projection challenges that require specialized approaches.</p>"},{"location":"gee/0.%20Supplementary/projection/#polar-regions_1","title":"Polar Regions","text":"<p>The poles present particular challenges for projection and scale:</p> <ul> <li>Extreme Distortion: Standard projections like Web Mercator become extremely distorted near the poles</li> <li>Convergence of Meridians: Longitude lines converge at the poles, causing computational issues</li> <li>Crossing the Dateline: Analysis across the 180\u00b0 meridian requires special handling</li> </ul> <p>For polar studies, use specialized polar projections: - Antarctic Polar Stereographic (EPSG:3031) for the South Pole region - Arctic Polar Stereographic (EPSG:3995) for the North Pole region</p> <pre><code>// Antarctic ice sheet analysis\nvar antarctica = ee.Geometry.Rectangle([-180, -90, 180, -60]);\nvar iceVelocity = ee.Image('CPOM/CryoSat2/ANTARCTICA_ICE_VELOCITY_2016');\n\n// Use appropriate polar projection\nvar polarProjection = {\n  crs: 'EPSG:3031',  // Antarctic Polar Stereographic\n  scale: 500\n};\n\n// Analyze with proper projection\nvar iceVelocityStats = iceVelocity.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: antarctica,\n  crs: polarProjection.crs,\n  scale: polarProjection.scale,\n  maxPixels: 1e13\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#equatorial-regions","title":"Equatorial Regions","text":"<p>Equatorial regions generally have minimal projection distortion in most systems, but considerations include:</p> <ul> <li>UTM Zone Transitions: Studies spanning multiple UTM zones require careful handling</li> <li>Seasonal Sun Angle Variations: Less extreme than polar regions but still relevant for time series</li> </ul>"},{"location":"gee/0.%20Supplementary/projection/#continental-scale-analysis_1","title":"Continental-Scale Analysis","text":"<p>For large continental analyses, specialized equal-area projections optimized for specific continents provide the best results:</p> <ul> <li>North America: Albers Equal Area Conic (EPSG:5070)</li> <li>Europe: ETRS89-extended / LAEA Europe (EPSG:3035)</li> <li>Africa: Africa Albers Equal Area Conic (ESRI:102022)</li> </ul> <pre><code>// Continental US analysis with appropriate projection\nvar usStates = ee.FeatureCollection('TIGER/2018/States');\nvar continentalUS = usStates.filter(ee.Filter.inList('NAME', [\n  'Washington', 'Oregon', 'California', 'Nevada', 'Idaho', 'Montana', 'Wyoming',\n  'Utah', 'Colorado', 'Arizona', 'New Mexico', 'North Dakota', 'South Dakota',\n  'Nebraska', 'Kansas', 'Oklahoma', 'Texas', 'Minnesota', 'Iowa', 'Missouri',\n  'Arkansas', 'Louisiana', 'Wisconsin', 'Illinois', 'Michigan', 'Indiana', 'Ohio',\n  'Kentucky', 'Tennessee', 'Mississippi', 'Alabama', 'Georgia', 'Florida',\n  'South Carolina', 'North Carolina', 'Virginia', 'West Virginia', 'Maryland',\n  'Delaware', 'Pennsylvania', 'New Jersey', 'New York', 'Connecticut',\n  'Rhode Island', 'Massachusetts', 'Vermont', 'New Hampshire', 'Maine'\n])).geometry();\n\n// Use Albers Equal Area Conic projection for US\nvar usAnalysis = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\n  .reduceRegion({\n    reducer: ee.Reducer.frequencyHistogram(),\n    geometry: continentalUS,\n    crs: 'EPSG:5070',  // NAD83 / Conus Albers\n    scale: 90,\n    maxPixels: 1e13\n  });\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#scale-and-projection-considerations-for-time-series-analysis","title":"Scale and Projection Considerations for Time-Series Analysis","text":"<p>Time-series analysis presents unique challenges for maintaining consistent scale and projection across temporal datasets.</p>"},{"location":"gee/0.%20Supplementary/projection/#ensuring-temporal-consistency","title":"Ensuring Temporal Consistency","text":"<p>For accurate time-series analysis:</p> <ol> <li>Consistent Projection: Use the same projection for all time points</li> <li>Consistent Scale: Process all images at the same scale</li> <li>Consistent Geometry: Ensure analysis boundaries remain fixed</li> </ol> <pre><code>// Time series analysis with consistent projection and scale\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterBounds(region)\n  .filterDate('2015-01-01', '2020-01-01');\n\n// Define consistent parameters\nvar analysisParams = {\n  crs: 'EPSG:3857',\n  scale: 30\n};\n\n// Process each image with consistent parameters\nvar processedCollection = collection.map(function(image) {\n  var ndvi = image.normalizedDifference(['B5', 'B4']);\n\n  // Force consistent projection and scale\n  return ndvi.reproject({\n    crs: analysisParams.crs,\n    scale: analysisParams.scale\n  }).set({\n    'system:time_start': image.get('system:time_start')\n  });\n});\n\n// Time series chart with consistent processing\nvar chart = ui.Chart.image.series({\n  imageCollection: processedCollection,\n  region: region,\n  reducer: ee.Reducer.mean(),\n  scale: analysisParams.scale\n}).setOptions({\n  title: 'NDVI Time Series',\n  vAxis: {title: 'NDVI'},\n  hAxis: {title: 'Date', format: 'MM-yyyy'}\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#handling-sensor-transitions","title":"Handling Sensor Transitions","text":"<p>When analyzing time series that span multiple sensors (e.g., Landsat 5 to Landsat 8):</p> <ol> <li>Cross-Calibration: Apply sensor-specific corrections before analysis</li> <li>Resolution Harmonization: Ensure consistent resolution across sensors</li> <li>Projection Alignment: Reproject to a common system</li> </ol> <pre><code>// Harmonized Landsat time series across sensors\nvar landsat5 = ee.ImageCollection('LANDSAT/LT05/C02/T1_TOA')\n  .filterBounds(region)\n  .filterDate('2010-01-01', '2012-01-01');\n\nvar landsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterBounds(region)\n  .filterDate('2013-01-01', '2015-01-01');\n\n// Harmonize Landsat 5 bands to match Landsat 8\nvar processL5 = function(image) {\n  // Cross-calibration coefficients (simplified example)\n  var ndvi = image.normalizedDifference(['B4', 'B3'])\n    .multiply(1.0).add(0.03);  // Adjust NDVI to match L8\n\n  return ndvi.reproject({\n    crs: 'EPSG:3857',\n    scale: 30\n  }).set({\n    'system:time_start': image.get('system:time_start'),\n    'sensor': 'L5'\n  });\n};\n\n// Process Landsat 8 with same projection and scale\nvar processL8 = function(image) {\n  var ndvi = image.normalizedDifference(['B5', 'B4']);\n\n  return ndvi.reproject({\n    crs: 'EPSG:3857',\n    scale: 30\n  }).set({\n    'system:time_start': image.get('system:time_start'),\n    'sensor': 'L8'\n  });\n};\n\n// Create harmonized collection\nvar harmonizedCollection = landsat5.map(processL5)\n  .merge(landsat8.map(processL8))\n  .sort('system:time_start');\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#custom-projection-transformations","title":"Custom Projection Transformations","text":"<p>For specialized analyses, you may need to create custom projections or transformations.</p>"},{"location":"gee/0.%20Supplementary/projection/#creating-custom-projections","title":"Creating Custom Projections","text":"<pre><code>// Create a custom projection centered on a study area\nvar centerPoint = ee.Geometry.Point([35, 0]);\n\n// Create an Albers Equal Area projection centered on the study area\nvar customProjection = ee.Projection('EPSG:4326')\n  .translate(centerPoint.coordinates().get(0), centerPoint.coordinates().get(1))\n  .scale(100, 100);  // 100-meter scale\n\n// Use the custom projection\nvar reprojected = image.reproject({\n  crs: customProjection,\n  scale: 100\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#working-with-projection-transforms","title":"Working with Projection Transforms","text":"<p>For advanced users, understanding and manipulating projection transforms provides fine-grained control:</p> <pre><code>// Extract and modify projection transform\nvar projection = image.projection();\nvar transform = projection.getInfo().transform;\n\n// Create a modified transform (e.g., to rotate or skew)\nvar modifiedTransform = [\n  transform[0], transform[1], transform[2],\n  transform[3], transform[4], transform[5]\n];\n\n// Apply the modified transform\nvar customProjection = ee.Projection(projection.getInfo().crs, modifiedTransform);\nvar reprojected = image.reproject({\n  crs: customProjection\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#performance-implications-of-projection-and-scale-choices","title":"Performance Implications of Projection and Scale Choices","text":"<p>Projection and scale choices significantly impact computational performance in GEE.</p>"},{"location":"gee/0.%20Supplementary/projection/#memory-usage-optimization","title":"Memory Usage Optimization","text":"<pre><code>// Memory-efficient approach for large-area analysis\nvar globalImage = ee.Image('MODIS/006/MOD13Q1/2019_01_01');\n\n// INEFFICIENT: Process at fine scale globally\nvar inefficient = globalImage.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: ee.Geometry.Rectangle([-180, -90, 180, 90]),\n  scale: 250,  // Fine scale globally requires massive computation\n  maxPixels: 1e13\n});\n\n// EFFICIENT: Two-step approach\n// 1. Process at coarse scale globally\nvar coarseResults = globalImage.reduceResolution({\n  reducer: ee.Reducer.mean(),\n  maxPixels: 1024\n}).reproject({\n  crs: 'EPSG:4326',\n  scale: 1000\n}).reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: ee.Geometry.Rectangle([-180, -90, 180, 90]),\n  scale: 1000,\n  maxPixels: 1e13\n});\n\n// 2. Process at fine scale only for areas of interest\nvar areasOfInterest = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Rectangle([30, -10, 40, 10])),  // East Africa\n  ee.Feature(ee.Geometry.Rectangle([-120, 30, -100, 50]))  // Western US\n]);\n\nvar detailedResults = areasOfInterest.map(function(region) {\n  return globalImage.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: region.geometry(),\n    scale: 250,  // Fine scale only where needed\n    maxPixels: 1e13\n  });\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/projection/#computation-time-optimization","title":"Computation Time Optimization","text":"<p>Strategic projection and scale choices can dramatically reduce computation time:</p> <ol> <li>Progressive Refinement: Start with coarse analyses and refine only in areas of interest</li> <li>Appropriate Scale Selection: Use the coarsest scale that still captures the phenomena of interest</li> <li>Projection Minimization: Avoid unnecessary reprojection operations</li> <li>Tiling Strategies: Break large areas into smaller tiles for parallel processing</li> </ol> <pre><code>// Tiling strategy for large-area analysis\nvar largeRegion = ee.Geometry.Rectangle([30, -10, 45, 10]);\n\n// Create a grid of tiles\nvar tiles = function(region, size) {\n  var bounds = region.bounds();\n  var coords = ee.List(bounds.coordinates().get(0));\n  var ll = ee.List(coords.get(0));\n  var ur = ee.List(coords.get(2));\n  var x0 = ee.Number(ll.get(0));\n  var y0 = ee.Number(ll.get(1));\n  var x1 = ee.Number(ur.get(0));\n  var y1 = ee.Number(ur.get(1));\n  var dx = x1.subtract(x0).divide(size);\n  var dy = y1.subtract(y0).divide(size);\n\n  var grid = ee.FeatureCollection(\n    ee.List.sequence(0, size - 1).map(function(i) {\n      return ee.List.sequence(0, size - 1).map(function(j) {\n        var x = x0.add(dx.multiply(i));\n        var y = y0.add(dy.multiply(j));\n        var rect = ee.Geometry.Rectangle([\n          x, y, x.add(dx), y.add(dy)\n        ]);\n        return ee.Feature(rect);\n      });\n    }).flatten()\n  );\n\n  return grid;\n};\n\n// Create a 4x4 grid of tiles\nvar grid = tiles(largeRegion, 4);\n\n// Process each tile in parallel\nvar results = grid.map(function(tile) {\n  return image.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: tile.geometry(),\n    scale: 30,\n    maxPixels: 1e13\n  });\n});\n</code></pre> <p>By mastering these advanced topics, you can tackle complex geospatial challenges in Google Earth Engine with greater accuracy and efficiency. The concepts presented here build upon the fundamental principles of projection and scale to address specialized analytical needs and optimize performance for demanding applications.</p>"},{"location":"gee/0.%20Supplementary/reprojection/","title":"Reprojection in Google Earth Engine (GEE)","text":"<p>In Google Earth Engine (GEE), reprojecting an image or dataset refers to transforming it into a new coordinate reference system (CRS) or adjusting the pixel resolution (scale) for consistency with other datasets or for analysis. If you do not reproject in Earth Engine when necessary, it can lead to various issues depending on the context of the analysis and the data you're working with.</p>"},{"location":"gee/0.%20Supplementary/reprojection/#potential-problems-of-not-reprojecting-in-earth-engine","title":"Potential Problems of Not Reprojecting in Earth Engine","text":""},{"location":"gee/0.%20Supplementary/reprojection/#1-inconsistent-coordinate-reference-systems-crs-problem","title":"1. Inconsistent Coordinate Reference Systems (CRS) Problem","text":"<p>Different datasets may use different CRSs (e.g., one dataset in EPSG:4326, another in EPSG:3857). If you don't reproject them into a common CRS, their alignment and spatial relationships can be incorrect.</p> <p>Example: If you overlay a Landsat image in EPSG:4326 (WGS84) with a Sentinel-2 image in EPSG:3857 (Web Mercator), they won't align correctly because their spatial references are different.</p> <p>Solution: Always reproject the data into a consistent CRS (typically EPSG:4326 or a projection that is suitable for your analysis).</p> <pre><code>var landsatImage = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');\nvar sentinelImage = ee.Image('COPERNICUS/S2/20190830T104031_20190830T104033_T31TFJ');\n\n// Reproject Sentinel-2 image to match Landsat CRS\nvar sentinelReprojected = sentinelImage.reproject(landsatImage.projection());\n\nMap.addLayer(landsatImage);\nMap.addLayer(sentinelReprojected);\n</code></pre>"},{"location":"gee/0.%20Supplementary/reprojection/#2-mismatched-pixel-resolutions-scale-problem","title":"2. Mismatched Pixel Resolutions (Scale) Problem","text":"<p>If two datasets have different pixel resolutions (e.g., one dataset has 30m pixels, and another has 10m pixels), operations such as image arithmetic or masking might yield unexpected or incorrect results.</p> <p>Example: A higher-resolution dataset (e.g., Sentinel-2 with 10m resolution) may get resampled when performing an operation with a lower-resolution dataset (e.g., Landsat with 30m resolution), leading to loss of detail or misalignment.</p> <p>Solution: Reproject both images to the same resolution before applying any operations.</p> <pre><code>var sentinelReprojected = sentinelImage.reproject({\n  crs: 'EPSG:4326', // CRS\n  scale: 30 // Define a common resolution (scale) for both images\n});\nvar landsatReprojected = landsatImage.reproject({\n  crs: 'EPSG:4326',\n  scale: 30\n});\n\nMap.addLayer(sentinelReprojected);\nMap.addLayer(landsatReprojected);\n</code></pre>"},{"location":"gee/0.%20Supplementary/reprojection/#3-incorrect-area-calculations-problem","title":"3. Incorrect <code>Area Calculations</code> Problem","text":"<p>If an image is not reprojected to the correct CRS, area calculations may not be accurate because the projection defines the scale at which geographic distances are measured. For example, in polar regions, an incorrect CRS will lead to distortion in the area measurements.</p> <p>Example: When calculating the area of a polygon using the area() function on a non-reprojected image, the computed area may be incorrect, especially if the image has an unusual projection.</p> <p>Solution: Reproject your image to a projection that preserves area (e.g., an equal-area projection like EPSG:3395 or EPSG:4326 if appropriate for your region).</p> <pre><code>var reprojectedImage = image.reproject({\n  crs: 'EPSG:3395', // Equal-area projection\n  scale: 1000 // Scale in meters for area calculations\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/reprojection/#4-distortion-of-shapes-or-features-problem","title":"4. Distortion of Shapes or Features Problem","text":"<p>Projections distort shapes, sizes, and distances differently, and not reprojecting may lead to visual or analytical distortion of your dataset. For example, shapes near the poles are heavily distorted in some projections (e.g., Mercator), while the equator is less affected.</p> <p>Example: If you are conducting analysis over large extents or near the poles, distortion might be significant if the projection is not suited for the region.</p> <p>Solution: Use appropriate projections for the region of interest. For example, use EPSG:3857 (Web Mercator) for web mapping or EPSG:4326 for general mapping tasks.</p> <pre><code>var reprojectedImage = image.reproject({\n  crs: 'EPSG:4326', // Common projection for world-scale mapping\n  scale: 30 // Use appropriate scale for the region\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/reprojection/#5-inaccurate-resampling-during-operations-problem","title":"5. Inaccurate Resampling During Operations Problem","text":"<p>If datasets with different projections or resolutions are involved in operations (e.g., image arithmetic, map algebra), Earth Engine will automatically resample the datasets to match each other. If no reprojecting is done beforehand, resampling could lead to inaccurate results, particularly for larger transformations.</p> <p>Example: If you are trying to perform an NDVI calculation across multiple datasets with different spatial resolutions or CRSs, without proper reprojection, the values may not represent the true spatial relationship between features.</p> <p>Solution: Reproject datasets before performing operations like normalizedDifference, reduceRegion, or clipping.</p> <pre><code>var reprojectedImage = image.reproject({\n  crs: 'EPSG:4326', // Choose an appropriate CRS\n  scale: 30 // Common resolution across datasets\n});\nvar ndvi = reprojectedImage.normalizedDifference(['B4', 'B5']);\n</code></pre>"},{"location":"gee/0.%20Supplementary/reprojection/#6-potential-for-computation-timed-out-or-memory-limit-exceeded-errors-problem","title":"6. Potential for \"Computation Timed Out\" or \"Memory Limit Exceeded\" Errors Problem","text":"<p>Not reprojecting to the appropriate scale or CRS can sometimes lead to excessively large data requests, especially when working with high-resolution or large-area datasets. This can trigger errors like \"Computation Timed Out\" or \"Memory Limit Exceeded\".</p> <p>Example: Attempting to analyze a large-area dataset at a very fine resolution without reprojection can result in inefficient processing and failure.</p> <p>Solution: Reproject datasets to a lower resolution (if acceptable for your analysis) to optimize memory usage and computation time.</p> <pre><code>var reprojectedImage = image.reproject({\n  crs: 'EPSG:4326',\n  scale: 5000 // Reproject to a lower resolution to avoid computation limits\n});\n</code></pre>"},{"location":"gee/0.%20Supplementary/reprojection/#conclusion","title":"Conclusion","text":"<p>In Earth Engine, reprojection is essential for ensuring that datasets align properly, operations work as expected, and the results are accurate. If you don't reproject:</p> <ul> <li>Datasets with different CRSs or scales may not align or may cause errors.</li> <li>Area, distance, and shape measurements may be distorted or incorrect.</li> <li>Image operations may lead to misleading results due to incorrect resampling. Always ensure that <code>your datasets have the same CRS and scale when performing spatial analysis or when combining multiple images</code>.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/0.%20Registration/","title":"Sign Up & Setup","text":"<p>\u26a0\ufe0fThe user name is unchangable once you given it cannot be cahanged even google will not do that, so choose carefully \u26a0\ufe0f</p>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/","title":"Google Earth Engine Code Editor Guide","text":"<p>The Google Earth Engine (GEE) Code Editor at code.earthengine.google.com is a powerful, web-based Integrated Development Environment (IDE) for the Earth Engine JavaScript API. It simplifies developing and managing complex geospatial workflows. Below is a detailed look at each component.</p>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#main-components-of-the-code-editor","title":"Main Components of the Code Editor","text":""},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#javascript-code-editor","title":"JavaScript Code Editor","text":"<ul> <li>Purpose: The primary workspace for writing and editing code.</li> <li>Features:</li> <li>Syntax highlighting and code formatting for easy readability.</li> <li>Autocomplete suggestions for Earth Engine functions.</li> <li>Syntax error checking with hints for common issues.</li> <li>Buttons for running scripts, saving, resetting the map/console, and generating unique shareable links.</li> <li>Note: The editor supports <code>ECMAScript 5 (ES5)</code> but doesn\u2019t support newer ES6+ features.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#map-display","title":"Map Display","text":"<ul> <li>Purpose: Interactive map for visualizing and exploring geospatial datasets.</li> <li>Features:</li> <li>Allows zooming, panning, and multiple background styles.</li> <li>Customize layer visibility and transparency using the Layer Manager.</li> <li>Supports overlaying multiple layers and adjusting their individual visualization settings.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#api-reference-docs-tab","title":"API Reference (Docs Tab)","text":"<ul> <li>Location: Left panel of the Code Editor.</li> <li>Purpose: Provides quick access to Earth Engine API documentation.</li> <li>Features:</li> <li>Searchable library of Earth Engine functions, classes, and methods.</li> <li>In-depth explanations and examples to support efficient coding.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#script-manager-scripts-tab","title":"Script Manager (Scripts Tab)","text":"<ul> <li>Purpose: Manages scripts and organizes them by access level.</li> <li>Folders:</li> <li>Owner: Private scripts you own.</li> <li>Writer: Scripts you have write access to.</li> <li>Reader: Scripts you have read-only access to.</li> <li>Examples: Example scripts provided by Google.</li> <li>Archive: Contains older, legacy scripts.</li> <li>Features:</li> <li>Organize scripts into folders, and rename, delete, or move scripts as needed.</li> <li>Version history to revert or compare script changes.</li> <li>Git integration, allowing scripts to be cloned, edited, or synchronized with external repositories like GitHub.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#asset-manager-assets-tab","title":"Asset Manager (Assets Tab)","text":"<ul> <li>Purpose: Manages user-uploaded assets for analysis, such as images or tables.</li> <li>Features:</li> <li>Upload custom data and organize it for easy access.</li> <li>Manage permissions for data sharing and usage in projects.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#tabs-and-panels-for-output-and-task-management","title":"Tabs and Panels for Output and Task Management","text":""},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#console-tab","title":"Console Tab","text":"<ul> <li>Purpose: Displays printed output, errors, and debugging information from scripts.</li> <li>Features:</li> <li>Expand and inspect printed objects directly.</li> <li>Interactive feedback when running complex code, allowing you to see results immediately.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#tasks-tab","title":"Tasks Tab","text":"<ul> <li>Purpose: Manages long-running data processing tasks (e.g., large exports and imports).</li> <li>Task Types:</li> <li>Export: For exporting data to Google Drive, Google Cloud Storage, etc.</li> <li>Import: For uploading files into Earth Engine (e.g., .csv, .tif).</li> <li>Features:</li> <li>Track progress of tasks, configure export options, and cancel tasks if necessary.</li> <li>Full-page view for managing tasks in detail.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#profiler","title":"Profiler","text":"<ul> <li>Purpose: Measures resources (CPU and memory) consumed by specific parts of a script.</li> <li>Features:</li> <li>Identifies areas where scripts may run slowly due to resource limitations.</li> <li>Activate by clicking Run with profiler or pressing <code>Alt + Run</code> (Mac: <code>Option + Run</code>).</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#tools-for-interactive-mapping-and-data-exploration","title":"Tools for Interactive Mapping and Data Exploration","text":""},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#inspector-tab","title":"Inspector Tab","text":"<ul> <li>Purpose: Allows interactive querying of the map to see values at specific points.</li> <li>Features:</li> <li>Displays geographic coordinates and attribute values of clicked points.</li> <li>Useful for verifying the values of data layers and geometries.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#layer-manager","title":"Layer Manager","text":"<ul> <li>Purpose: Adjusts the visibility and appearance of map layers.</li> <li>Features:</li> <li>Set layer transparency, color stretch, and other visualization parameters.</li> <li>Supports custom color palettes for specific layers.</li> <li>Note: Accessed from the upper right of the map display.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#search-tool","title":"Search Tool","text":"<ul> <li>Purpose: Quickly find datasets, locations, or saved scripts.</li> <li>Features:</li> <li>Search for datasets by keywords (e.g., dataset name, sensor).</li> <li>Click results to view dataset details and import options.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#geometry-drawing-tools","title":"Geometry Drawing Tools","text":"<ul> <li>Purpose: Create custom geometries directly on the map for analysis or visualization.</li> <li>Tools:</li> <li>Point: Place a single point.</li> <li>Line: Draw lines.</li> <li>Polygon: Create polygon shapes.</li> <li>Rectangle: Draw rectangular, planar shapes.</li> <li>Features:</li> <li>New geometries are imported as layers that can be locked to prevent further editing.</li> <li>Configure geometries as Features or FeatureCollections for flexible use.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#imports-section","title":"Imports Section","text":"<ul> <li>Purpose: Displays and manages datasets and geometries imported into the script.</li> <li>Features:</li> <li>Auto-generates JavaScript code for dataset imports.</li> <li>Organize and convert imports for reusability across scripts.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#script-sharing-and-link-generation","title":"Script Sharing and Link Generation","text":""},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#script-links-and-get-link-feature","title":"Script Links and \u201cGet Link\u201d Feature","text":"<ul> <li>Purpose: Allows sharing of scripts via URL links.</li> <li>Link Types:</li> <li>Snapshot Link: Encodes the exact state of the script, including code, layers, and map position.</li> <li>Saved Script Link: Always loads the most recent saved version of the script.</li> <li>Features:</li> <li>Manage links with options to prevent auto-execution, hide the code pane, and set parameters via URL fragments.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#script-link-management","title":"Script Link Management","text":"<ul> <li>Purpose: Access previously generated links.</li> <li>Features:</li> <li>Recall, remove, and download links.</li> <li>Enables sharing scripts in a controlled and documented way.</li> </ul>"},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#additional-help-and-support","title":"Additional Help and Support","text":""},{"location":"gee/1.%20Code%20Editor/1.%20User%20Interface%20of%20Code%20Editor/#help-button","title":"Help Button","text":"<ul> <li>Location: Top right of the Code Editor.</li> <li>Purpose: Accesses help resources, including:</li> <li>Documentation and Developer\u2019s Guide.</li> <li>Guided Code Editor tour and a list of keyboard shortcuts.</li> <li>Feedback submission for bug reports or feature requests.</li> </ul> <p>The Earth Engine Code Editor combines these tools to streamline your geospatial analysis and visualization tasks. Each component is designed to help you develop, test, and share geospatial workflows effectively, making Earth Engine a versatile and powerful tool for environmental data analysis.</p>"},{"location":"gee/1.%20Code%20Editor/2.%20Welcome%20to%20Programming%20World/","title":"Data Types and Structures in Programming","text":"<p>Some Fundamental Programming concepts\u2014<code>Name (string)</code>, <code>Number</code>, <code>List</code>, <code>Dictionary</code>, <code>Date</code>, and <code>Array</code></p> Data Type Example Usage in Landsat 8 Context Example String Image file name, Band name, metadata tags, satellite and band identifiers <code>\"LC08_L1TP_016037_20210819_20210827_01_T1.TIF\"</code>, <code>\"Landsat 8\"</code>, <code>\"Band 4\"</code> Number Pixel values, band numbers, geographic coordinates <code>3256</code> (pixel value), <code>4</code> (band number), <code>34.056</code> (latitude) List Group of file paths, band data, or pixel values in a region <code>[\"image1.TIF\", \"image2.TIF\", \"image3.TIF\"]</code>, <code>[band_1, band_2, ..., band_11]</code> Dictionary Metadata storage, band mappings, processing parameters <code>{\"sensor\": \"OLI/TIRS\", \"date\": \"2021-08-19\", \"cloud_cover\": 5.43}</code>, <code>{\"Band 4\": \"file_path_band4.TIF\"}</code> Array Pixel data storage for calculations across bands and image manipulation <code>array[bands, height, width]</code>, <code>[[235, 456, 678], [123, 456, 789], ...]</code> (2D pixel values) Date Acquisition date, time-series analysis, metadata records <code>\"2021-08-19\"</code> (acquisition date), <code>\"2020-01-01\" to \"2022-01-01\"</code> (time series)"},{"location":"gee/1.%20Code%20Editor/2.%20Welcome%20to%20Programming%20World/#1-name-string","title":"1. Name (String)","text":"<p>A string is simply a series of characters, like letters, numbers, and symbols, enclosed in quotes. It\u2019s typically used to represent text. In programming, anything within quotation marks (single or double) is considered a string.</p> <ul> <li>Example: <code>\"Hello, World!\"</code>, <code>\"1234\"</code>, <code>\"John Doe\"</code></li> </ul> <p>How it's used: Strings are used for storing and displaying text. For example, if you wanted to store someone's name, you'd use a string.</p>"},{"location":"gee/1.%20Code%20Editor/2.%20Welcome%20to%20Programming%20World/#2-number","title":"2. Number","text":"<p>A number in programming is just what it sounds like\u2014an integer, decimal, or other numerical value that can be used in calculations. </p> <ul> <li>Types of numbers:</li> <li>Integers: Whole numbers without a decimal point (e.g., <code>5</code>, <code>-10</code>, <code>42</code>).</li> <li>Floats: Numbers with decimal points (e.g., <code>3.14</code>, <code>0.99</code>, <code>-2.5</code>).</li> </ul> <p>How it's used: Numbers are used for counting, calculations, and anything requiring math. For instance, <code>5 + 10</code> would give <code>15</code>.</p>"},{"location":"gee/1.%20Code%20Editor/2.%20Welcome%20to%20Programming%20World/#3-list","title":"3. List","text":"<p>A list is an ordered collection of items. Think of it as a shopping list or to-do list; it contains multiple items in a specific order, and each item can be accessed by its position in the list. Lists are very flexible: they can contain different types of data (strings, numbers, even other lists).</p> <ul> <li>Example: <code>[\"apple\", \"banana\", \"cherry\"]</code> or <code>[1, 2, 3, 4]</code></li> </ul> <p>How it's used: Lists are used when you need to keep track of multiple items together. For example, a list can store a group of names or numbers.</p>"},{"location":"gee/1.%20Code%20Editor/2.%20Welcome%20to%20Programming%20World/#4-dictionary","title":"4. Dictionary","text":"<p>A dictionary is like a real-world dictionary where each word has a meaning. In programming, a dictionary stores key-value pairs. Each key is unique and is used to access its corresponding value.</p> <ul> <li>Example: <code>{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}</code></li> </ul> <p>How it's used: Dictionaries are used for storing data that\u2019s related in a meaningful way. For instance, you might store a person\u2019s details like name, age, and city in a dictionary, making it easy to find any detail by using the key (like <code>\"name\"</code> for the person's name).</p>"},{"location":"gee/1.%20Code%20Editor/2.%20Welcome%20to%20Programming%20World/#5-date","title":"5. Date","text":"<p>A date represents a specific day, often with time included. It\u2019s usually formatted in a standard way (like <code>YYYY-MM-DD</code> for Year, Month, Day). In programming, dates are often represented by special date objects, which make it easy to perform operations like adding days or checking the difference between dates.</p> <ul> <li>Example: <code>\"2023-01-01\"</code> (January 1, 2023)</li> </ul> <p>How it's used: Dates are used for anything that requires tracking or scheduling by time, like a calendar app or setting deadlines.</p>"},{"location":"gee/1.%20Code%20Editor/2.%20Welcome%20to%20Programming%20World/#6-array","title":"6. Array","text":"<p>A  array is a structured way of organizing data in rows and columns. In programming, an array is a collection of items, similar to a list, but usually limited to storing items of the same type. Arrays make it easy to store large amounts of similar data.</p> <ul> <li>Example of an array: <code>[[10, 20, 30, 40], [10, 20, 30, 40]]</code> </li> <li>Example of a table:</li> </ul> <p>How it's used: Arrays are great for mathematical operations, data processing, and performance-sensitive tasks. Tables are used in databases and spreadsheets to organize information clearly and logically.</p>"},{"location":"gee/1.%20Code%20Editor/2.%20Welcome%20to%20Programming%20World/#summary-table","title":"Summary Table","text":"Concept Description Example String Text data, enclosed in quotes <code>\"Hello, World!\"</code> Number Numerical value (integer or decimal) <code>42</code>, <code>3.14</code> List Ordered collection of items <code>[\"apple\", \"banana\", \"cherry\"]</code> Dictionary Key-value pairs for storing related data <code>{\"name\": \"John\", \"age\": 30}</code> Date Representation of a specific day/time <code>\"2023-01-01\"</code> Array Structured data in rows/columns or similar items in array <code>[[10, 20, 30, 40], [10, 20, 30, 40]]</code> <p>These are some basic data types and structures in programming that help organize and manipulate data in different ways.</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"gee/1.%20Code%20Editor/3.%20JavaScript%20vs%20Python/","title":"JavaScript vs Python: What's the Difference?","text":"<p>Google Earth Engine works with two languages: JavaScript and Python. They do the exact same things in GEE, but they look slightly different.</p>"},{"location":"gee/1.%20Code%20Editor/3.%20JavaScript%20vs%20Python/#quick-comparison","title":"Quick Comparison","text":"Feature JavaScript (Code Editor) Python (Jupyter/Colab) Variables <code>var image = ...</code> <code>image = ...</code> (No <code>var</code>) Functions <code>function myFunc(x) { ... }</code> <code>def my_func(x):</code> Comments <code>// This is a comment</code> <code># This is a comment</code> True/False <code>true</code>, <code>false</code> (lowercase) <code>True</code>, <code>False</code> (Capitalized) Null <code>null</code> <code>None</code> Dictionaries <code>{key: 'value'}</code> <code>{'key': 'value'}</code> (Quotes on keys) Install? No (Runs in browser) Yes (Requires setup)"},{"location":"gee/1.%20Code%20Editor/3.%20JavaScript%20vs%20Python/#code-examples","title":"Code Examples","text":"<p>Here is how common tasks look in both languages.</p>"},{"location":"gee/1.%20Code%20Editor/3.%20JavaScript%20vs%20Python/#1-loading-an-image","title":"1. Loading an Image","text":"JavaScriptPython <pre><code>// Load Landsat 8\nvar image = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318');\n\nprint('Image loaded:', image);\n</code></pre> <pre><code># Load Landsat 8\nimage = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318')\n\nprint('Image loaded:', image.getInfo()) # Note: .getInfo() needed to print\n</code></pre>"},{"location":"gee/1.%20Code%20Editor/3.%20JavaScript%20vs%20Python/#2-defining-visualization-parameters","title":"2. Defining Visualization Parameters","text":"<p>This is the biggest difference! Python requires quotes around keys in dictionaries.</p> JavaScriptPython <pre><code>var visParams = {\n  bands: ['SR_B4', 'SR_B3', 'SR_B2'],\n  min: 7000,\n  max: 12000,\n  palette: ['blue', 'green', 'red']\n};\n\nMap.addLayer(image, visParams, 'My Image');\n</code></pre> <pre><code>vis_params = {\n    'bands': ['SR_B4', 'SR_B3', 'SR_B2'],\n    'min': 7000,\n    'max': 12000,\n    'palette': ['blue', 'green', 'red']\n}\n\nMap.addLayer(image, vis_params, 'My Image')\n</code></pre>"},{"location":"gee/1.%20Code%20Editor/3.%20JavaScript%20vs%20Python/#3-writing-a-function","title":"3. Writing a Function","text":"JavaScriptPython <pre><code>// A function to mask clouds\nvar maskClouds = function(image) {\n  var qa = image.select('QA_PIXEL');\n  // ... logic here ...\n  return image.updateMask(qa);\n};\n\n// Apply it using .map()\nvar cleanCollection = collection.map(maskClouds);\n</code></pre> <pre><code># A function to mask clouds\ndef mask_clouds(image):\n  qa = image.select('QA_PIXEL')\n  # ... logic here ...\n  return image.updateMask(qa)\n\n# Apply it using .map()\nclean_collection = collection.map(mask_clouds)\n</code></pre>"},{"location":"gee/1.%20Code%20Editor/3.%20JavaScript%20vs%20Python/#which-one-should-i-use","title":"Which one should I use?","text":"<ul> <li>Choose JavaScript if: You are a beginner. It runs instantly in the browser and is easiest to learn.</li> <li>Choose Python if: You are a data scientist, want to use other libraries (like pandas/matplotlib), or want to automate workflows.</li> </ul>"},{"location":"gee/2.%20Data%20Catalogs/1.%20Earth%20Engine%20Data%20Catalog/","title":"1. Earth Engine Data Catalog","text":""},{"location":"gee/2.%20Data%20Catalogs/1.%20Earth%20Engine%20Data%20Catalog/#usgs-landsat-8-level-2-collection-2-tier-1","title":"USGS Landsat 8 Level 2, Collection 2, Tier 1","text":"<p>This is the title of the dataset. It tells us that we are dealing with data from the Landsat 8 satellite, which is at Level 2 (meaning it has undergone some processing like radiometric calibration and atmospheric correction), Collection 2 (the latest collection of Landsat data), and Tier 1 (the standard processing level).</p>"},{"location":"gee/2.%20Data%20Catalogs/1.%20Earth%20Engine%20Data%20Catalog/#dataset-availability","title":"Dataset Availability","text":"<p>This section provides the time range for which the data is available: 2013-03-18T15:58:14Z to 2024-10-26T12:58:36Z. This means that the dataset contains images captured by Landsat 8 between these two dates.</p>"},{"location":"gee/2.%20Data%20Catalogs/1.%20Earth%20Engine%20Data%20Catalog/#dataset-provider","title":"Dataset Provider","text":"<p>This section indicates that the United States Geological Survey (USGS) is the provider of this dataset. The USGS is responsible for collecting and processing the Landsat data.</p>"},{"location":"gee/2.%20Data%20Catalogs/1.%20Earth%20Engine%20Data%20Catalog/#id-of-the-dataset","title":"ID of the Dataset","text":"<p>This snippet provides the code to access this dataset within Google Earth Engine (GEE). The code is <code>ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\")</code>. This code allows you to load the Landsat 8 Collection 2 Level 2 Tier 1 image collection into GEE for further analysis and visualization.</p>"},{"location":"gee/2.%20Data%20Catalogs/1.%20Earth%20Engine%20Data%20Catalog/#tags","title":"Tags","text":"<p>The tags section <code>lists keywords</code> associated with the dataset. Some of the relevant tags here are:</p> <p>cfmask, cloud, fmask: These tags indicate that the dataset includes information about cloud cover and cloud masks. global: This tag suggests that the dataset has global coverage. 18sr, landsat, lasrc, lc08, lst, reflectance, sr, usgs: These tags are related to the Landsat 8 satellite, its spectral bands, and the type of data (reflectance, surface temperature).</p> <p></p>"},{"location":"gee/2.%20Data%20Catalogs/1.%20Earth%20Engine%20Data%20Catalog/#description","title":"Description","text":"<p>This section likely provides a brief overview of the dataset, such as its purpose, source, or any relevant background information.</p>"},{"location":"gee/2.%20Data%20Catalogs/1.%20Earth%20Engine%20Data%20Catalog/#bands","title":"Bands","text":"<p>This section details the spectral bands that are included in the dataset. Each band captures information about a specific wavelength range of light. The table under \"Bands\" likely provides details about each band, including:</p> <ul> <li>Name: The name or identifier of the band.</li> <li>Units: The units of measurement for the data in that band (e.g., radiance, reflectance).</li> <li>Min/Max: The minimum and maximum possible values for the data in that band.</li> <li><code>Scale: The scaling factor applied to the raw data values.</code></li> <li><code>Offset: The offset added to the scaled data values.</code></li> <li>Wavelength: The central wavelength of the band in nanometers.</li> <li>Description: A description of the band and what it measures.</li> </ul>"},{"location":"gee/2.%20Data%20Catalogs/1.%20Earth%20Engine%20Data%20Catalog/#resolution","title":"Resolution","text":"<p>This section indicates the spatial resolution of the dataset, which is 30 meters in this case. This means that each pixel in the image represents a 30-meter by 30-meter area on the ground.</p>"},{"location":"gee/2.%20Data%20Catalogs/1.%20Earth%20Engine%20Data%20Catalog/#image-properties","title":"Image Properties","text":"<p>This section likely provides information about the overall characteristics of the images in the dataset. This might include details like the image size, projection, coordinate system, or any other relevant image properties.</p>"},{"location":"gee/2.%20Data%20Catalogs/1.%20Earth%20Engine%20Data%20Catalog/#terms-of-use","title":"Terms of Use","text":"<p>This section specifies the terms and conditions under which you can use the dataset. It might include information about licensing, attribution requirements, or any restrictions on how the data can be used. Overall, this image appears to be a metadata summary for a remote sensing dataset, likely from a satellite or drone. It provides essential information about the dataset's content, characteristics, and how it can be used.</p> <p></p> <ul> <li>https://developers.google.com/earth-engine/datasets/catalog/IDAHO_EPSCOR_TERRACLIMATE</li> <li>https://developers.google.com/earth-engine/datasets/catalog/ESA_WorldCover_v100</li> <li>https://developers.google.com/earth-engine/datasets/catalog/GOOGLE_DYNAMICWORLD_V1</li> <li>https://developers.google.com/earth-engine/datasets/catalog/UMD_hansen_global_forest_change_2023_v1_11</li> <li>https://developers.google.com/earth-engine/datasets/catalog/NASA_GDDP-CMIP6</li> </ul>"},{"location":"gee/3.%20Data%20Types/1.%20Variables/","title":"1. Variables","text":"<p>```javascript // Numerical Variable var num = ee.Number(10); print('Numeric:', num);  // Prints 10 </p> <p>// String Variable var str = ee.String('Hello, world!'); print('String:', str);  // Prints 'Hello, world!'</p> <p>// List (Array) Variable var list = ee.List([1, 2, 3, 4, 5]); print('List:', list);  // Prints [1, 2, 3, 4, 5]</p> <p>// Dictionary (Object) Variable var dict = ee.Dictionary({name: 'John', age: 30, city: 'New York'}); print('Dictionary:', dict);  // Prints {name: 'John', age: 30, city: 'New York'}</p> <p>// Date Variable var date = ee.Date('2022-01-01'); print('Date:', date);  // Prints '2022-01-01'</p> <p>// Array Variable var array = ee.Array([[1, 2, 3], [4, 5, 6]]); print('Array:', array);</p>"},{"location":"gee/3.%20Data%20Types/2.%20Numbers/","title":"2. Numbers","text":"<p>```javascript // Numeric Variable var num = ee.Number(10); print('Numeric:', num);  // Prints 10</p> <p>// Mathematical Operators  var a = ee.Number(5); var b = ee.Number(2); print('Add:', a.add(b));  // Prints 7 print('Subtract:', a.subtract(b));  // Prints 3 print('Multiply:', a.multiply(b));  // Prints 10 print('Divide:', a.divide(b));  // Prints 2.5</p> <p>// String Variable var str = ee.String('Hello, world!'); print('String:', str);  // Prints 'Hello, world!'</p> <p>// Boolean Variable var bool = true; print('Boolean:', bool);  // Prints true</p> <p>// List (Array) var list = ee.List([1, 2, 3, 4, 5]); print('List:', list);  // Prints [1, 2, 3, 4, 5]</p> <p>// Dictionary (Object) var dict = ee.Dictionary({name: 'John', age: 30, city: 'New York'}); print('Dictionary:', dict);  // Prints {name: 'John', age: 30, city: 'New York'}</p>"},{"location":"gee/3.%20Data%20Types/3.%20Math/","title":"3. Math","text":"<p>```javascript // Constants PI and E var pi = ee.Number(Math.PI); print('PI:', pi); var e = ee.Number(Math.E); print('E:', e);</p> <p>// Rounding numbers (ceil, trunc, round)  var x = ee.Number(10.3); var ceilValue = x.ceil();  // 11 print('Ceil:', ceilValue); var truncValue = x.floor();  // 10 print('Trunc:', truncValue); var roundValue = x.round();  // 10 print('Round:', roundValue);</p> <p>// Exponent var expValue = e.exp();  // Approximately 7.38905609893064957217 print('Exp:', expValue);</p> <p>// Logarithm var logValue = x.log();  // Approximately 2.302585092994046 print('Log:', logValue);</p> <p>// Power var y = ee.Number(3); var powValue = x.pow(y);  // 8 print('Pow:', powValue);</p> <p>// Square root var sqrtValue = x.sqrt();  // Approximately 3.20854454116696 print('Sqrt:', sqrtValue);</p> <p>// Absolute value var absValue = x.abs();  // 10.3 print('Abs:', absValue);</p> <p>// Copy sign is not directly available in GEE. However, you can create a custom function for it.</p> <p>// Trigonometric functions var angleInRadians = ee.Number(Math.PI / 4); //45 degrees in radians var sinValue = angleInRadians.sin(); print('Sin:', sinValue); var cosValue = angleInRadians.cos(); print('Cos:', cosValue); var tanValue = angleInRadians.tan(); print('Tan:', tanValue);</p>"},{"location":"gee/3.%20Data%20Types/4.%20Geometry/","title":"4. Geometry","text":"<p>```javascript // Geometry Data Types  var point = ee.Geometry.Point([0, 0]); print('Point:', point); var lineString = ee.Geometry.LineString([[0, 0], [1, 1]]); print('LineString:', lineString); var polygon = ee.Geometry.Polygon([[[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]]); print('Polygon:', polygon);</p> <p>// Feature Data Type var feature = ee.Feature(point, {name: 'My Point'}); print('Feature:', feature);</p> <p>// FeatureCollection Data Type var featureCollection = ee.FeatureCollection([feature]); print('FeatureCollection:', featureCollection);</p> <p>// Selecting an Image from an ImageCollection var imageCollection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA'); var image = imageCollection.filterDate('2018-01-01', '2018-12-31').first(); print('Image:', image);</p> <p>// Creating Constant Image var constantImage = ee.Image.constant(1); print('Constant Image:', constantImage);</p>"},{"location":"gee/3.%20Data%20Types/5.%20Functions%20Theory/","title":"5. Functions Theory","text":""},{"location":"gee/3.%20Data%20Types/5.%20Functions/","title":"5. Functions","text":"<p>```javascript // Simple Function function greet() {     print('Hello, world!'); } greet();  // Calls the function </p> <p>// Sum Function function sum(a, b) {     return a + b; } print('Sum:', sum(5, 3));  // Prints 8</p> <p>// Index Function function getIndex(array, element) {     return array.indexOf(element); } print('Index:', getIndex([1, 2, 3, 4, 5], 3));  // Prints 2</p> <p>// Average Function function average(array) {     var sum = array.reduce(function(a, b) { return a + b; }, 0);     return sum / array.length; } print('Average:', average([1, 2, 3, 4, 5]));  // Prints 3</p> <p>// Square Function function square(x) {     return x * x; } print('Square:', square(5));  // Prints 25</p>"},{"location":"gee/3.%20Data%20Types/6.%20Else%20If/","title":"6. Else If","text":"<p>```javascript // Define variables var x = ee.Number(10); var y = ee.Number(10); var z = ee.Number(10);</p> <p>// If condition for 'x &gt; 5' var resultX = ee.Algorithms.If(x.gt(5), 'x is greater than 5', 'x is not greater than 5'); print(resultX);  // Output will be based on the condition</p> <p>// Else if equivalent for 'y &gt; 15' or 'y &gt; 5' var resultY = ee.Algorithms.If(     y.gt(15),      'y is greater than 15',      ee.Algorithms.If(y.gt(5), 'y is greater than 5', 'y is 5 or less') ); print(resultY);  // Output will depend on the conditions</p> <p>// Else equivalent for 'z &gt; 15' or 'else' var resultZ = ee.Algorithms.If(     z.gt(15),      'z is greater than 15',      'z is not greater than 15' ); print(resultZ);  // Output will depend on the condition</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/","title":"Working with Satellite Images (Raster Data)","text":"<p>In Google Earth Engine, satellite images are called Raster Data. Think of them as digital photos of the Earth.</p> <p>Each pixel in these photos contains information, not just about color (Red, Green, Blue), but also about things our eyes can't see, like temperature or plant health.</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/#popular-datasets-explained","title":"Popular Datasets Explained","text":"<p>Here are the most common \"cameras\" (satellites) you'll use:</p> Satellite Best For... Detail Level How Often? Sentinel-2 Agriculture, vegetation, detail High (10m) Every 5 days Landsat 8 &amp; 9 Long-term changes (since 2013) Medium (30m) Every 16 days MODIS Daily monitoring, climate, fire Low (250m-1km) Daily Sentinel-1 Floods, landslides (Radar) Medium (10m) Every 6-12 days"},{"location":"gee/5.%20Working%20with%20Raster%20Data/#the-raster-workflow","title":"The Raster Workflow","text":"<pre><code>graph LR\n    A[Catalog] -- Search --&gt; B[ImageCollection]\n    B -- filter --&gt; C[Filtered Collection]\n    C -- composite/reduce --&gt; D[Single Image]\n    D -- process --&gt; E[Analysis Result]\n    E -- Map --&gt; F[Visualization]\n    style D fill:#f96,stroke:#333,stroke-width:2px</code></pre>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/#how-to-load-a-dataset","title":"How to Load a Dataset","text":"<p>To use these images, you need to \"call\" them from the catalog.</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/#1-loading-landsat-8","title":"1. Loading Landsat 8","text":"<p>Great for looking at land changes over time.</p> JavaScriptPython <pre><code>// Load the Landsat 8 collection\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n  .filterDate('2023-01-01', '2023-12-31')\n  .filterBounds(ee.Geometry.Point([-122.4, 37.8])); // San Francisco\n\nprint('Number of images:', landsat.size());\n</code></pre> <pre><code># Load the Landsat 8 collection\nlandsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \\\n    .filterDate('2023-01-01', '2023-12-31') \\\n    .filterBounds(ee.Geometry.Point([-122.4, 37.8])) # San Francisco\n\nprint('Number of images:', landsat.size().getInfo())\n</code></pre>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/#2-loading-sentinel-2","title":"2. Loading Sentinel-2","text":"<p>Best for sharp, detailed images of cities or fields.</p> JavaScriptPython <pre><code>// Load Sentinel-2\nvar sentinel2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')\n  .filterDate('2023-06-01', '2023-06-30')\n  .filterBounds(ee.Geometry.Point([-0.12, 51.50])); // London\n\n// Sort by cloud cover to get the clearest image\nvar clearImage = sentinel2.sort('CLOUDY_PIXEL_PERCENTAGE').first();\n\n// Display it\nMap.centerObject(clearImage, 11);\nMap.addLayer(clearImage, {min: 0, max: 3000, bands: ['B4', 'B3', 'B2']}, 'Sentinel-2 RGB');\n</code></pre> <pre><code># Load Sentinel-2\nsentinel2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') \\\n    .filterDate('2023-06-01', '2023-06-30') \\\n    .filterBounds(ee.Geometry.Point([-0.12, 51.50])) # London\n\n# Sort by cloud cover to get the clearest image\nclear_image = sentinel2.sort('CLOUDY_PIXEL_PERCENTAGE').first()\n\n# Display it (using geemap)\nMap = geemap.Map()\nMap.centerObject(clear_image, 11)\nMap.addLayer(clear_image, {'min': 0, 'max': 3000, 'bands': ['B4', 'B3', 'B2']}, 'Sentinel-2 RGB')\nMap\n</code></pre>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/#3-loading-climate-data-era5","title":"3. Loading Climate Data (ERA5)","text":"<p>Want to know the temperature or rainfall? Use ERA5.</p> JavaScriptPython <pre><code>// Load ERA5 Monthly data\nvar climate = ee.ImageCollection('ECMWF/ERA5_LAND/MONTHLY_AGGR')\n  .filterDate('2023-01-01', '2023-12-31');\n\n// Select temperature (in Kelvin)\nvar temp = climate.select('temperature_2m');\n\n// Convert to Celsius and get average\nvar tempC = temp.mean().subtract(273.15);\n\nMap.addLayer(tempC, {min: -10, max: 35, palette: ['blue', 'white', 'red']}, 'Avg Temp (C)');\n</code></pre> <pre><code># Load ERA5 Monthly data\nclimate = ee.ImageCollection('ECMWF/ERA5_LAND/MONTHLY_AGGR') \\\n    .filterDate('2023-01-01', '2023-12-31')\n\n# Select temperature (in Kelvin)\ntemp = climate.select('temperature_2m')\n\n# Convert to Celsius and get average\ntemp_c = temp.mean().subtract(273.15)\n\nMap = geemap.Map()\nMap.addLayer(temp_c, {'min': -10, 'max': 35, 'palette': ['blue', 'white', 'red']}, 'Avg Temp (C)')\nMap\n</code></pre>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/#what-next","title":"What Next?","text":"<p>Now that you know how to load these \"raster\" images, learn how to analyze them!</p> <ul> <li>Single Band Images - Working with just one layer (like temperature)</li> <li>Multi Band Images - Combining layers (like Red+Green+Blue)</li> <li>Calculating Indices - Formulas like NDVI for plants</li> </ul>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/1.%20Single%20Band%20Images/","title":"Working with Single Band Images","text":"<p>A Single Band Image is like a grayscale photo where each pixel holds one value. Instead of colors (Red/Green/Blue), it might hold:</p> <ul> <li>Elevation (Height above sea level)</li> <li>Temperature (How hot it is)</li> <li>Rainfall (How much it rained)</li> </ul>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/1.%20Single%20Band%20Images/#example-1-elevation-data-srtm","title":"Example 1: Elevation Data (SRTM)","text":"<p>We will use the SRTM dataset, which gives the height of the land for the entire world.</p> JavaScriptPython <pre><code>// Load the SRTM Elevation data\nvar srtm = ee.Image(\"CGIAR/SRTM90_V4\");\n\n// Center the map on a mountainous area (Himalayas)\nMap.setCenter(86.92, 27.98, 8);\n\n// Add the layer with visualization parameters\n// min: 0 meters (sea level), max: 6000 meters (high peaks)\nMap.addLayer(srtm, {min: 0, max: 6000}, 'Elevation');\n</code></pre> <pre><code>import ee\nimport geemap\n\n# Initialize\nee.Initialize()\n\n# Load the SRTM Elevation data\nsrtm = ee.Image(\"CGIAR/SRTM90_V4\")\n\n# Create a map\nMap = geemap.Map()\n\n# Center the map on a mountainous area (Himalayas)\nMap.setCenter(86.92, 27.98, 8)\n\n# Add the layer with visualization parameters\nMap.addLayer(srtm, {'min': 0, 'max': 6000}, 'Elevation')\nMap\n</code></pre> <p>What is happening?</p> <ul> <li>Darker pixels = Lower elevation</li> <li>Brighter pixels = Higher elevation</li> </ul>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/1.%20Single%20Band%20Images/#example-2-rainfall-data-chirps","title":"Example 2: Rainfall Data (CHIRPS)","text":"<p>The CHIRPS dataset tracks rainfall daily. Let's look at total rainfall for a year.</p> JavaScriptPython <pre><code>// Load rainfall data for 2023\nvar rainfall = ee.ImageCollection(\"UCSB-CHG/CHIRPS/DAILY\")\n  .filterDate('2023-01-01', '2023-12-31')\n  .sum(); // Add up all daily rain to get yearly total\n\n// Visualization: Blue = High rainfall, White = Low rainfall\nvar rainVis = {\n  min: 0,\n  max: 2000,\n  palette: ['white', 'blue', 'darkblue']\n};\n\nMap.setCenter(78.9, 20.5, 5); // India\nMap.addLayer(rainfall, rainVis, 'Total Rainfall 2023');\n</code></pre> <pre><code># Load rainfall data for 2023\nrainfall = ee.ImageCollection(\"UCSB-CHG/CHIRPS/DAILY\") \\\n  .filterDate('2023-01-01', '2023-12-31') \\\n  .sum() # Add up all daily rain to get yearly total\n\n# Visualization: Blue = High rainfall, White = Low rainfall\nrain_vis = {\n  'min': 0,\n  'max': 2000,\n  'palette': ['white', 'blue', 'darkblue']\n}\n\nMap.setCenter(78.9, 20.5, 5) # India\nMap.addLayer(rainfall, rain_vis, 'Total Rainfall 2023')\nMap\n</code></pre>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/2.%20Multi%20Band%20Images/","title":"Working with Multi-Band Images","text":"<p>Most satellite images are Multi-Band, meaning they capture different types of light separately.</p> <p>Think of it like a camera that takes 10 photos at once:</p> <ul> <li>Red light (Band 4)</li> <li>Green light (Band 3)</li> <li>Blue light (Band 2)</li> <li>Infrared light (data our eyes can't see!)</li> </ul> <p>By combining these bands, we can see the world in different ways.</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/2.%20Multi%20Band%20Images/#1-true-color-what-we-see","title":"1. True Color (What we see)","text":"<p>To see the Earth as our eyes do, we combine Red, Green, and Blue bands.</p> JavaScriptPython <pre><code>// Load a Landsat 8 image\nvar image = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318');\n\n// Combine Bands 4 (Red), 3 (Green), 2 (Blue)\nvar trueColor = {\n  bands: ['SR_B4', 'SR_B3', 'SR_B2'],\n  min: 7000,\n  max: 12000\n};\n\nMap.centerObject(image, 9);\nMap.addLayer(image, trueColor, 'True Color');\n</code></pre> <pre><code># Load a Landsat 8 image\nimage = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318')\n\n# Combine Bands 4 (Red), 3 (Green), 2 (Blue)\ntrue_color = {\n    'bands': ['SR_B4', 'SR_B3', 'SR_B2'],\n    'min': 7000,\n    'max': 12000\n}\n\nMap = geemap.Map()\nMap.centerObject(image, 9)\nMap.addLayer(image, true_color, 'True Color')\nMap\n</code></pre>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/2.%20Multi%20Band%20Images/#2-false-color-plant-health","title":"2. False Color (Plant Health)","text":"<p>Plants heavily reflect Infrared light, which humans can't see. By shifting the bands, we can make plants pop out in Bright Red.</p> <ul> <li>Near Infrared (Band 5) -&gt; Display as Red</li> <li>Red (Band 4) -&gt; Display as Green</li> <li>Green (Band 3) -&gt; Display as Blue</li> </ul> JavaScriptPython <pre><code>// Combine Bands 5 (NIR), 4 (Red), 3 (Green)\nvar falseColor = {\n  bands: ['SR_B5', 'SR_B4', 'SR_B3'],\n  min: 7000,\n  max: 12000\n};\n\nMap.addLayer(image, falseColor, 'False Color (Vegetation)');\n</code></pre> <pre><code># Combine Bands 5 (NIR), 4 (Red), 3 (Green)\nfalse_color = {\n    'bands': ['SR_B5', 'SR_B4', 'SR_B3'],\n    'min': 7000,\n    'max': 12000\n}\n\nMap.addLayer(image, false_color, 'False Color (Vegetation)')\n</code></pre> <p>What does it mean?</p> <ul> <li>Bright Red = Healthy, dense vegetation</li> <li>Dark Red = Sparse vegetation</li> <li>Cyan/Blue = Cities, bare soil, or water</li> </ul>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/2.%20Multi%20Band%20Images/#why-use-infrared","title":"Why use infrared?","text":"<p>Infrared helps distinguish between real plants and green objects (like fake turf or green paint). Only real plants glow brightly in infrared!</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/3.%20Calculating%20Indices/","title":"Calculating Indices (Like NDVI)","text":"<p>Satellite images contain hidden information. By doing math on the different bands (colors), we can uncover things like plant health or water content.</p> <p>The most famous index is NDVI (Normalized Difference Vegetation Index).</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/3.%20Calculating%20Indices/#what-is-ndvi","title":"What is NDVI?","text":"<p>Plants absorb Red light (for photosynthesis) and reflect Infrared light. Dead plants or soil reflect both equally.</p> <p>Formula: $$ NDVI = \\frac{(NIR - Red)}{(NIR + Red)} $$</p> <p>Don't worry about the math - Earth Engine does it for you!</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/3.%20Calculating%20Indices/#calculating-ndvi-in-earth-engine","title":"Calculating NDVI in Earth Engine","text":"<p>Let's calculate NDVI for a Landsat 8 image.</p> JavaScriptPython <pre><code>// Load a Landsat 8 image\nvar image = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318');\n\n// Method 1: Using the formula directly (harder)\nvar ndvi = image.expression(\n  '(NIR - RED) / (NIR + RED)', {\n    'NIR': image.select('SR_B5'),\n    'RED': image.select('SR_B4')\n  });\n\n// Method 2: Using the built-in function (easier!)\nvar easyNDVI = image.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI');\n\n// Visualization: Blue (Water) -&gt; White (Bare) -&gt; Green (Healthy Plants)\nvar ndviVis = {min: -1, max: 1, palette: ['blue', 'white', 'green']};\n\nMap.centerObject(image, 9);\nMap.addLayer(easyNDVI, ndviVis, 'NDVI');\n</code></pre> <pre><code># Load a Landsat 8 image\nimage = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_044034_20140318')\n\n# Method 2: Using the built-in function (easier!)\n# We select bands 5 (NIR) and 4 (Red)\neasy_ndvi = image.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI')\n\n# Visualization: Blue (Water) -&gt; White (Bare) -&gt; Green (Healthy Plants)\nndvi_vis = {'min': -1, 'max': 1, 'palette': ['blue', 'white', 'green']}\n\nMap = geemap.Map()\nMap.centerObject(image, 9)\nMap.addLayer(easy_ndvi, ndvi_vis, 'NDVI')\nMap\n</code></pre>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/3.%20Calculating%20Indices/#interpreting-the-result","title":"Interpreting the Result","text":"<ul> <li>Values close to +1 (Dark Green): Dense, healthy forest.</li> <li>Values around 0.2 - 0.5 (Light Green): Grass or sparse vegetation.</li> <li>Values near 0 (White/Brown): Urban areas, bare soil, rock.</li> <li>Negative Values (Blue): Water bodies.</li> </ul>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/3.%20Calculating%20Indices/#other-common-indices","title":"Other Common Indices","text":"Index Name Formula Use Case NDWI Normalized Difference Water Index (Green - NIR) / (Green + NIR) Detecting water bodies NBR Normalized Burn Ratio (NIR - SWIR) / (NIR + SWIR) Detecting burnt areas after fire EVI Enhanced Vegetation Index Complex Formula Better vegetation monitoring in dense forests <p>You can calculate any of these using <code>.normalizedDifference()</code> or <code>.expression()</code>!</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/4.%20Time%20Series%20Analysis/","title":"Time Series Analysis (Changes Over Time)","text":"<p>Satellite data is powerful because we have images going back decades. By analyzing a \"stack\" of images, we can see how a place changes.</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/4.%20Time%20Series%20Analysis/#the-map-function","title":"The <code>map()</code> Function","text":"<p>To process many images at once (like calculating NDVI for every image in a year), we use <code>.map()</code>. Think of it as an assembly line: you define a set of instructions, and Earth Engine applies them to every image in the collection automatically.</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/4.%20Time%20Series%20Analysis/#example-charting-vegetation-health-over-a-year","title":"Example: Charting Vegetation Health Over a Year","text":"<p>Let's calculate NDVI for every Landsat 8 image in 2023 and plot it on a chart.</p> JavaScriptPython <pre><code>// Define a location (e.g., a forest or farm)\nvar roi = ee.Geometry.Point([-122.4, 37.8]); // San Francisco\n\n// Load Landsat 8 for 1 year\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n  .filterDate('2023-01-01', '2023-12-31')\n  .filterBounds(roi);\n\n// Define a function to calculate NDVI\nvar addNDVI = function(image) {\n  var ndvi = image.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI');\n  return image.addBands(ndvi); // Add NDVI as a new band\n};\n\n// Apply the function to every image in the collection!\nvar withNDVI = collection.map(addNDVI);\n\n// Create a chart\nprint(ui.Chart.image.series({\n  imageCollection: withNDVI.select('NDVI'),\n  region: roi,\n  reducer: ee.Reducer.mean(),\n  scale: 30\n}).setOptions({\n  title: 'NDVI Over Time (2023)',\n  vAxis: {title: 'NDVI'},\n  hAxis: {title: 'Date'}\n}));\n</code></pre> <pre><code># Define a location\nroi = ee.Geometry.Point([-122.4, 37.8]) # San Francisco\n\n# Load Landsat 8 for 1 year\ncollection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \\\n  .filterDate('2023-01-01', '2023-12-31') \\\n  .filterBounds(roi)\n\n# Define a function to calculate NDVI\ndef add_ndvi(image):\n  ndvi = image.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI')\n  return image.addBands(ndvi)\n\n# Apply the function to every image\nwith_ndvi = collection.map(add_ndvi)\n\n# Create a chart using geemap (requires installation)\nimport geemap.chart as chart\n\nchart.feature_byFeature(\n    with_ndvi,\n    roi,\n    'NDVI',\n    title='NDVI Over Time (2023)',\n    x_label='Date',\n    y_label='NDVI'\n)\n# Alternatively, you can use matplotlib for Python!\n</code></pre>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/4.%20Time%20Series%20Analysis/#moving-forward","title":"Moving Forward","text":"<p>This technique is fundamental to remote sensing. You can use it to:</p> <ul> <li>Monitor crop growth during a season</li> <li>Track deforestation over 20 years</li> <li>Watch lakes shrink or expand</li> </ul> <p>Next, let's learn how to export your results.</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/5.%20Exporting%20Data/","title":"Exporting Your Data","text":"<p>Once you've analyzed an image or made a map, you probably want to save it! You can export results to Google Drive, Google Cloud Storage, or as an Earth Engine Asset.</p>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/5.%20Exporting%20Data/#1-exporting-an-image-geotiff","title":"1. Exporting an Image (GeoTIFF)","text":"<p>To download a map (like an NDVI image) to your Google Drive:</p> JavaScriptPython <p><pre><code>// Select the image you want to export (e.g., NDVI)\nvar imageToExport = easyNDVI;\n\n// Define the export parameters\nExport.image.toDrive({\n  image: imageToExport,\n  description: 'NDVI_Export_2023',\n  scale: 30, // Resolution in meters (30m for Landsat)\n  region: roi, // The area to export\n  fileFormat: 'GeoTIFF'\n});\n</code></pre> A new task will appear in the \"Tasks\" tab on the right. Click \"Run\" to start the download!</p> <pre><code>import geemap\n\n# Export using geemap (simplest way)\ngeemap.ee_export_image_to_drive(\n    easy_ndvi, \n    description='NDVI_Export_2023', \n    folder='GEE_Exports', \n    scale=30, \n    region=roi\n)\n</code></pre>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/5.%20Exporting%20Data/#2-exporting-a-table-csv","title":"2. Exporting a Table (CSV)","text":"<p>To save statistics (like average rainfall per district) to a spreadsheet:</p> JavaScriptPython <pre><code>// Calculate mean rainfall for a region\nvar stats = rainfall.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: roi,\n  scale: 5000\n});\n\n// Create a feature with the stats\nvar feature = ee.Feature(null, stats);\nvar collection = ee.FeatureCollection([feature]);\n\n// Export to CSV\nExport.table.toDrive({\n  collection: collection,\n  description: 'Rainfall_Stats_2023',\n  fileFormat: 'CSV'\n});\n</code></pre> <pre><code># Calculate stats\nstats = rainfall.reduceRegion(\n  reducer=ee.Reducer.mean(),\n  geometry=roi,\n  scale=5000\n)\n\n# Create a feature collection\nfeature = ee.Feature(None, stats)\ncollection = ee.FeatureCollection([feature])\n\n# Export using geemap\ngeemap.ee_export_vector_to_drive(\n    collection, \n    description='Rainfall_Stats_2023', \n    fileFormat='CSV'\n)\n</code></pre>"},{"location":"gee/5.%20Working%20with%20Raster%20Data/5.%20Exporting%20Data/#3-creating-charts","title":"3. Creating Charts","text":"<p>If you just want a quick graph, you can print charts directly in the Code Editor (JavaScript) or display them in Jupyter (Python) without exporting files.</p> <ul> <li>JavaScript: Use <code>ui.Chart</code> functions.</li> <li>Python: Use <code>geemap.chart</code> or <code>matplotlib</code>.</li> </ul> <p>See the Time Series tutorial for a chart example.</p>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/","title":"Working with Maps (Vector Data)","text":"<p>In Google Earth Engine, vector data is called Geometry (points, lines) or Features (shapes with information). Think of these as drawings on top of the satellite images.</p>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/#types-of-vector-data","title":"Types of Vector Data","text":"Type Description Example Point A single location A city coordinate LineString A line connecting points A river or road Polygon A closed shape A country border, a field FeatureCollection A group of features All countries in the world"},{"location":"gee/6.%20Working%20with%20Vector%20Data/#popular-datasets-explained","title":"Popular Datasets Explained","text":"<p>You don't always have to draw your own shapes. GEE has many ready-to-use vector datasets:</p> Dataset What is it? Why use it? LSIB (USDOS) Detailed Country Boundaries To clip images to country borders FAO GAUL Admin Boundaries (States/Provinces) To analyze specific regions within a country Protected Areas National Parks &amp; Reserves To study conservation areas Your Own Data Shapes you upload To analyze your specific study area"},{"location":"gee/6.%20Working%20with%20Vector%20Data/#the-vector-workflow","title":"The Vector Workflow","text":"<pre><code>graph LR\n    A[Geometry / Point] -- .buffer --&gt; B[Area of Interest]\n    C[FeatureCollection] -- .filter --&gt; D[Selected Features]\n    B &amp; D -- .clip --&gt; E[Clipped Raster]\n    E -- .reduceRegion --&gt; F[Zonal Statistics]\n    style F fill:#f96,stroke:#333,stroke-width:2px</code></pre>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/#how-to-load-vector-data","title":"How to Load Vector Data","text":""},{"location":"gee/6.%20Working%20with%20Vector%20Data/#1-filtering-world-countries","title":"1. Filtering World Countries","text":"JavaScriptPython <pre><code>// Load the world boundaries\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\n\n// Filter to get only Brazil\nvar brazil = countries.filter(ee.Filter.eq('country_na', 'Brazil'));\n\nMap.centerObject(brazil, 4);\nMap.addLayer(brazil, {color: 'green'}, 'Brazil');\n</code></pre> <pre><code># Load the world boundaries\ncountries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\n\n# Filter to get only Brazil\nbrazil = countries.filter(ee.Filter.eq('country_na', 'Brazil'))\n\nMap = geemap.Map()\nMap.centerObject(brazil, 4)\nMap.addLayer(brazil, {'color': 'green'}, 'Brazil')\nMap\n</code></pre>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/#2-drawing-your-own-shape","title":"2. Drawing Your Own Shape","text":"<p>You can draw a rectangle directly on the map in the Code Editor, or define it in code:</p> JavaScriptPython <pre><code>// Define a rectangle for the Amazon Rainforest region\nvar amazon = ee.Geometry.Rectangle([-70.0, -10.0, -50.0, 0.0]);\n\nMap.addLayer(amazon, {color: 'blue'}, 'Amazon Region');\n</code></pre> <pre><code># Define a rectangle for the Amazon Rainforest region\namazon = ee.Geometry.Rectangle([-70.0, -10.0, -50.0, 0.0])\n\nMap = geemap.Map()\nMap.addLayer(amazon, {'color': 'blue'}, 'Amazon Region')\nMap\n</code></pre>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/#what-next","title":"What Next?","text":"<ul> <li>Understand Features - Learn the details of vector data</li> <li>Work with Collections - Filter and analyze groups of features</li> <li>Export Data - Save your results</li> </ul>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/1.%20Overview%20of%20Features/","title":"Features (Points, Lines, Polygons)","text":"<p>In Earth Engine, a single shape is called a Feature. It can be a point (like a city), a line (like a road), or a polygon (like a field).</p>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/1.%20Overview%20of%20Features/#creating-features","title":"Creating Features","text":""},{"location":"gee/6.%20Working%20with%20Vector%20Data/1.%20Overview%20of%20Features/#1-point","title":"1. Point","text":"JavaScriptPython <pre><code>// A point at [longitude, latitude]\nvar point = ee.Geometry.Point([-122.2, 37.7]);\n\nMap.addLayer(point, {color: 'red'}, 'My Point');\n</code></pre> <pre><code># A point at [longitude, latitude]\npoint = ee.Geometry.Point([-122.2, 37.7])\n\nMap.addLayer(point, {'color': 'red'}, 'My Point')\n</code></pre>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/1.%20Overview%20of%20Features/#2-linestring","title":"2. LineString","text":"<p>A line connects multiple points.</p> JavaScriptPython <pre><code>var river = ee.Geometry.LineString([\n  [-122.0, 37.0],\n  [-122.1, 37.1],\n  [-122.2, 37.2]\n]);\n\nMap.addLayer(river, {color: 'blue'}, 'My River');\n</code></pre> <pre><code>river = ee.Geometry.LineString([\n  [-122.0, 37.0],\n  [-122.1, 37.1],\n  [-122.2, 37.2]\n])\n\nMap.addLayer(river, {'color': 'blue'}, 'My River')\n</code></pre>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/1.%20Overview%20of%20Features/#3-polygon","title":"3. Polygon","text":"<p>A polygon is a closed shape (like a rectangle or custom drawing).</p> JavaScriptPython <pre><code>// A rectangle defined by [minLon, minLat, maxLon, maxLat]\nvar farm = ee.Geometry.Rectangle([-122.5, 37.5, -122.4, 37.6]);\n\nMap.addLayer(farm, {color: 'green'}, 'My Farm');\n</code></pre> <pre><code># A rectangle defined by [minLon, minLat, maxLon, maxLat]\nfarm = ee.Geometry.Rectangle([-122.5, 37.5, -122.4, 37.6])\n\nMap.addLayer(farm, {'color': 'green'}, 'My Farm')\n</code></pre>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/2.%20Feature%20Collections/","title":"Feature Collections (Boundaries)","text":"<p>A Feature Collection is a group of features, like a bag full of shapes. Most commonly, this is a dataset of country borders, states, or protected areas.</p>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/2.%20Feature%20Collections/#1-loading-global-boundaries","title":"1. Loading Global Boundaries","text":"<p>Let's load all countries in the world.</p> JavaScriptPython <pre><code>// Load the dataset\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\n\n// Display all countries (might be slow!)\nMap.addLayer(countries, {color: 'black'}, 'World Borders');\n</code></pre> <pre><code># Load the dataset\ncountries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')\n\nMap.addLayer(countries, {'color': 'black'}, 'World Borders')\n</code></pre>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/2.%20Feature%20Collections/#2-filtering-a-specific-country","title":"2. Filtering a Specific Country","text":"<p>Usually, you only want one country. Use <code>.filter()</code> to find it.</p> JavaScriptPython <pre><code>// Find \"France\" by filtering the 'country_na' property\nvar france = countries.filter(ee.Filter.eq('country_na', 'France'));\n\n// Center map and show only France\nMap.centerObject(france, 6);\nMap.addLayer(france, {color: 'blue'}, 'France');\n</code></pre> <pre><code># Find \"France\"\nfrance = countries.filter(ee.Filter.eq('country_na', 'France'))\n\nMap.centerObject(france, 6)\nMap.addLayer(france, {'color': 'blue'}, 'France')\n</code></pre>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/2.%20Feature%20Collections/#3-clipping-images","title":"3. Clipping Images","text":"<p>The most useful thing you can do with a boundary is cut (clip) an image to fit inside it.</p> JavaScriptPython <pre><code>// Load elevation data\nvar srtm = ee.Image(\"CGIAR/SRTM90_V4\");\n\n// Clip the image to France's shape\nvar franceElevation = srtm.clip(france);\n\nMap.addLayer(franceElevation, {min: 0, max: 2000}, 'Elevation (Clipped)');\n</code></pre> <pre><code># Load elevation data\nsrtm = ee.Image(\"CGIAR/SRTM90_V4\")\n\n# Clip the image to France's shape\nfrance_elevation = srtm.clip(france)\n\nMap.addLayer(france_elevation, {'min': 0, 'max': 2000}, 'Elevation (Clipped)')\n</code></pre>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/3.%20Exporting%20Vectors/","title":"Exporting Vectors (Boundaries &amp; Shapes)","text":"<p>Once you have filtered or processed your features, you can download them.</p>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/3.%20Exporting%20Vectors/#1-export-as-shapefile-shp","title":"1. Export as Shapefile (SHP)","text":"<p>To save your vector data for use in ArcGIS or QGIS, export as a Shapefile.</p> JavaScriptPython <p><pre><code>// Define the collection to export\nvar myCollection = france; // From previous example\n\n// Export it\nExport.table.toDrive({\n  collection: myCollection,\n  description: 'France_Boundary',\n  fileFormat: 'SHP'\n});\n</code></pre> If exporting a large collection, it will be split into part files.</p> <pre><code>import geemap\n\n# Export as Shapefile\ngeemap.ee_export_vector_to_drive(\n    france, \n    description='France_Boundary', \n    fileFormat='SHP'\n)\n</code></pre>"},{"location":"gee/6.%20Working%20with%20Vector%20Data/3.%20Exporting%20Vectors/#2-export-as-csv-table","title":"2. Export as CSV (Table)","text":"<p>If your features are points or just data (like a list of cities), you can export as a spreadsheet.</p> JavaScriptPython <pre><code>Export.table.toDrive({\n  collection: myCollection,\n  description: 'City_List',\n  fileFormat: 'CSV'\n});\n</code></pre> <pre><code>geemap.ee_export_vector_to_drive(\n    myCollection,\n    description='City_List',\n    fileFormat='CSV'\n)\n</code></pre>"},{"location":"gee/7.%20Machine%20Learning/1.%20Unsupervised/Theory/","title":"Theory","text":"<p>```javascript</p> <p>// To Do list</p>"},{"location":"gee/Advance%20Analysis/1.%20Random%20Sample/","title":"Advanced Sampling","text":"<p>This Google Earth Engine (GEE) script performs environmental data analysis using satellite images from various datasets, calculating and exporting indices such as cloud cover, NDVI (Normalized Difference Vegetation Index), and Land Surface Temperature (LST) for a selected region. Let\u2019s break down the main steps and explain each part in context.</p> <ol> <li>Cloud Fraction Calculation using Sentinel-5P (COPERNICUS/S5P/NRTI/L3_CLOUD) Dataset Purpose: The script starts by calculating the cloud fraction over a specified time range (April 2023 to September 2023). Cloud fraction represents the percentage of cloud cover within each satellite pixel and is useful for assessing cloudiness over an area.</li> </ol> <p>Method:</p> <p><pre><code>var collection = ee.ImageCollection('COPERNICUS/S5P/NRTI/L3_CLOUD')\n  .filterDate('2023-04-01', '2023-09-01')\n  .select('cloud_fraction');\n</code></pre> This code snippet filters the Sentinel-5P dataset to select only the cloud_fraction band for the specified date range. It calculates the mean cloud fraction using collection.mean(), which averages cloud cover data over the selected period. A color palette is applied to visualize the cloud fraction. 2. MODIS NDVI Calculation (MODIS/MOD09GA_006_NDVI) Purpose: NDVI measures vegetation health and density. Higher NDVI values indicate greener, healthier vegetation. Here, MODIS NDVI data from April to June 2018 is used.</p> <p>Method:</p> <p><pre><code>var dataset = ee.ImageCollection('MODIS/MOD09GA_006_NDVI')\n                  .filter(ee.Filter.date('2018-04-01', '2018-06-01'));\n</code></pre> The MODIS dataset is filtered by date and the NDVI band is selected. dataset.mean() computes the average NDVI for the specified time range, and a custom color palette is applied for visualization. 3. Landsat-8 Data Processing for NDVI and LST Calculation (LANDSAT/LC08/C02/T1_L2) Purpose: This step calculates NDVI and LST from Landsat-8 images. This dataset has high-resolution data suitable for vegetation and surface temperature analysis.</p> <p>Method:</p> <p>Scaling Factors: The function applyScaleFactors is defined to adjust Landsat\u2019s optical (SR_B.) and thermal (ST_B.) bands with scaling factors. <pre><code>var opticalBands = image.select('SR_B.*').multiply(0.0000275).add(-0.2);\nvar thermalBands = image.select('ST_B.*').multiply(0.00341802).add(149.0);\n</code></pre> NDVI Calculation: The calculateNDVI function computes NDVI as (NIR - Red) / (NIR + Red), which correlates with vegetation health. <pre><code>var ndvi = image.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI');\n</code></pre> LST Calculation: The calculateLST function estimates land surface temperature. The ST_B10 band provides surface brightness temperature, which is adjusted for emissivity derived from NDVI. <pre><code>var thermal = image.select('ST_B10').multiply(0.1);\nvar LST = thermal.expression(\n  '(Tb/(1 + (0.00115 * (Tb / 1.438)) * log(Ep)))', {\n    'Tb': thermal.select('ST_B10'),\n    'Ep': EM.select('EMM')\n  }).rename('LST');\n</code></pre> Here, Ep is the calculated emissivity, derived from NDVI, which helps adjust temperature values for surface types (vegetation vs. bare soil). 4. Sampling and Exporting Data Purpose: Sample and export point-based data to understand correlations among NDVI, cloud cover, LST, and vegetation conditions.</p> <p>Method:</p> <p>Point Sampling: <pre><code>var sample = ee.FeatureCollection.randomPoints({\n  region: aoi,\n  points: 500\n});\n</code></pre> A set of 500 random points is generated within the area of interest (AOI). Data Extraction and Combining: The script creates an image combining the selected bands (ndvi, cloud, lst, land) and samples these bands at each random point. <pre><code>var imgSamp = swir1Bands.sampleRegions({\n  collection: sample,\n  scale: 30\n})\n</code></pre> sampleRegions extracts values from each band at each sample point. Export to CSV: <pre><code>Export.table.toDrive({\n  collection: imgSamp,\n  description: 'CSV_points_Regression',\n  folder: 'GEE',\n  fileNamePrefix: 'CSV_points_Regression',\n  fileFormat: 'CSV',\n  selectors: ['ndvi', 'cloud', 'lst', 'land']\n});\n</code></pre> The sampled data is exported to Google Drive as a CSV file with columns for each index (ndvi, cloud, lst, land), which can be used for regression analysis or further statistical processing. Summary This script:</p> <p>Analyzes Cloud Cover (Sentinel-5P) and NDVI (MODIS) over specific timeframes. Calculates LST and NDVI using Landsat-8 images, enhancing environmental data for a specific region. Samples Data Points and exports these indices to a CSV file, useful for regression analysis or other data science applications, such as modeling relationships between vegetation health and cloud cover or temperature.</p> <p>```javascript var geometry= ee.FeatureCollection('users/pulakesh/JMU') Map.centerObject(geometry) var collection = ee.ImageCollection('COPERNICUS/S5P/NRTI/L3_CLOUD')   .filterDate('2023-04-01', '2023-09-01')   .select('cloud_fraction'); var meanCollection =collection.mean(); var band_viz = {   min: 0.40,   max: 0.60,   palette: ['#fff7fb','#ece7f2','#d0d1e6','#a6bddb','#74a9cf','#3690c0','#0570b0','#045a8d','#023858'] };</p> <p>Map.addLayer(meanCollection.clip(geometry), band_viz, 'S5P Cloud');</p> <p>//------------------------------------------------------------------------------MODIS NDVI var dataset = ee.ImageCollection('MODIS/MOD09GA_006_NDVI')                   .filter(ee.Filter.date('2018-04-01', '2018-06-01')); var colorized = dataset.select('NDVI').mean(); var colorizedVis = {   min: 0,   max: 1,   palette: [     'ffffff', 'ce7e45', 'df923d', 'f1b555', 'fcd163', '99b718', '74a901',     '66a000', '529400', '3e8601', '207401', '056201', '004c00', '023b01',     '012e01', '011d01', '011301'   ], };</p> <p>Map.addLayer(colorized.clip(geometry), colorizedVis, 'MODIS NDVI');</p> <p>//------------------------------------------------------------------------------MODIS LST var geometry = ee.FeatureCollection('users/pulakesh/JMU');</p> <p>var dataset = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')     .filterBounds(geometry);</p> <p>// Applies scaling factors. function applyScaleFactors(image) {   var opticalBands = image.select('SR_B.').multiply(0.0000275).add(-0.2);   var thermalBands = image.select('ST_B.').multiply(0.00341802).add(149.0);   return image.addBands(opticalBands, null, true).addBands(thermalBands, null, true); }</p> <p>dataset = dataset.map(applyScaleFactors);</p> <p>var visualization = {   bands: ['SR_B4', 'SR_B3', 'SR_B2'],   min: 0.0,   max: 0.3, };</p> <p>// Function to calculate NDVI. function calculateNDVI(image) {   var ndvi = image.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI');   return image.addBands(ndvi); }</p> <p>dataset = dataset.map(calculateNDVI);</p> <p>// Function to calculate Land Surface Temperature (LST). function calculateLST(image) {   var thermal = image.select('ST_B10').multiply(0.1);   var ndvi = image.select('NDVI');   var minNDVI = ee.Number(ndvi.reduceRegion({ reducer: ee.Reducer.min(), scale: 30, maxPixels: 1e9 }).values().get(0));   var maxNDVI = ee.Number(ndvi.reduceRegion({ reducer: ee.Reducer.max(), scale: 30, maxPixels: 1e9 }).values().get(0));   var fv = ndvi.subtract(minNDVI).divide(maxNDVI.subtract(minNDVI)).pow(ee.Number(2)).rename('FV');   var a = ee.Number(0.004);   var b = ee.Number(0.986);   var EM = fv.multiply(a).add(b).rename('EMM');</p> <p>var LST = thermal.expression(     '(Tb/(1 + (0.00115 * (Tb / 1.438)) * log(Ep)))', {       'Tb': thermal.select('ST_B10'),       'Ep': EM.select('EMM')     }).rename('LST');</p> <p>return image.addBands(LST); }</p> <p>dataset = dataset.map(calculateLST);</p> <p>// Combine all LST images into a single multiband image.  var REC = dataset.select('LST').filterDate('2021-01-01', '2021-01-30').median().clip(geometry); var L8ND = dataset.select('NDVI').filterDate('2021-01-01', '2021-01-30').median().clip(geometry); //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++point to CSV</p> <p>// Get the intersection between the two images - the area of interest (aoi). var aoi = geometry;</p> <p>// Get a set of 1000 random points from within the aoi. A feature collection // is returned. var sample = ee.FeatureCollection.randomPoints({   region: aoi,   points: 500 });</p> <p>var lst = REC; var land = L8ND; var ndvi = colorized; var cloud = collection.mean();</p> <p>// Combine the SWIR1 bands from each image into a single image. var swir1Bands = ndvi.select('NDVI')   .addBands(cloud.select('cloud_fraction'))   .addBands(lst.select('LST'))   .addBands(land.select('NDVI'))   .rename(['ndvi', 'cloud', 'lst', 'land']);</p> <p>// Sample the SWIR1 bands using the sample point feature collection. var imgSamp = swir1Bands.sampleRegions({   collection: sample,   scale: 30 }) // Add a constant property to each feature to be used as an independent variable. .map(function(feature) {   return feature.set('constant', 1); });</p> <p>print(imgSamp)</p> <p>Export.table.toDrive({   collection: imgSamp,   description: 'CSV_points_Regression',   folder: 'GEE',   fileNamePrefix: 'CSV_points_Regression',   fileFormat: 'CSV',   selectors: ['ndvi', 'cloud', 'lst', 'land'] });</p>"},{"location":"gee/Exercises/1.%20Data%20Type/","title":"Google Earth Engine Exercises","text":""},{"location":"gee/Exercises/1.%20Data%20Type/#module-1-earth-engine-basics","title":"Module 1: Earth Engine Basics","text":""},{"location":"gee/Exercises/1.%20Data%20Type/#01-hello-world","title":"01. Hello World","text":"<ul> <li>List the five largest cities in the world: Tokyo, Delhi, Shanghai, Mexico City, Sao Paulo.</li> <li>Create a list called <code>largeCities</code> with these city names.</li> <li>Print the list to the console.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#02-working-with-image-collections","title":"02. Working with Image Collections","text":"<ul> <li>Locate the Sentinel-2 Level-1C dataset in the Earth Engine catalog.</li> <li>Copy and paste the code snippet to load this dataset.</li> <li>Modify the code to display images for your home city.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#03-filtering-image-collections","title":"03. Filtering Image Collections","text":"<ul> <li>Apply filters to an image collection to select images by:</li> <li>Specific criteria using <code>ee.Filter.eq()</code>, <code>ee.Filter.lt()</code>, etc.</li> <li>Date range using <code>ee.Filter.date()</code>.</li> <li>Location using <code>ee.Filter.bounds()</code>.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#04-creating-mosaics-and-composites-from-image-collections","title":"04. Creating Mosaics and Composites from Image Collections","text":"<ul> <li>Create a median composite image for a specific time period.</li> <li>Load an image collection and apply the median reducer.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#05-working-with-feature-collections","title":"05. Working with Feature Collections","text":"<ul> <li>Filter a feature collection to select specific regions.</li> <li>Display the filtered regions on the map.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#06-importing-data","title":"06. Importing Data","text":"<ul> <li>Import a dataset and apply filters to select specific features.</li> <li>Display the filtered results on the map.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#07-clipping-images","title":"07. Clipping Images","text":"<ul> <li>Clip an image to the geometry of a specified feature.</li> <li>Display the clipped image on the map.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#08-exporting-data","title":"08. Exporting Data","text":"<ul> <li>Export the processed image or feature collection as an asset.</li> <li>Use <code>Export.image.toDrive()</code> or <code>Export.table.toDrive()</code> as needed.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#module-2-earth-engine-intermediate","title":"Module 2: Earth Engine Intermediate","text":""},{"location":"gee/Exercises/1.%20Data%20Type/#01-earth-engine-objects","title":"01. Earth Engine Objects","text":"<ul> <li>Manipulate Earth Engine objects to process data.</li> <li>Use Earth Engine methods and properties effectively.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#02-calculating-indices","title":"02. Calculating Indices","text":"<ul> <li>Calculate spectral indices like NDVI or EVI.</li> <li>Select the appropriate bands from an image collection.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#03-computation-on-image-collections","title":"03. Computation on Image Collections","text":"<ul> <li>Perform computations on image collections using reducers.</li> <li>Aggregate data over a specific time period or spatial extent.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#04-cloud-masking","title":"04. Cloud Masking","text":"<ul> <li>Implement cloud masking techniques to improve image quality.</li> <li>Use cloud probability bands to mask clouds.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#05-reducers","title":"05. Reducers","text":"<ul> <li>Use reducers to summarize data from image collections.</li> <li>Apply functions like mean, median, or mode.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#06-time-series-charts","title":"06. Time-Series Charts","text":"<ul> <li>Create time-series charts to visualize changes over time.</li> <li>Use <code>ui.Chart.image.series()</code> to generate the charts.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#module-3-supervised-classification","title":"Module 3: Supervised Classification","text":""},{"location":"gee/Exercises/1.%20Data%20Type/#01-basic-supervised-classification","title":"01. Basic Supervised Classification","text":"<ul> <li>Perform supervised classification with training data.</li> <li>Train a classifier and apply it to an image collection.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#02-accuracy-assessment","title":"02. Accuracy Assessment","text":"<ul> <li>Calculate accuracy metrics for a classified image.</li> <li>Use a confusion matrix and overall accuracy metrics.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#03-improving-the-classification","title":"03. Improving the Classification","text":"<ul> <li>Enhance classification results by adding spectral indices.</li> <li>Retrain the classifier using these new features.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#04-exporting-classification-results","title":"04. Exporting Classification Results","text":"<ul> <li>Export the classified image as an asset.</li> <li>Use <code>Export.image.toDrive()</code> with suitable parameters.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#05-calculating-area","title":"05. Calculating Area","text":"<ul> <li>Compute the area of different land cover classes.</li> <li>Print area statistics to the console.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#module-4-change-detection","title":"Module 4: Change Detection","text":""},{"location":"gee/Exercises/1.%20Data%20Type/#01-spectral-index-change","title":"01. Spectral Index Change","text":"<ul> <li>Analyze changes in spectral indices over time.</li> <li>Identify areas with significant changes.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#02-spectral-distance-change","title":"02. Spectral Distance Change","text":"<ul> <li>Apply spectral distance methods to detect changes.</li> <li>Use thresholds to classify changed areas.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#03-direct-classification-of-change","title":"03. Direct Classification of Change","text":"<ul> <li>Classify change directly using machine learning techniques.</li> <li>Assess land cover changes over time.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#04-post-classification-comparison","title":"04. Post-Classification Comparison","text":"<ul> <li>Compare pre- and post-classification results.</li> <li>Visualize areas of change on the map.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#module-5-earth-engine-apps","title":"Module 5: Earth Engine Apps","text":""},{"location":"gee/Exercises/1.%20Data%20Type/#01-client-vs-server","title":"01. Client vs. Server","text":"<ul> <li>Understand the differences between client-side and server-side processing.</li> <li>Use appropriate methods for each type of processing.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#02-using-ui-elements","title":"02. Using UI Elements","text":"<ul> <li>Create UI elements such as dropdowns and buttons.</li> <li>Integrate these elements into your Earth Engine app.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#03-building-and-publishing-an-app","title":"03. Building and Publishing an App","text":"<ul> <li>Build an interactive Earth Engine app.</li> <li>Publish the app to the Earth Engine App Gallery.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#04-creating-a-split-panel-app","title":"04. Creating a Split Panel App","text":"<ul> <li>Design a split-panel app with multiple views.</li> <li>Use <code>ui.SplitPanel()</code> to organize the layout.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#module-6-google-earth-engine-python-api","title":"Module 6: Google Earth Engine Python API","text":""},{"location":"gee/Exercises/1.%20Data%20Type/#01-python-api-syntax","title":"01. Python API Syntax","text":"<ul> <li>Convert Earth Engine code to Python API syntax.</li> <li>Use equivalent Python methods and classes.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#02-automatic-conversion-of-code-to-python","title":"02. Automatic Conversion of Code to Python","text":"<ul> <li>Use geemap to automatically convert Earth Engine code to Python.</li> <li>Leverage geemap's conversion features.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#03-batch-exports","title":"03. Batch Exports","text":"<ul> <li>Initiate batch export tasks for multiple images.</li> <li>Automate exports using the Python API.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#04-using-earth-engine-with-xarray","title":"04. Using Earth Engine with XArray","text":"<ul> <li>Integrate Earth Engine with XArray for advanced data analysis.</li> <li>Use XArray's data structures and methods for analysis.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#05-automating-downloads","title":"05. Automating Downloads","text":"<ul> <li>Automate data downloads using the Python API.</li> <li>Create scripts to download data for further processing.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#06-automating-exports","title":"06. Automating Exports","text":"<ul> <li>Automate exports with the Python API and service accounts.</li> <li>Use scripts to handle large-scale processing.</li> </ul>"},{"location":"gee/Exercises/1.%20Data%20Type/#07-using-the-google-earth-engine-qgis-plugin","title":"07. Using the Google Earth Engine QGIS Plugin","text":"<ul> <li>Use the QGIS plugin to visualize Earth Engine data.</li> <li>Integrate Earth Engine with QGIS for geospatial analysis.</li> </ul>"},{"location":"gee/Print/Feature/","title":"Feature","text":""},{"location":"gee/Print/Feature/#feature-vs-featurecollection","title":"Feature vs FeatureCollection","text":"<ul> <li>Feature: A single geographic object with associated attributes (properties). It consists of a geometry (e.g., a point, line, polygon) and metadata.</li> <li>FeatureCollection: A collection of multiple features. It's used to store and process datasets containing multiple geographic objects.</li> </ul>"},{"location":"gee/Print/Feature/#importing-featurecollection","title":"Importing FeatureCollection","text":"<pre><code>var table = ee.FeatureCollection(\"projects/pulakesh/assets/cmc\");\nvar city = ee.FeatureCollection(\"projects/pulakesh/assets/bmc\");\nMap.addLayer(table);\n</code></pre> <ul> <li><code>ee.FeatureCollection</code>: Represents the spatial data imported.</li> <li><code>Map.addLayer</code>: Adds the data to the map for visualization.</li> </ul>"},{"location":"gee/Print/Feature/#1-calculate-area","title":"1. Calculate Area","text":"<pre><code>print(table.geometry().area().divide(1e6));\n</code></pre> <ul> <li>Purpose: Computes the area of the entire <code>FeatureCollection</code> in square kilometers.</li> <li>Method:<ul> <li><code>table.geometry()</code>: Merges all features into a single geometry.</li> <li><code>area()</code>: Calculates the area in square meters.</li> <li><code>.divide(1e6)</code>: Converts the area to square kilometers.</li> </ul> </li> </ul> <pre><code>var area = table.map(function(feature) {\n  return feature.set('area_km2', feature.geometry().area().divide(1e6));\n});\n</code></pre> <ul> <li>Purpose: Adds a property <code>area_km2</code> to each feature, representing its area in square kilometers.</li> <li>Method: Use <code>map()</code> to iterate over each feature and attach the area as a property.</li> </ul>"},{"location":"gee/Print/Feature/#2-get-bounds","title":"2. Get Bounds","text":"<pre><code>var bounds = table.map(function(feature) {\n  return feature.setGeometry(feature.geometry().bounds());\n});\n</code></pre> <ul> <li>Purpose: Computes the bounding box (minimum enclosing rectangle) for each feature.</li> <li>Method:<ul> <li><code>.bounds()</code>: Calculates the bounds.</li> <li><code>setGeometry</code>: Updates the feature's geometry to the bounding box.</li> </ul> </li> </ul> <pre><code>var bounds = table.geometry().bounds();\n</code></pre> <ul> <li>Purpose: Gets the bounding box for the entire <code>FeatureCollection</code>.</li> </ul>"},{"location":"gee/Print/Feature/#3-buffer","title":"3. Buffer","text":"<pre><code>var buffered = table.map(function(feature) {\n  return feature.buffer(10000); // Buffer distance in meters\n});\n</code></pre> <ul> <li>Purpose: Creates a buffer (a zone around a feature) of 10 km around each feature.</li> <li>Method:<ul> <li><code>.buffer(10000)</code>: Adds a buffer of 10,000 meters (10 km) to the geometry.</li> </ul> </li> </ul>"},{"location":"gee/Print/Feature/#4-centroid","title":"4. Centroid","text":"<pre><code>var centroids = table.map(function(feature) {\n  return feature.setGeometry(feature.geometry().centroid());\n});\n</code></pre> <ul> <li>Purpose: Computes the centroid (geometric center) for each feature.</li> <li>Method:<ul> <li><code>.centroid()</code>: Calculates the centroid of the geometry.</li> </ul> </li> </ul>"},{"location":"gee/Print/Feature/#5-distance","title":"5. Distance","text":"<pre><code>var point = ee.Geometry.Point([37.5, 0.5]); // Example point\nvar distances = table.map(function(feature) {\n  return feature.set('distance_to_point_m', feature.geometry().distance(point));\n});\n</code></pre> <ul> <li>Purpose: Calculates the distance of each feature to a specific point.</li> <li>Method:<ul> <li><code>.distance(point)</code>: Computes the distance between the feature's geometry and the given point.</li> </ul> </li> </ul>"},{"location":"gee/Print/Feature/#6-dissolve","title":"6. Dissolve","text":"<pre><code>var dissolved = table.geometry();\n</code></pre> <ul> <li>Purpose: Dissolves all features into a single geometry.</li> </ul> <p>Made by Pulakesh Pradhan</p>"},{"location":"gee/Print/Feature/#7-evaluate","title":"7. Evaluate","text":"<pre><code>table.first().geometry().area().evaluate(function(area) {\n  print('Area of the first feature in m\u00b2:', area);\n});\n</code></pre> <ul> <li>Purpose: Evaluates the area of the first feature client-side.</li> <li>Method:<ul> <li><code>.evaluate()</code>: Converts the server-side object to a client-side value.</li> </ul> </li> </ul>"},{"location":"gee/Print/Feature/#8-geometry","title":"8. Geometry","text":"<pre><code>var firstGeometry = table.first().geometry();\nprint('First feature geometry:', firstGeometry);\n</code></pre> <ul> <li>Purpose: Retrieves the geometry of the first feature.</li> </ul>"},{"location":"gee/Print/Feature/#9-property-names","title":"9. Property Names","text":"<pre><code>var propertyNames = table.first().propertyNames();\nprint('Property names:', propertyNames);\n</code></pre> <ul> <li>Purpose: Retrieves the list of property names for the first feature.</li> </ul>"},{"location":"gee/Print/Feature/#10-select","title":"10. Select","text":"<pre><code>var selected = table.select(['ADM1_NAME', 'ADM0_NAME']);\n</code></pre> <ul> <li>Purpose: Selects specific properties from the features.</li> </ul>"},{"location":"gee/Print/Feature/#11-simplify","title":"11. Simplify","text":"<pre><code>var simplified = table.map(function(feature) {\n  return feature.setGeometry(feature.geometry().simplify(1000)); // Tolerance in meters\n});\n</code></pre> <ul> <li>Purpose: Simplifies the geometry of each feature to reduce complexity.</li> </ul> <p>Made by Pulakesh Pradhan</p>"},{"location":"gee/Print/Feature/#12-union","title":"12. Union","text":"<pre><code>var fc = ee.FeatureCollection('WRI/GPPD/power_plants')\n            .filter('country_lg == \"Belgium\"');\nvar union = fc.union(1);\n</code></pre> <ul> <li>Purpose: Merges all geometries in the <code>FeatureCollection</code> into one.</li> </ul>"},{"location":"gee/Print/Feature/#13-within-distance","title":"13. Within Distance","text":"<pre><code>var withinDistance = table.filter(ee.Filter.withinDistance({\n  distance: 50000, // Distance in meters\n  leftField: '.geo', // Geometry field\n  rightField: '.geo',\n  maxError: 10\n}));\n</code></pre> <ul> <li>Purpose: Finds features within 50 km of a point or another geometry.</li> </ul>"},{"location":"gee/Print/Feature/#14-additional-operations","title":"14. Additional Operations","text":"<ul> <li> <p>Intersection: Calculates the overlapping geometry between features.</p> <pre><code>var intersection = table.geometry().intersection(table.geometry());\n</code></pre> </li> <li> <p>Difference: Computes the non-overlapping part of the geometry.</p> <pre><code>var difference = table.geometry().difference(buffered.geometry());\n</code></pre> </li> </ul>"},{"location":"gee/Print/Feature/#15-export","title":"15. Export","text":"<pre><code>Export.table.toDrive({\n  collection: area,\n  description: 'Exported_Features',\n  fileFormat: 'CSV'\n});\n</code></pre> <ul> <li>Purpose: Exports the <code>FeatureCollection</code> with computed areas to Google Drive as a CSV file.</li> </ul> <p>Made by Pulakesh Pradhan</p>"},{"location":"gee/Print/FeatureGee/","title":"FeatureGee","text":""},{"location":"gee/Print/FeatureGee/#geometries-in-google-earth-engine","title":"Geometries in Google Earth Engine","text":"<p>Google Earth Engine (GEE) provides a variety of geometries for spatial analysis. Below is an explanation of how to declare and work with geometries, along with detailed examples.</p>"},{"location":"gee/Print/FeatureGee/#1-points","title":"1. Points","text":"<p>A Point represents a single location in space, defined by latitude and longitude coordinates.</p>"},{"location":"gee/Print/FeatureGee/#syntax","title":"Syntax:","text":"<pre><code>var poi = ee.Geometry.Point(longitude, latitude);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#example","title":"Example:","text":"<pre><code>var poi = ee.Geometry.Point(0, 45); // Point at (longitude=0, latitude=45)\n</code></pre>"},{"location":"gee/Print/FeatureGee/#2-multi-points","title":"2. Multi-Points","text":"<p>A MultiPoint represents a collection of points.</p>"},{"location":"gee/Print/FeatureGee/#syntax_1","title":"Syntax:","text":"<pre><code>var multi = ee.Geometry.MultiPoint([longitude1, latitude1, longitude2, latitude2, ...]);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#example_1","title":"Example:","text":"<pre><code>var multi = ee.Geometry.MultiPoint([0, 45, 5, 6, 70, -56]); // Points: (0, 45), (5, 6), (70, -56)\n</code></pre>"},{"location":"gee/Print/FeatureGee/#3-linestring","title":"3. LineString","text":"<p>A LineString connects two or more points with a straight line between each pair of consecutive points.</p>"},{"location":"gee/Print/FeatureGee/#syntax_2","title":"Syntax:","text":"<pre><code>var lineStr = ee.Geometry.LineString([[longitude1, latitude1], [longitude2, latitude2], ...]);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#example_2","title":"Example:","text":"<pre><code>var lineStr = ee.Geometry.LineString([[0, 45], [5, 6], [70, -56]]);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#4-multi-linestring","title":"4. Multi-LineString","text":"<p>A MultiLineString contains multiple LineStrings.</p>"},{"location":"gee/Print/FeatureGee/#syntax_3","title":"Syntax:","text":"<pre><code>var mLineStr = ee.Geometry.MultiLineString([[[long1, lat1], [long2, lat2], ...], ...]);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#example_3","title":"Example:","text":"<pre><code>var mLineStr = ee.Geometry.MultiLineString(\n    [[[0, 45], [5, 6], [70, -56]], [[0, -45], [-5, -6], [-70, 56]]]\n);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#5-linearring","title":"5. LinearRing","text":"<p>A LinearRing is a closed LineString, forming a loop. The first and last points must be the same.</p>"},{"location":"gee/Print/FeatureGee/#syntax_4","title":"Syntax:","text":"<pre><code>var linRin = ee.Geometry.LinearRing([long1, lat1, long2, lat2, ...]);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#example_4","title":"Example:","text":"<pre><code>var linRin = ee.Geometry.LinearRing([0, 45, 5, 6, 70, -56, 0, 45]);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#6-rectangle","title":"6. Rectangle","text":"<p>A Rectangle is defined by two diagonally opposite corners.</p>"},{"location":"gee/Print/FeatureGee/#syntax_5","title":"Syntax:","text":"<pre><code>var rect = ee.Geometry.Rectangle(long1, lat1, long2, lat2);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#example_5","title":"Example:","text":"<pre><code>var rect = ee.Geometry.Rectangle(0, 0, 60, 30);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#7-polygon","title":"7. Polygon","text":"<p>A Polygon is a closed shape formed by connecting multiple points, where the first and last points are the same.</p>"},{"location":"gee/Print/FeatureGee/#syntax_6","title":"Syntax:","text":"<pre><code>var poly = ee.Geometry.Polygon([[[long1, lat1], [long2, lat2], ...]]);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#example_6","title":"Example:","text":"<pre><code>var poly = ee.Geometry.Polygon([[[0, 0], [6, 3], [5, 5], [-30, 2], [0, 0]]]);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#8-multi-polygon","title":"8. Multi-Polygon","text":"<p>A MultiPolygon consists of multiple polygons.</p>"},{"location":"gee/Print/FeatureGee/#syntax_7","title":"Syntax:","text":"<pre><code>var multiPoly = ee.Geometry.MultiPolygon([polygon1, polygon2, ...]);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#example_7","title":"Example:","text":"<pre><code>var multiPoly = ee.Geometry.MultiPolygon([\n    ee.Geometry.Polygon([[0, 0], [6, 3], [5, 5], [-30, 2], [0, 0]]),\n    ee.Geometry.Polygon([[0, 0], [-6, -3], [-5, -5], [30, -2], [0, 0]])\n]);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#features-and-featurecollections","title":"Features and FeatureCollections","text":"<ul> <li>Features associate geometries with properties (e.g., name, population).</li> <li>FeatureCollections are groups of features.</li> </ul>"},{"location":"gee/Print/FeatureGee/#example_8","title":"Example:","text":"<pre><code>var feature = ee.Feature(ee.Geometry.Point(0, 0), {name: 'A Point'});\nvar featureCollection = ee.FeatureCollection([\n    ee.Feature(ee.Geometry.Point(0, 0), {name: 'Point 1'}),\n    ee.Feature(ee.Geometry.Point(1, 1), {name: 'Point 2'})\n]);\n</code></pre>"},{"location":"gee/Print/FeatureGee/#common-operations-on-geometries","title":"Common Operations on Geometries","text":"<ol> <li> <p>Finding the Area</p> <pre><code>var geoArea = geometry.area(maxError);\n</code></pre> <p>Example:</p> <pre><code>var area = rect.area(); // Calculate area of a rectangle\n</code></pre> </li> <li> <p>Finding the Length of a Line</p> <pre><code>var linLen = lineString.length(maxError);\n</code></pre> <p>Example:</p> <pre><code>var length = lineStr.length();\n</code></pre> </li> <li> <p>Finding the Perimeter</p> <pre><code>var geoPeri = geometry.perimeter(maxError);\n</code></pre> <p>Example:</p> <pre><code>var perimeter = poly.perimeter();\n</code></pre> </li> <li> <p>Simplifying a Geometry</p> <pre><code>var simpGeo = geometry.simplify(maxError);\n</code></pre> <p>Example:</p> <pre><code>var simplified = poly.simplify(1);\n</code></pre> </li> <li> <p>Finding the Centroid</p> <pre><code>var centrGeo = geometry.centroid(maxError);\n</code></pre> <p>Example:</p> <pre><code>var centroid = poly.centroid();\n</code></pre> </li> <li> <p>Buffering</p> <pre><code>var buffGeo = geometry.buffer(radius, maxError);\n</code></pre> <p>Example:</p> <pre><code>var buffer = poi.buffer(1000); // Create a 1000-meter buffer around a point\n</code></pre> </li> <li> <p>Bounding Rectangle</p> <pre><code>var bounGeo = geometry.bounds(maxError);\n</code></pre> <p>Example:</p> <pre><code>var bounds = poly.bounds();\n</code></pre> </li> <li> <p>Convex Hull</p> <pre><code>var convexGeo = geometry.convexHull(maxError);\n</code></pre> <p>Example:</p> <pre><code>var convex = poly.convexHull();\n</code></pre> </li> <li> <p>Intersection</p> <pre><code>var interGeo = geometry1.intersection(geometry2, maxError);\n</code></pre> <p>Example:</p> <pre><code>var intersection = rect.intersection(poly);\n</code></pre> </li> <li> <p>Union</p> <pre><code>var unGeo = geometry1.union(geometry2, maxError);\n</code></pre> <p>Example:</p> <pre><code>var union = rect.union(poly);\n</code></pre> </li> </ol> <p>Made by Pulakesh Pradhan</p>"},{"location":"gee/Print/FeatureGee/#loading-and-displaying-the-featurecollection","title":"Loading and Displaying the FeatureCollection","text":"<pre><code>var city = ee.FeatureCollection(\"projects/pulakesh/assets/bmc\");\nMap.addLayer(city);\n</code></pre> <ul> <li>Explanation:     The <code>ee.FeatureCollection</code> function loads a collection of features from a specified path. Here, the <code>city</code> FeatureCollection is loaded, representing geographic features.</li> <li>Visualization: <code>Map.addLayer(city)</code> adds the layer to the map for visualization in the GEE Code Editor.</li> </ul>"},{"location":"gee/Print/FeatureGee/#calculating-and-printing-the-area-of-the-geometry","title":"Calculating and Printing the Area of the Geometry","text":"<pre><code>print(city.geometry().area().divide(1e6));\n</code></pre> <ul> <li>Explanation:<ul> <li>The <code>.geometry()</code> method extracts the geometry of the FeatureCollection.</li> <li><code>.area()</code> calculates the area of the geometry in square meters.</li> <li><code>.divide(1e6)</code> converts the area from square meters to square kilometers.</li> <li><code>print</code> outputs the calculated area to the Console.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#finding-the-bounding-box","title":"Finding the Bounding Box","text":"<pre><code>var bounds = city.geometry().bounds();\nMap.addLayer(bounds);\n</code></pre> <ul> <li>Explanation:<ul> <li>The <code>.bounds()</code> method creates a rectangular bounding box that fully contains the geometry of the <code>city</code>.</li> <li>This bounding box is added to the map for visualization.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#creating-a-buffer-around-the-geometry","title":"Creating a Buffer Around the Geometry","text":"<pre><code>var buffer = city.geometry().buffer(10000);\nMap.addLayer(buffer);\n</code></pre> <ul> <li>Explanation:<ul> <li>The <code>.buffer(10000)</code> method creates a buffer of 10,000 meters (10 km) around the geometry of <code>city</code>.</li> <li>The buffer is visualized on the map.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#finding-the-centroid-of-the-geometry","title":"Finding the Centroid of the Geometry","text":"<pre><code>var centroid = city.geometry().centroid();\nMap.addLayer(centroid);\n</code></pre> <ul> <li>Explanation:<ul> <li>The <code>.centroid()</code> method calculates the geometric center of the <code>city</code>.</li> <li>This centroid is added to the map for visualization.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#calculating-centroids-for-each-feature","title":"Calculating Centroids for Each Feature","text":"<pre><code>var centroids = city.map(function(feature) {\n  return feature.setGeometry(feature.geometry().centroid());\n});\nMap.addLayer(centroids);\n</code></pre> <ul> <li>Explanation:<ul> <li>The <code>.map()</code> function iterates over each feature in the <code>city</code> FeatureCollection.</li> <li>For each feature, the <code>.centroid()</code> method calculates its centroid, and <code>.setGeometry()</code> updates the feature geometry to its centroid.</li> <li>The resulting centroids are visualized on the map.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#calculating-distance-to-a-point","title":"Calculating Distance to a Point","text":"<pre><code>var point = ee.Geometry.Point([85.895361, 20.462031]); // Example point\nvar distances = city.map(function(feature) {\n  return feature.set('distance_to_point_m', feature.geometry().distance(point));\n});\nprint(distances);\n</code></pre> <ul> <li>Explanation:<ul> <li>A <code>Point</code> geometry is created using the <code>.Point()</code> method with the specified coordinates.</li> <li>The <code>.map()</code> function iterates over each feature in the <code>city</code> FeatureCollection.</li> <li>For each feature, <code>.distance(point)</code> calculates the distance in meters between the feature's geometry and the specified point.</li> <li>The distance is added as a new property (<code>distance_to_point_m</code>) to each feature.</li> <li><code>print(distances)</code> outputs the updated FeatureCollection with distances to the Console.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#dissolving-the-geometry","title":"Dissolving the Geometry","text":"<pre><code>var dissolved = city.geometry().dissolve();\nMap.addLayer(dissolved);\n</code></pre> <ul> <li>Explanation:<ul> <li>The <code>.dissolve()</code> method merges all geometries in the <code>city</code> FeatureCollection into a single unified geometry.</li> <li>The dissolved geometry is visualized on the map.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#simplifying-the-geometry","title":"Simplifying the Geometry","text":"<pre><code>var simplified = city.geometry().simplify(100);\nMap.addLayer(simplified);\n</code></pre> <ul> <li>Explanation:<ul> <li>The <code>.simplify(100)</code> method reduces the number of vertices in the geometry, with a tolerance of 100 meters.</li> <li>This simplifies the geometry for faster processing and visualization.</li> <li>The simplified geometry is added to the map.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#union-of-features","title":"Union of Features","text":"<pre><code>var union = city.union();\nMap.addLayer(union);\n</code></pre> <ul> <li>Explanation:<ul> <li>The <code>.union()</code> method combines overlapping or adjacent geometries into a single unified geometry.</li> <li>This is useful for merging multiple features into a single shape.</li> <li>The result is visualized on the map.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#intersection-of-geometries","title":"Intersection of Geometries","text":""},{"location":"gee/Print/FeatureGee/#code","title":"Code:","text":"<pre><code>var intersection = city.first().geometry().intersection(city.geometry().buffer(100));\nMap.addLayer(intersection);\n</code></pre> <ul> <li>Explanation:<ul> <li>The <code>.intersection()</code> method finds the common area between two geometries: the geometry of the first feature in <code>city</code> and the 100-meter buffer of the <code>city</code> geometry.</li> <li>The resulting intersected area is visualized on the map.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#difference-between-geometries","title":"Difference Between Geometries","text":""},{"location":"gee/Print/FeatureGee/#code_1","title":"Code:","text":"<pre><code>var difference = city.geometry().difference(buffer);\nprint(difference);\n</code></pre> <ul> <li>Explanation:<ul> <li>The <code>.difference(buffer)</code> method calculates the area of the <code>city</code> geometry that does not overlap with the buffer.</li> <li>The resulting geometry is printed to the Console.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#exporting-the-featurecollection","title":"Exporting the FeatureCollection","text":""},{"location":"gee/Print/FeatureGee/#code_2","title":"Code:","text":"<pre><code>Export.table.toDrive({\n  collection: city,\n  description: 'Exported_Features',\n  fileFormat: 'SHP'\n});\n</code></pre> <ul> <li>Explanation:<ul> <li>The <code>Export.table.toDrive</code> function exports the <code>city</code> FeatureCollection as a shapefile (<code>SHP</code>) to Google Drive.</li> <li><code>description</code> specifies the name of the exported file.</li> <li>This allows the FeatureCollection to be used in external GIS tools like QGIS or ArcGIS.</li> </ul> </li> </ul>"},{"location":"gee/Print/FeatureGee/#summary-of-key-operations","title":"Summary of Key Operations:","text":"<ol> <li>Area, Bounds, Centroid: Measure and summarize basic geometric properties.</li> <li>Buffer, Simplify, Union, Dissolve: Modify geometries for analysis and visualization.</li> <li>Intersection, Difference: Analyze spatial relationships between geometries.</li> <li>Export: Save the processed geometries for further use.</li> </ol> <p>These operations form the backbone of geospatial analysis in Google Earth Engine.</p> <p>Made by Pulakesh Pradhan</p>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/2.%20Exploring%20GSW%20Dataset/","title":"Exploring the Global Surface Water (GSW) Dataset","text":"<p>The Global Surface Water (GSW) dataset, created by the European Commission's Joint Research Centre (JRC), contains maps of the location and temporal distribution of surface water over 35 years.</p>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/2.%20Exploring%20GSW%20Dataset/#1-loading-the-dataset","title":"\ud83d\udef0\ufe0f 1. Loading the Dataset","text":"<p>The GSW dataset is available in Earth Engine as a single multi-band image.</p> <pre><code>// Import the Global Surface Water dataset\nvar gsw = ee.Image('JRC/GSW1_4/GlobalSurfaceWater');\n\n// Print metadata to the console\nprint('GSW Metadata:', gsw);\n\n// Set map center over a region (e.g., Pune, India)\nMap.setCenter(73.85, 18.52, 11);\n</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/2.%20Exploring%20GSW%20Dataset/#2-visualizing-occurrence","title":"\ud83d\udca7 2. Visualizing Occurrence","text":"<p>The <code>occurrence</code> band shows the frequency with which water was present on the surface.</p> <pre><code>// Define visualization for water occurrence (0-100%)\nvar occVis = {\n  min: 0.0,\n  max: 100.0,\n  palette: ['ffffff', 'ffbbbb', '0000ff']\n};\n\n// Add the occurrence layer\nMap.addLayer(gsw.select('occurrence'), occVis, 'Water Occurrence');\n</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/2.%20Exploring%20GSW%20Dataset/#3-creating-a-permanent-water-mask","title":"\ud83d\udee1\ufe0f 3. Creating a Permanent Water Mask","text":"<p>To identify \"permanent\" water bodies, we can filter for pixels that have water more than 90% of the time.</p> <pre><code>// Select the occurrence band\nvar occurrence = gsw.select('occurrence');\n\n// Create a mask for pixels with &gt;90% water occurrence\nvar permanentWater = occurrence.gt(90).unmask(0);\n\nMap.addLayer(permanentWater, {palette: ['white', 'darkblue']}, 'Permanent Water (&gt;90% Occ)');\n</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/2.%20Exploring%20GSW%20Dataset/#4-analyzing-absolute-change","title":"\ud83d\udcc8 4. Analyzing Absolute Change","text":"<p>The <code>change_abs</code> band shows the absolute change in water occurrence between two periods (1984-1999 and 2000-2021).</p> <pre><code>graph LR\n    A[Raw Bands] --&gt; B[Subtract Periods]\n    B --&gt; C[Change Intensity]\n    C -- Red --&gt; D[Loss of Water]\n    C -- Green --&gt; E[Gain of Water]\n    style D fill:#f66\n    style E fill:#6f6</code></pre> <pre><code>var change = gsw.select(\"change_abs\");\nvar changeVis = {\n  min: -50,\n  max: 50,\n  palette: ['red', 'black', 'limegreen']\n};\n\n// Center over a reservoir (Tehri Reservoir)\nMap.setCenter(78.48, 30.38, 12);\nMap.addLayer(change, changeVis, 'Occurrence Change Intensity');\n</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/2.%20Exploring%20GSW%20Dataset/#5-surface-water-transitions","title":"\ud83d\udd00 5. Surface Water Transitions","text":"<p>This band detects transitions between states (e.g., permanent to seasonal, seasonal to lost).</p> <pre><code>var transition = gsw.select('transition');\nvar transVis = {\n  min: 0,\n  max: 10,\n  palette: [\n    \"ffffff\", // No water\n    \"0000ff\", // Permanent\n    \"22b14c\", // New permanent\n    \"d1102d\", // Lost permanent\n    \"99d9ea\", // Seasonal\n    \"b5e61d\", // New seasonal\n    \"e6a1aa\", // Lost seasonal\n    \"ff7f27\", // Seasonal to permanent\n    \"ffc90e\", // Permanent to seasonal\n    \"7f7f7f\", // Ephemeral\n    \"c3c3c3\"  // Other\n  ]\n};\n\nMap.addLayer(transition, transVis, 'Water Transitions');\n</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/2.%20Exploring%20GSW%20Dataset/#summary-table-of-gsw-bands","title":"\ud83d\udcda Summary Table of GSW Bands","text":"Band Name Description Values <code>occurrence</code> Water presence frequency 0 - 100 (%) <code>change_abs</code> Change in occurrence intensity -100 to 100 <code>seasonality</code> Number of months water is present 0 - 12 <code>max_extent</code> Any pixel ever detected as water 0 (no) or 1 (yes) <code>transition</code> Changes in water class types Categorical (0-10) <p>Data Source: JRC Global Surface Water</p>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20Surface%20Area%20Charting/","title":"Water Surface Area Charting","text":"<p>Learn how to calculate the total surface area of water bodies over time using Sentinel-2 satellite imagery and NDWI (Normalized Difference Water Index).</p>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20Surface%20Area%20Charting/#the-analysis-workflow","title":"\ud83d\udee0\ufe0f The Analysis Workflow","text":"<pre><code>graph TD\n    A[Sentinel-2 Collection] --&gt; B[Filter: Date, Bounds, Clouds]\n    B --&gt; C[Calculate NDWI Band]\n    C --&gt; D[Apply Threshold &gt; 0.15]\n    D --&gt; E[Calculate Area per Pixel]\n    E --&gt; F[Sum Area via reduceRegion]\n    F --&gt; G[Generate Time-Series Chart]\n    style G fill:#6bf,stroke:#333</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20Surface%20Area%20Charting/#1-setup-and-filtering","title":"\ud83d\udef0\ufe0f 1. Setup and Filtering","text":"<p>We start by loading the Sentinel-2 collection and filtering for a specific study area and time range.</p> <pre><code>// Define Study Area (Polygon)\nvar studyArea = ee.Geometry.Polygon([\n  [[85.76, 20.52], [85.76, 20.41], [85.95, 20.41], [85.95, 20.52]]\n]);\n\n// Load Sentinel-2 Collection\nvar S2 = ee.ImageCollection(\"COPERNICUS/S2_SR\");\n\n// Filter for 2020-2021, Study Area, and &lt;30% Clouds\nvar filtered = S2.filterDate('2020-10-01', '2021-06-01')\n                 .filterBounds(studyArea)\n                 .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30));\n\nMap.centerObject(studyArea, 12);\n</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20Surface%20Area%20Charting/#2-calculating-ndwi","title":"\ud83d\udca7 2. Calculating NDWI","text":"<p>NDWI is calculated using the Green (<code>B3</code>) and NIR (<code>B8</code>) bands. It highlights water bodies by exploiting their high reflectance in green and high absorption in NIR.</p> <pre><code>// Function to add NDWI band\nvar addNDWI = function(image) {\n  var ndwi = image.normalizedDifference(['B3', 'B8']).rename('ndwi');\n  return image.addBands(ndwi);\n};\n\nvar withNDWI = filtered.map(addNDWI);\n</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20Surface%20Area%20Charting/#3-calculating-water-area-km2","title":"\ud83d\udccf 3. Calculating Water Area (km\u00b2)","text":"<p>We iterate through the collection, masking out non-water pixels and summing the area of the remaining water pixels.</p> <pre><code>var ndwiThreshold = 0.15;\n\nvar calculateArea = function(image) {\n  // Create water mask\n  var waterMask = image.select('ndwi').gte(ndwiThreshold);\n\n  // Calculate area of each pixel in sq. meters\n  var pixelArea = ee.Image.pixelArea();\n  var waterPixels = pixelArea.updateMask(waterMask);\n\n  // Sum pixels in the study area\n  var stats = waterPixels.reduceRegion({\n    reducer: ee.Reducer.sum(),\n    geometry: studyArea,\n    scale: 10,\n    maxPixels: 1e8,\n    bestEffort: true\n  });\n\n  // Convert to km\u00b2 and add as a property\n  var areaKm2 = ee.Number(stats.get('area')).divide(1e6);\n  return image.set('waterspreadarea', areaKm2);\n};\n\nvar areaSeries = withNDWI.map(calculateArea);\n</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20Surface%20Area%20Charting/#4-visualizing-the-results","title":"\ud83d\udcca 4. Visualizing the Results","text":"<p>Finally, we print a chart showing the water area fluctuation over time.</p> <pre><code>var chart = ui.Chart.image.series({\n  imageCollection: areaSeries,\n  region: studyArea,\n  reducer: ee.Reducer.mean(),\n  scale: 10,\n  xProperty: 'system:time_start'\n})\n.setSeriesNames(['Area (km\u00b2)'])\n.setOptions({\n  title: 'Water Spread Area Trend',\n  hAxis: {title: 'Date'},\n  vAxis: {title: 'Area (sq. km)'},\n  lineWidth: 2,\n  pointSize: 4,\n  series: {0: {color: 'blue'}}\n});\n\nprint(chart);\n</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20Surface%20Area%20Charting/#pro-tips","title":"\ud83d\udca1 Pro Tips","text":"<ol> <li>Cloud Masks: For better accuracy during monsoon seasons, implement an automated cloud masking function (using the <code>QA60</code> band).</li> <li>Thresholding: The threshold <code>0.15</code> is a starting point. Adjust it based on the turbidity and depth of the water in your specific region.</li> <li>Visualization: Always add a layer to the map to visually verify that your <code>waterMask</code> is correctly capturing the water bodies.</li> </ol> <p>View Code in GEE Editor</p>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20pdf/","title":"3. Water pdf","text":""},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20pdf/#water-surface-area-charting","title":"Water Surface Area Charting","text":""},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20pdf/#httpscodeearthenginegooglecoin9e82406b1579173e08c89a7996133dba","title":"https://code.earthengine.google.co.in/9e82406b1579173e08c89a7996133dba","text":"<p>This script is using Google Earth Engine (GEE) to analyze the water spread area in Study Area, using Sentinel-2 imagery. </p>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20pdf/#step-by-step-explanation-of-the-code","title":"Step-by-step Explanation of the Code:","text":""},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20pdf/#1-defining-the-region-of-interest-roi-and-satellite-data","title":"1. Defining the Region of Interest (ROI) and Satellite Data","text":"<p><pre><code>var studyArea = \n    ee.Geometry.Polygon(\n        [[[85.76361517120263, 20.52393128133101],\n          [85.76361517120263, 20.41553715846105],\n          [85.95621923614404, 20.41553715846105],\n          [85.95621923614404, 20.52393128133101]]], null, false);\nvar S2 = ee.ImageCollection(\"COPERNICUS/S2_SR\");\n</code></pre> *   <code>studyArea</code> is the FeatureCollection for the study area, which represents the geographic area of interest (ROI). *   <code>S2</code> refers to the Sentinel-2 Surface Reflectance (SR) ImageCollection, which provides satellite images from the Sentinel-2 mission.</p>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20pdf/#2-filtering-the-image-collection","title":"2. Filtering the Image Collection","text":"<pre><code>var S2filtered = S2.filterDate('2020-10-01', '2021-06-01')\n                   .filterBounds(studyArea)\n                   .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE',30));\n</code></pre> <ul> <li>This line filters the Sentinel-2 image collection to only include images from October 1, 2020, to June 1, 2021.</li> <li>It also filters for images that cover the study area  (<code>filterBounds(studyArea)</code>).</li> <li>Additionally, it selects only those images with less than 30% cloud coverage (<code>CLOUDY_PIXEL_PERCENTAGE</code>).</li> </ul>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20pdf/#3-adding-ndwi-band-to-the-images","title":"3. Adding NDWI Band to the Images","text":"<p><pre><code>var addNDWI = function(inputImage) {\n  var ndwi = inputImage.normalizedDifference(['B3','B8']).rename('ndwi');\n  return inputImage.addBands(ndwi); \n};\nvar imagesWithNDWI = S2filtered.map(addNDWI);\n</code></pre> *   The NDWI (Normalized Difference Water Index) is calculated using the Green (B3) and Near-Infrared (B8) bands of Sentinel-2. *   This function adds the NDWI as a new band to each image in the filtered collection. *   <code>normalizedDifference(['B3','B8'])</code> computes the NDWI, where water bodies typically have higher values.</p>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20pdf/#4-calculating-water-area-in-the-region-of-interest","title":"4. Calculating Water Area in the Region of Interest","text":"<pre><code>var waterAr = function(inputImage) {\n  var waterMask = inputImage.select('ndwi').gte(ndwiThreshold);\n  var pixelArea = ee.Image.pixelArea();\n  var waterpixels = pixelArea.updateMask(waterMask);\n  var waterArea = waterpixels.reduceRegion({\n    reducer: ee.Reducer.sum(),\n    geometry: studyArea,\n    crs: inputImage.select('B3').projection(),  \n    maxPixels: 1e8,\n    bestEffort: true\n  });\n  var areaImage = ee.Image(waterArea.getNumber('area').divide(1e6)).rename('waterspreadarea'); \n  return inputImage.addBands(areaImage);\n};\nvar areaSeries = imagesWithNDWI.map(waterAr);\n</code></pre> <ul> <li><code>waterMask</code> creates a binary mask where NDWI values greater than or equal to 0.15 are considered water pixels (indicating areas with water bodies).</li> <li><code>pixelArea</code> calculates the area of each pixel.</li> <li><code>waterArea</code> sums up the pixel areas where water is detected (using <code>reduceRegion</code>) and returns the total water area for each image in square meters.</li> <li>The water area is then converted from square meters to square kilometers and added as a new band called <code>waterspreadarea</code>.</li> </ul>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20pdf/#5-creating-a-time-series-chart","title":"5. Creating a Time Series Chart","text":"<pre><code>var title = {\n  title: 'Water Spread Area in studyArea (Sq.km)',\n  hAxis: {title: 'Time'},\n  vAxis: {title: 'Water Spread Area'},\n};\nvar chart = ui.Chart.image.seriesByRegion(areaSeries,studyArea, ee.Reducer.mean(), 'waterspreadarea', 10, 'system:time_start',' ')\n.setChartType('ColumnChart') //set chart type\n .setOptions(title); //set chart options\nprint(chart);\n</code></pre> <ul> <li><code>areaSeries</code> is a time series of images with the water spread area for each image.</li> <li>The chart is created using <code>ui.Chart.image.seriesByRegion</code>, which plots the water spread area (in square kilometers) over time (using <code>system:time_start</code> as the time axis).</li> <li>The chart is configured to display as a ColumnChart, with appropriate axis labels for time and water spread area.</li> </ul>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/3.%20Water%20pdf/#6-challenges-with-cloud-cover","title":"6. Challenges with Cloud Cover","text":"<p>The comment in the code: <pre><code>// Due to cloud cover especially during monsoon period water spread area values may not be representative\n</code></pre> </p> <p>Made by Pulakesh Pradhan</p>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/4.%20Flood%20Mapping/","title":"Flood Mapping with Sentinel-1 Radar","text":"<p>Radar data (SAR) from Sentinel-1 is the primary tool for flood mapping because it can \"see\" through clouds and works even at night.</p>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/4.%20Flood%20Mapping/#why-use-sentinel-1","title":"\ud83d\udef0\ufe0f Why use Sentinel-1?","text":"Feature Advantage for Floods Active Sensor Operates at night C-Band Radar Penetrates clouds and smoke Backscatter Water reflects radar away (looks black) High Frequency 6-12 day revisit time"},{"location":"gee/Projects/1.Water%20Body%20Mapping/4.%20Flood%20Mapping/#the-flood-detection-workflow","title":"\ud83d\udee0\ufe0f The Flood Detection Workflow","text":"<pre><code>graph LR\n    A[Before Flood Image] -- min --&gt; B[Reference Map]\n    C[After Flood Image] -- min --&gt; D[Flood Map]\n    B &amp; D -- Thresholding --&gt; E[Change Detection]\n    E -- mask --&gt; F[Final Flood Inundation]\n    style F fill:#f66,stroke:#333</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/4.%20Flood%20Mapping/#code-implementation","title":"\ud83d\udcbb Code Implementation","text":"<p>We compare radar backscatter between a \"dry\" date and a \"wet\" date.</p> <pre><code>// 1. Define Dates\nvar preFloodDate = ee.Date('2023-05-15');\nvar postFloodDate = ee.Date('2023-07-09');\n\n// 2. Select polarization (VV is best for water)\nvar polarization = 'VV';\n\n// 3. Load Images\nvar preFlood = ee.ImageCollection('COPERNICUS/S1_GRD')\n    .filterDate(preFloodDate, preFloodDate.advance(1, 'week'))\n    .filter(ee.Filter.listContains('transmitterReceiverPolarisation', polarization))\n    .filter(ee.Filter.eq('instrumentMode', 'IW'))\n    .select(polarization)\n    .min();\n\nvar postFlood = ee.ImageCollection('COPERNICUS/S1_GRD')\n    .filterDate(postFloodDate, postFloodDate.advance(1, 'week'))\n    .filter(ee.Filter.listContains('transmitterReceiverPolarisation', polarization))\n    .filter(ee.Filter.eq('instrumentMode', 'IW'))\n    .select(polarization)\n    .min();\n\n// 4. Remove permanent water to find NEW floods\nvar permanentWater = ee.ImageCollection('GLCF/GLS_WATER')\n    .select('water')\n    .mean()\n    .neq(2);\n\nvar preFloodMasked = preFlood.updateMask(permanentWater);\nvar postFloodMasked = postFlood.updateMask(permanentWater);\n\n// 5. Visualize\nMap.centerObject(ee.Geometry.Point([77.2, 28.7]), 12); // Delhi Region\n\nMap.addLayer(preFloodMasked, {min: -25, max: -5}, 'Pre-Flood (Dry)');\nMap.addLayer(postFloodMasked, {min: -25, max: -5}, 'Post-Flood (Wet)');\n\n// 6. Simple Threshold Change Detection\nvar flooded = postFloodMasked.lt(-18).and(preFloodMasked.gt(-18));\nMap.addLayer(flooded.selfMask(), {palette: ['red']}, 'Potential Flood Area');\n</code></pre>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/4.%20Flood%20Mapping/#interpreting-radar-backscatter","title":"\ud83d\udcc9 Interpreting Radar Backscatter","text":"<p>In radar imagery, smooth surfaces (like calm water) act like a mirror, reflecting signals away from the satellite. This results in very low backscatter (dark pixels). When a dry field becomes flooded, its backscatter value drops significantly (e.g., from -10dB to -20dB).</p>"},{"location":"gee/Projects/1.Water%20Body%20Mapping/4.%20Flood%20Mapping/#important-considerations","title":"\u26a0\ufe0f Important Considerations","text":"<ol> <li>Urban Floods: Radar often struggles in cities due to \"double-bounce\" reflections off buildings.</li> <li>Wind/Waves: Rough water surfaces can look \"bright\" on radar, potentially hiding floods.</li> <li>Vegetation: Flooded forests can actually look brighter due to the interaction between the water and tree trunks.</li> </ol>"},{"location":"gee/Projects/2.%20Water%20Quality/1.%20Chlorophyll%20Mapping/","title":"\ud83c\udf43 Chlorophyll-a Mapping (Water Quality)","text":"<p>Monitoring lake health by assessing Chlorophyll-a concentration using Sentinel-2 multispectral data.</p>"},{"location":"gee/Projects/2.%20Water%20Quality/1.%20Chlorophyll%20Mapping/#scientific-basis","title":"\ud83d\udd2c Scientific Basis","text":"<p>Chlorophyll-a is a pigment found in algae and phytoplankton. High concentrations often indicate eutrophication (excess nutrients). We can estimate it by measuring the reflectance in the Red Edge and Red bands.</p> <pre><code>graph LR\n    A[Sentinel-2] --&gt; B[Calculate NDWI]\n    B --&gt; C[Mask Land/Cloud]\n    A --&gt; D[Band Ratio B5/B4]\n    D --&gt; E[Empirical Formula]\n    E --&gt; F[Chlorophyll Concentration]\n    style F fill:#9f9,stroke:#333</code></pre>"},{"location":"gee/Projects/2.%20Water%20Quality/1.%20Chlorophyll%20Mapping/#implementation","title":"\ud83d\udcbb Implementation","text":"<p>The following script calculates Chlorophyll-a (mg/m\u00b3) for a water body.</p> <pre><code>// 1. Define Area of Interest (Ujani Dam, India)\nvar aoi = ee.Geometry.Point([75.1, 18.2]);\n\n// 2. Load Sentinel-2 and Create Cloud-free Composite\nvar s2 = ee.ImageCollection('COPERNICUS/S2_HARMONIZED')\n                   .filterBounds(aoi)\n                   .filterDate('2024-01-01', '2024-01-30')\n                   .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n                   .median();\n\n// 3. Mask Water only (NDWI &gt; 0)\nvar ndwi = s2.normalizedDifference(['B3', 'B8']).rename('NDWI');\nvar s2_water = s2.updateMask(ndwi.gt(0));\n\n// 4. Chlorophyll-a Formula (Gilerson et al., 2010 approximation)\n// Index = (B5 - B4) / (B5 + B4)\nvar chla = s2_water.expression(\n  '693 * ((B5 - B4) / (B5 + B4)) + 40', {\n    'B5': s2_water.select('B5'),  // Red Edge 1 (705nm)\n    'B4': s2_water.select('B4')   // Red (665nm)\n  }).rename('Chlorophyll_a');\n\n// 5. Visualize Results\nMap.centerObject(aoi, 11);\nMap.addLayer(s2.select(['B4','B3','B2']), {min:0, max:3000}, 'Natural Color');\nMap.addLayer(chla, {min: 0, max: 25, palette: ['blue','cyan','yellow','green','red']}, 'Chlorophyll-a (mg/m\u00b3)');\n</code></pre>"},{"location":"gee/Projects/2.%20Water%20Quality/1.%20Chlorophyll%20Mapping/#how-to-interpret","title":"\ud83d\udcca How to Interpret","text":"Concentration Status Indicator 0 - 5 mg/m\u00b3 Oligotrophic High water clarity, low nutrients 5 - 10 mg/m\u00b3 Mesotrophic Moderate nutrients, good health &gt; 10 mg/m\u00b3 Eutrophic High algae levels, potentially low oxygen &gt; 30 mg/m\u00b3 Hypertrophic Severe pollution/algae blooms"},{"location":"gee/Projects/2.%20Water%20Quality/1.%20Chlorophyll%20Mapping/#limitations","title":"\u26a0\ufe0f Limitations","text":"<ol> <li>Optical Depth: In very turbid water, suspended sediments (mud) can interfere with the signal.</li> <li>Algorithm Tuning: The coefficients (<code>693</code> and <code>40</code>) are generic. For high-accuracy research, these should be calibrated with ground-truth water samples.</li> </ol>"},{"location":"gee/Projects/3.%20Susceptibility/1.%20Landslide/","title":"\ud83c\udf0b Landslide Susceptibility Mapping","text":"<p>Using Digital Elevation Models (DEM) and multi-spectral data to identify areas prone to landslides.</p>"},{"location":"gee/Projects/3.%20Susceptibility/1.%20Landslide/#factors-for-susceptibility","title":"\ud83c\udfd7\ufe0f Factors for Susceptibility","text":"<p>A landslide isn't caused by one thing, but a combination of factors:</p> <pre><code>graph TD\n    A[Elevation/Slope] --&gt; D[Susceptibility Model]\n    B[Aspect/Topographic Wetness] --&gt; D\n    C[Land Cover/NDVI] --&gt; D\n    D --&gt; E[Risk Map]\n    style E fill:#f96,stroke:#333</code></pre>"},{"location":"gee/Projects/3.%20Susceptibility/1.%20Landslide/#1-terrain-analysis-the-fundamentals","title":"\ud83d\udcbb 1. Terrain Analysis (The Fundamentals)","text":"<p>The most important factor is Slope. If the land is steep, it's more likely to slide.</p> <pre><code>// 1. Load SRTM Elevation Data\nvar srtm = ee.Image(\"USGS/SRTMGL1_003\");\n\n// 2. Calculate Slope and Aspect\nvar slope = ee.Terrain.slope(srtm);\nvar aspect = ee.Terrain.aspect(srtm);\n\n// 3. Select High-Risk Slopes (&gt;30 degrees)\nvar highRiskSlope = slope.gt(30);\n\nMap.addLayer(slope, {min: 0, max: 45, palette: ['white', 'red']}, 'Slope Intensity');\nMap.addLayer(highRiskSlope.selfMask(), {palette: ['darkred']}, 'High Slope Risk (&gt;30\u00b0)');\n</code></pre>"},{"location":"gee/Projects/3.%20Susceptibility/1.%20Landslide/#2-integrating-vegetation-ndvi","title":"\ud83d\udcbb 2. Integrating Vegetation (NDVI)","text":"<p>Vegetation roots stabilize the soil. Areas with steep slopes AND low vegetation are the most dangerous.</p> <pre><code>// 4. Load Sentinel-2 for Vegetation\nvar s2 = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\")\n  .filterDate('2023-01-01', '2023-12-31')\n  .median();\n\nvar ndvi = s2.normalizedDifference(['B8', 'B4']).rename('NDVI');\n\n// 5. Combined Risk: High Slope AND Low NDVI\nvar riskMap = slope.gt(25).and(ndvi.lt(0.3));\n\nMap.addLayer(riskMap.selfMask(), {palette: ['purple']}, 'Combined Landslide Risk');\n</code></pre>"},{"location":"gee/Projects/3.%20Susceptibility/1.%20Landslide/#summary-of-factors","title":"\ud83d\udcca Summary of Factors","text":"Factor High Risk Condition Why? Slope &gt; 25 degrees Gravity pulls soil down steep inclines Vegetation NDVI &lt; 0.2 Lack of roots to hold soil together Hydrology High TWI Saturated soil is heavier and more fluid Lithology Weathered Rock Soft material slides easier than bedrock"},{"location":"gee/Projects/3.%20Susceptibility/2.%20Flood/","title":"\ud83c\udf0a Flood Susceptibility Mapping","text":"<p>Identifying areas at risk of flooding based on geography and historic data. Unlike real-time flood mapping, this helps with long-term planning.</p>"},{"location":"gee/Projects/3.%20Susceptibility/2.%20Flood/#key-risk-factors","title":"\ud83d\udcc8 Key Risk Factors","text":"<p>Flood risk is defined by where water wants to go (low elevation) and where it can't drain (saturated soil, urban surfaces).</p> <pre><code>graph LR\n    A[DEM/Elevation] -- Low --&gt; C[Accumulation]\n    B[Distance to River] -- Short --&gt; C\n    D[Land Cover/Built-up] -- Impervious --&gt; E[Runoff]\n    C &amp; E --&gt; F[Flood Risk Score]\n    style F fill:#6af,stroke:#333</code></pre>"},{"location":"gee/Projects/3.%20Susceptibility/2.%20Flood/#1-distance-from-rivers","title":"\ud83d\udcbb 1. Distance from Rivers","text":"<p>Being close to a river is the most obvious risk factor.</p> <pre><code>// 1. Load River Data (WWF Free-flowing rivers)\nvar rivers = ee.FeatureCollection(\"projects/sat-io/open-datasets/GRWL/water_mask_v1_01\");\n\n// 2. Create Distance Buffer (e.g., 500m)\nvar riverBuffer = rivers.distance({searchRadius: 1000, maxError: 50});\n\nMap.addLayer(riverBuffer, {min: 0, max: 1000, palette: ['blue', 'white']}, 'Proximity to Water');\n</code></pre>"},{"location":"gee/Projects/3.%20Susceptibility/2.%20Flood/#2-height-above-nearest-drainage-hand","title":"\ud83d\udcbb 2. Height Above Nearest Drainage (HAND)","text":"<p>A simple elevation check isn't enough\u2014you need to know how high you are relative to the nearest stream.</p> <pre><code>// 3. Load Merit Hydro (Global Hydrography)\n// This dataset includes HAND which is a great proxy for flood risk\nvar hand = ee.Image(\"MERIT/Hydro/v1_0_1\").select('hand');\n\n// 4. Areas less than 5m above drainage are high risk\nvar floodPlains = hand.lt(5);\n\nMap.addLayer(hand, {min: 0, max: 20}, 'HAND Elevation', false);\nMap.addLayer(floodPlains.selfMask(), {palette: ['cyan']}, 'Flood Plain Susceptibility (&lt;5m)');\n</code></pre>"},{"location":"gee/Projects/3.%20Susceptibility/2.%20Flood/#3-integrating-impervious-surfaces-urban","title":"\ud83d\udcbb 3. Integrating Impervious Surfaces (Urban)","text":"<p>Cities flood more because concrete doesn't absorb water.</p> <pre><code>// 5. Load Global Human Settlement Layer\nvar ghsl = ee.ImageCollection(\"JRC/GHSL/P2023A/GHS_BUILT_S\").filterDate('2020-01-01').first();\n\n// 6. Combine: Low relative elevation AND Urban area\nvar urbanFloodRisk = hand.lt(5).and(ghsl.gt(20));\n\nMap.addLayer(urbanFloodRisk.selfMask(), {palette: ['red']}, 'Urban Flood Susceptibility');\n</code></pre>"},{"location":"gee/Projects/3.%20Susceptibility/2.%20Flood/#susceptibility-matrix","title":"\ud83d\uddfa\ufe0f Susceptibility Matrix","text":"Elevation (HAND) Land Cover Risk Level &lt; 2m Any CRITICAL 2m - 5m Urban HIGH 2m - 5m Forest LOW &gt; 10m Any NEGLIGIBLE"},{"location":"gee/Projects/Collection/Dem/","title":"Dem","text":"<p>```javascript</p> <p>var cor = [   [48.646401641929856,35.98889945187288],   [50.211953399742356,35.98889945187288],   [50.211953399742356,37.15353368743586],   [48.646401641929856,37.15353368743586],   [48.646401641929856,35.98889945187288]   ]</p> <p>var roi = ee.Geometry.Polygon(cor)</p> <p>Map.centerObject(roi);</p> <p>var srtm = image.select('elevation');</p> <p>Map.addLayer(srtm.clip(roi),[],'dem30',false)</p> <p>print(   ui.Chart.image.histogram(srtm,roi,100)   )</p> <p>var slope = ee.Terrain.slope(srtm);</p> <p>Map.addLayer(slope.clip(roi),[],'slope', false);</p> <p>var aspect = ee.Terrain.aspect(srtm);</p> <p>Map.addLayer(aspect.clip(roi),[],'aspect',false);</p> <p>var product = ee.Terrain.products(srtm);</p> <p>print(product);</p> <p>Export.image.toDrive({   image: product.clip(roi).float(),   description: 'dem_product',   scale: 30,   region: roi,   crs: product.getInfo().crs,   folder: 'dem',   maxPixels: 1e13   })</p> <p>// </p> <p>var alos = imageCollection.select('DSM').mean()</p> <p>print(   ui.Chart.image.histogram(alos, roi, 100)   )</p>"},{"location":"gee/Projects/Collection/Lake%20Area%20Estimation/","title":"Lake Area Estimation","text":"<p>```javascript /* Tutorial Code by Amirhossein Ahrari YouTube: https://www.youtube.com/@amirhosseinahrarigee</p> <p>This code is part of a tutorial series on Earth Engine programming techniques presented on the Amirhossein Ahrari YouTube channel. You are free to use and modify this code for academic and non-academic purposes. Don't forget to subscribe to the Amirhossein Ahrari channel and follow the videos to support the instructor! */</p> <p>var coordinates = [   [42.000552219688586, 38.18969302118053],   [43.868228000938586, 38.18969302118053],   [43.868228000938586, 39.209978258633186],   [42.000552219688586, 39.209978258633186],   [42.000552219688586, 38.18969302118053] ];</p> <p>var roi = ee.Geometry.Polygon(coordinates);</p> <p>Map.addLayer(roi)</p> <p>var time_start = '2013', time_end = '2021'</p> <p>var landsat = imageCollection .filterDate(time_start, time_end) .filter(ee.Filter.lt('CLOUD_COVER', 10)) .filter(ee.Filter.calendarRange(6,9,'month')) .filterBounds(geometry).map(function(img){   var bands = img.select('SR_.*').multiply(2.75e-05).add(-0.2);   var ndwi = bands.normalizedDifference(['SR_B3','SR_B5']).rename('ndwi');   return ndwi   .copyProperties(img, img.propertyNames())   }).median();</p> <p>Map.addLayer(landsat.clip(geometry), [], 'ndwi_summer', false); Map.addLayer(landsat.clip(geometry).gt(0), [], 'ndwi_thr', false);</p> <p>var thr = landsat.gt(0.1); var mask = thr.updateMask(thr);</p> <p>Map.addLayer(mask, [], 'ndwi_masked', false);</p> <p>var pixel_area = mask.multiply(ee.Image.pixelArea().divide(1e6));</p> <p>Map.addLayer(pixel_area.clip(geometry), [], 'ndwi_pixel_area', false);</p> <p>var lake_area = pixel_area.reduceRegion({   reducer: ee.Reducer.sum(), geometry: geometry, scale: 100   }).values().get(0);</p> <p>print(ee.Number(lake_area))</p>"},{"location":"gee/Projects/Collection/Lake%20Area%20Monitoring/","title":"Lake Area Monitoring","text":"<p>```javascript var cor = [[44.82021271860131,37.08040466447922],            [46.11659943735131,37.08040466447922],            [46.11659943735131,38.37506300104177],            [44.82021271860131,38.37506300104177],            [44.82021271860131,37.08040466447922]             ]</p> <p>var roi = ee.Geometry.Polygon(cor)</p> <p>Map.addLayer(roi) Map.centerObject(roi)</p> <p>var time_start = '2001', time_end = '2023'</p> <p>var modis = ee.ImageCollection(\"MODIS/061/MOD09A1\") .filterDate(time_start, time_end);</p> <p>var ndwi = modis.map(function(img){   var band = img.select('sur.*').multiply(0.0001);   var index = band.normalizedDifference(['sur_refl_b04','sur_refl_b02']).rename('ndwi');   return index   .copyProperties(img, img.propertyNames())   });</p> <p>Map.addLayer(ndwi.filterDate('2010','2011').toBands().clip(roi), [],'ndwi', false);</p> <p>var ndwi_average = ndwi.filterDate('2010', '2011').median();</p> <p>print(   ui.Chart.image.histogram(ndwi_average, roi, 500)   )</p> <p>var lake_area = ndwi.map(function(img){   var thr = img.gt(0.1)   var mask = thr.updateMask(thr);   var area = mask.multiply(ee.Image.pixelArea().divide(1e6));   return area   .copyProperties(img, img.propertyNames())   });</p> <p>print(   ui.Chart.image.series(lake_area, roi, ee.Reducer.sum(),   500, 'system:time_start')   )</p>"},{"location":"gee/Projects/Collection/Precipitation%20Anomaly/","title":"Precipitation Anomaly","text":"<p>```javascript</p> <p>var cor = [   [54.04610024292115,36.26824729036319],   [56.30928383667115,36.26824729036319],   [56.30928383667115,37.7942120428063],   [54.04610024292115,37.7942120428063],   [54.04610024292115,36.26824729036319]   ]</p> <p>var roi = ee.Geometry.MultiPolygon(cor);</p> <p>Map.addLayer(roi)</p> <p>var time_start = '2000', time_end = '2020'</p> <p>var chirps = ee.ImageCollection(\"UCSB-CHG/CHIRPS/DAILY\") .filterDate(time_start, time_end);</p> <p>function temporal_collection(collection, start, count, interval, unit){   var seq = ee.List.sequence(0, ee.Number(count).subtract(1));   var origin_date = ee.Date(start);   return ee.ImageCollection(seq.map(function(i){     var start_date = origin_date.advance(ee.Number(interval).multiply(i), unit);     var end_date = origin_date.advance(ee.Number(interval).multiply(ee.Number(i).add(1)), unit);     return collection.filterDate(start_date, end_date).sum()     .set('system:time_start', start_date.millis())     .set('system:time_end', end_date.millis())     }))   }</p> <p>var monthly = temporal_collection(chirps, time_start, 240, 1, 'month');</p> <p>var pr_mean = monthly.mean();</p> <p>Map.addLayer(pr_mean.clip(roi),[],'pr_mean', false);</p> <p>var anomaly = monthly.map(function(img){   return img.subtract(pr_mean)   .copyProperties(img, img.propertyNames())   });</p> <p>print(   ui.Chart.image.series(anomaly, roi, ee.Reducer.mean(),   5000, 'system:time_start').setChartType('ColumnChart')   )</p> <p>Map.addLayer(anomaly.filterDate('2010','2011').toBands().clip(roi),[],'anomaly2010', false)</p> <p>Export.image.toDrive({   image: anomaly.filterDate('2010','2011').toBands().clip(roi).float(),   description: 'pr_anomaly2010',    scale: 5000,    region: roi,    folder: 'precipitatoin',   crs: 'EPSG:4326',   })</p>"},{"location":"gee/Projects/Collection/Precipitation%20Dry%20Wet%20Days/","title":"Precipitation Dry Wet Days","text":"<p>```javascript</p> <p>var cor = [   [52.44694261887793,36.17836425046897],   [53.04020433762793,36.17836425046897],   [53.04020433762793,36.61168836568063],   [52.44694261887793,36.61168836568063],   [52.44694261887793,36.17836425046897]   ]</p> <p>var roi = ee.Geometry.Polygon(cor);</p> <p>Map.centerObject(roi);</p> <p>var time_start = '2010' , time_end = '2020' </p> <p>var pr = imageCollection .filterDate(time_start, time_end);</p> <p>function pr_class(img){   var pr_mean = img.reduceRegion({     reducer: ee.Reducer.mean(), geometry: roi, scale: 27000     }).values().get(0);     var pr_max = img.reduceRegion({     reducer: ee.Reducer.max(), geometry: roi, scale: 27000     }).values().get(0);   return img   .copyProperties(img, img.propertyNames())   .set('pr_mean', pr_mean)   .set('pr_max', pr_max)   }</p> <p>var pr_values = pr.map(pr_class);</p> <p>var dry = pr_values .filter(ee.Filter.lt('pr_mean',0.5));</p> <p>print(   ui.Chart.image.series(dry, roi, ee.Reducer.mean(),    27000, 'system:time_start').setChartType('ColumnChart')   )</p> <p>var wet = pr_values.filter(ee.Filter.gt('pr_mean',1));</p> <p>print(   ui.Chart.image.series(wet, roi, ee.Reducer.mean(),   270000, 'system:time_start').setChartType('ColumnChart')   )</p> <p>var mid = pr_values .filter(ee.Filter.gte('pr_mean',0.5)) .filter(ee.Filter.lte('pr_mean', 1));</p> <p>print(mid.aggregate_array('pr_mean'))</p>"},{"location":"gee/Projects/Collection/Temperature%20Percentage%20Change/","title":"Temperature Percentage Change","text":"<p>```javascript</p> <p>var cor = [   [-106.362109375,36.957529497279594],   [-101.528125,36.957529497279594],   [-101.528125,40.5210649481601],   [-106.362109375,40.5210649481601],   [-106.362109375,36.957529497279594]   ]</p> <p>var roi = ee.Geometry.Polygon(cor)</p> <p>Map.centerObject(roi)</p> <p>var time_start = '1950', time_end = '2020'</p> <p>var era5 = ee.ImageCollection(\"ECMWF/ERA5_LAND/MONTHLY_AGGR\") .select('temperature_2m') .filterDate(time_start, time_end);</p> <p>function temporal_collection(collection, start, count, interval, unit){   var seq = ee.List.sequence(0, ee.Number(count).subtract(1));   var origin_date = ee.Date(start);   return ee.ImageCollection(seq.map(function(i){     var start_date = origin_date.advance(ee.Number(interval).multiply(i), unit);     var end_date = origin_date.advance(ee.Number(interval).multiply(ee.Number(i).add(1)), unit);     return collection.filterDate(start_date, end_date).mean()     .set('system:time_start', start_date.millis())     .set('system:time_end', end_date.millis())     }))   }</p> <p>var annual = temporal_collection(era5, time_start, 70, 1, 'year') .map(function(img){   return img.subtract(273.15)   .copyProperties(img, img.propertyNames())   });</p> <p>print(   ui.Chart.image.series(annual, roi, ee.Reducer.mean(), 10000, 'system:time_start')   )</p> <p>// get the percent of changes</p> <p>var temp_mean = annual.mean();</p> <p>// eq = ((temp - mean)/(mean)) * 100</p> <p>var change = annual.map(function(img){   var eq = img.expression('((temp - mean)/(mean)) * 100',{     'temp': img, 'mean': temp_mean     }).rename('temp_change');   return eq   .copyProperties(img, img.propertyNames())   })</p> <p>print(   ui.Chart.image.series(change, roi, ee.Reducer.mean(),   10000, 'system:time_start').setChartType('ColumnChart')</p> <p>)</p>"},{"location":"gee/Tutoring/charts/","title":"Charts in Google Earth Engine","text":""},{"location":"gee/Tutoring/charts/#1-image-based-charts","title":"1. Image-Based Charts","text":""},{"location":"gee/Tutoring/charts/#time-series-analysis","title":"Time Series Analysis","text":"<ul> <li><code>ui.Chart.image.series</code>: Single region over time</li> <li><code>ui.Chart.image.seriesByRegion</code>: Multiple regions over time</li> <li><code>ui.Chart.image.doySeries</code>: Day-of-year patterns for single region</li> <li><code>ui.Chart.image.doySeriesByYear</code>: Compare years for single region</li> <li><code>ui.Chart.image.doySeriesByRegion</code>: Day-of-year patterns across regions</li> </ul>"},{"location":"gee/Tutoring/charts/#general-parameters","title":"General Parameters","text":"<ul> <li><code>scale</code>: Spatial resolution in meters</li> <li><code>reducer</code>: Function for aggregating pixel values (e.g., mean, max, min)</li> <li><code>region/regions</code>: Area(s) of interest for analysis</li> <li><code>xProperty</code>: Property for x-axis values</li> <li><code>seriesProperty</code>: Property for distinguishing multiple series</li> </ul>"},{"location":"gee/Tutoring/charts/#customization-options","title":"Customization Options","text":"<p><pre><code>.setOptions({\n  title: 'Chart Title',\n  hAxis: {\n    title: 'X-Axis Label',\n    titleTextStyle: {italic: false, bold: true}\n  },\n  vAxis: {\n    title: 'Y-Axis Label',\n    titleTextStyle: {italic: false, bold: true}\n  },\n  lineWidth: 2,\n  colors: ['hexcolor1', 'hexcolor2'],\n  curveType: 'function'  // for smooth lines\n})\n</code></pre> </p>"},{"location":"gee/Tutoring/charts/#-","title":"---","text":"<p>Made by Pulakesh Pradhan</p>"},{"location":"gee/Tutoring/charts/#1-uichartimageseries","title":"1. <code>ui.Chart.image.series</code>","text":""},{"location":"gee/Tutoring/charts/#description","title":"Description:","text":"<p>This chart shows how vegetation indices (NDVI and EVI) change over time for a specific region, such as a forest. Each image band (NDVI and EVI) is plotted as a unique series. The x-axis represents the time, and the y-axis shows the average vegetation index value.</p>"},{"location":"gee/Tutoring/charts/#code","title":"Code:","text":"<p><pre><code>// Import the example feature collection and subset the forest feature.\nvar forest = ee.FeatureCollection('projects/google/charts_feature_example')\n                 .filter(ee.Filter.eq('label', 'Forest'));\n\n// Load MODIS vegetation indices data and subset a decade of images.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filter(ee.Filter.date('2010-01-01', '2020-01-01'))\n                     .select(['NDVI', 'EVI']);\n\n// Define the chart and print it to the console.\nvar chart = ui.Chart.image.series({\n  imageCollection: vegIndices,\n  region: forest,\n  reducer: ee.Reducer.mean(),\n  scale: 500,\n  xProperty: 'system:time_start'\n})\n.setSeriesNames(['EVI', 'NDVI'])\n.setOptions({\n  title: 'Average Vegetation Index Value by Date for Forest',\n  hAxis: {title: 'Date', titleTextStyle: {italic: false, bold: true}},\n  vAxis: {title: 'Vegetation index (x1e4)', titleTextStyle: {italic: false, bold: true}},\n  lineWidth: 5,\n  colors: ['e37d05', '1d6b99'],\n  curveType: 'function'\n});\nprint(chart);\n</code></pre> </p>"},{"location":"gee/Tutoring/charts/#2-uichartimageseriesbyregion","title":"2. <code>ui.Chart.image.seriesByRegion</code>","text":""},{"location":"gee/Tutoring/charts/#description_1","title":"Description:","text":"<p>This chart compares NDVI values over time for multiple regions, such as forest, desert, and grasslands. Each region is represented as a unique series.</p>"},{"location":"gee/Tutoring/charts/#code_1","title":"Code:","text":"<p><pre><code>// Import the example feature collection.\nvar ecoregions = ee.FeatureCollection('projects/google/charts_feature_example');\n\n// Load MODIS vegetation indices data and subset a decade of images.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filter(ee.Filter.date('2010-01-01', '2020-01-01'))\n                     .select(['NDVI', 'EVI']);\n\n// Define the chart and print it to the console.\nvar chart = ui.Chart.image.seriesByRegion({\n  imageCollection: vegIndices,\n  band: 'NDVI',\n  regions: ecoregions,\n  reducer: ee.Reducer.mean(),\n  scale: 500,\n  seriesProperty: 'label',\n  xProperty: 'system:time_start'\n})\n.setOptions({\n  title: 'Average NDVI Value by Date',\n  hAxis: {title: 'Date', titleTextStyle: {italic: false, bold: true}},\n  vAxis: {title: 'NDVI (x1e4)', titleTextStyle: {italic: false, bold: true}},\n  lineWidth: 5,\n  colors: ['f0af07', '0f8755', '76b349'],\n});\nprint(chart);\n</code></pre> </p>"},{"location":"gee/Tutoring/charts/#3-uichartimagedoyseries","title":"3. <code>ui.Chart.image.doySeries</code>","text":""},{"location":"gee/Tutoring/charts/#description_2","title":"Description:","text":"<p>This chart plots average NDVI and EVI values for each day of the year across multiple years for a single region. For example, it can help identify seasonal vegetation trends in a grassland.</p>"},{"location":"gee/Tutoring/charts/#code_2","title":"Code:","text":"<p><pre><code>// Import the example feature collection and subset the grassland feature.\nvar grassland = ee.FeatureCollection('projects/google/charts_feature_example')\n                    .filter(ee.Filter.eq('label', 'Grassland'));\n\n// Load MODIS vegetation indices data and subset a decade of images.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filter(ee.Filter.date('2010-01-01', '2020-01-01'))\n                     .select(['NDVI', 'EVI']);\n\n// Define the chart and print it to the console.\nvar chart = ui.Chart.image.doySeries({\n  imageCollection: vegIndices,\n  region: grassland,\n  regionReducer: ee.Reducer.mean(),\n  scale: 500,\n  yearReducer: ee.Reducer.mean(),\n  startDay: 1,\n  endDay: 365\n})\n.setSeriesNames(['EVI', 'NDVI'])\n.setOptions({\n  title: 'Average Vegetation Index Value by Day of Year for Grassland',\n  hAxis: {title: 'Day of year', titleTextStyle: {italic: false, bold: true}},\n  vAxis: {title: 'Vegetation index (x1e4)', titleTextStyle: {italic: false, bold: true}},\n  lineWidth: 5,\n  colors: ['e37d05', '1d6b99'],\n});\nprint(chart);\n</code></pre> </p>"},{"location":"gee/Tutoring/charts/#4-uichartimagedoyseriesbyyear","title":"4. <code>ui.Chart.image.doySeriesByYear</code>","text":""},{"location":"gee/Tutoring/charts/#description_3","title":"Description:","text":"<p>This chart compares NDVI trends for a specific region over different years, plotting the average value for each day of the year. Each year\u2019s data is shown as a separate series.</p>"},{"location":"gee/Tutoring/charts/#code_3","title":"Code:","text":"<p><pre><code>// Import the example feature collection and subset the grassland feature.\nvar grassland = ee.FeatureCollection('projects/google/charts_feature_example')\n                    .filter(ee.Filter.eq('label', 'Grassland'));\n\n// Load MODIS vegetation indices data and subset years 2012 and 2019.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filter(ee.Filter.or(\n                         ee.Filter.date('2012-01-01', '2013-01-01'),\n                         ee.Filter.date('2019-01-01', '2020-01-01')))\n                     .select(['NDVI', 'EVI']);\n\n// Define the chart and print it to the console.\nvar chart = ui.Chart.image.doySeriesByYear({\n  imageCollection: vegIndices,\n  bandName: 'NDVI',\n  region: grassland,\n  regionReducer: ee.Reducer.mean(),\n  scale: 500,\n  sameDayReducer: ee.Reducer.mean(),\n  startDay: 1,\n  endDay: 365\n})\n.setOptions({\n  title: 'Average NDVI Value by Day of Year for Grassland',\n  hAxis: {title: 'Day of year', titleTextStyle: {italic: false, bold: true}},\n  vAxis: {title: 'NDVI (x1e4)', titleTextStyle: {italic: false, bold: true}},\n  lineWidth: 5,\n  colors: ['39a8a7', '9c4f97'],\n});\nprint(chart);\n</code></pre> </p>"},{"location":"gee/Tutoring/charts/#5-uichartimagedoyseriesbyregion","title":"5. <code>ui.Chart.image.doySeriesByRegion</code>","text":""},{"location":"gee/Tutoring/charts/#description_4","title":"Description:","text":"<p>This chart compares average NDVI values for different regions (e.g., forest, desert, and grasslands) over a single year. It shows how vegetation varies seasonally across regions.</p>"},{"location":"gee/Tutoring/charts/#code_4","title":"Code:","text":"<p><pre><code>// Import the example feature collection.\nvar ecoregions = ee.FeatureCollection('projects/google/charts_feature_example');\n\n// Load MODIS vegetation indices data and subset a decade of images.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filter(ee.Filter.date('2010-01-01', '2020-01-01'))\n                     .select(['NDVI', 'EVI']);\n\n// Define the chart and print it to the console.\nvar chart = ui.Chart.image.doySeriesByRegion({\n  imageCollection: vegIndices,\n  bandName: 'NDVI',\n  regions: ecoregions,\n  regionReducer: ee.Reducer.mean(),\n  scale: 500,\n  yearReducer: ee.Reducer.mean(),\n  seriesProperty: 'label',\n  startDay: 1,\n  endDay: 365\n})\n.setOptions({\n  title: 'Average NDVI Value by Day of Year',\n  hAxis: {title: 'Day of year', titleTextStyle: {italic: false, bold: true}},\n  vAxis: {title: 'NDVI (x1e4)', titleTextStyle: {italic: false, bold: true}},\n  lineWidth: 5,\n  colors: ['f0af07', '0f8755', '76b349'],\n});\nprint(chart);\n</code></pre> </p> <p>Made by Pulakesh Pradhan</p>"},{"location":"gee/Tutoring/charts/#_1","title":"* * *","text":""},{"location":"gee/Tutoring/exports/","title":"Exports","text":""},{"location":"gee/Tutoring/exports/#export-raster-and-vector-data","title":"Export Raster and Vector Data:","text":"<ol> <li>Raster Export: Export an image (like satellite data) with specific details like resolution (scale), area, and file format.</li> <li>Vector Export: Export shapes (like country boundaries) with specific details.</li> </ol>"},{"location":"gee/Tutoring/exports/#code-with-step-by-step-explanation","title":"Code with Step-by-Step Explanation","text":"<pre><code>// Step 1: Load a raster image (elevation data in this case)\nvar raster = ee.Image('CGIAR/SRTM90_V4'); \n// This is an elevation dataset from GEE. It shows the height of the land.\n\nprint(\"Loaded raster image\", raster); // Print raster details in Console\n\n// Step 2: Load a vector dataset (country boundaries)\nvar vector = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017'); \n// This is a vector dataset showing country boundaries.\n\nprint(\"Loaded vector data\", vector); // Print vector details in Console\n\n// Step 3: Define an area of interest (AOI)\n// This is a rectangular area we want to work on.\nvar aoi = ee.Geometry.Polygon([\n  [[-120.0, 40.0], [-120.0, 35.0], [-115.0, 35.0], [-115.0, 40.0], [-120.0, 40.0]]\n]);\n\nMap.centerObject(aoi); // Center the map view on this area\nMap.addLayer(aoi, {color: 'red'}, 'Area of Interest'); // Show the AOI on the map\n\n// Step 4: Clip the raster image to the AOI\nvar clippedRaster = raster.clip(aoi);\n// This cuts the raster to match the area we are interested in.\n\nMap.addLayer(clippedRaster, {min: 0, max: 3000, palette: ['blue', 'green', 'red']}, 'Clipped Raster');\n// Display the clipped raster on the map with colors for different heights.\n</code></pre> <p>Made by Pulakesh Pradhan</p>"},{"location":"gee/Tutoring/exports/#export-code","title":"Export Code:","text":"<pre><code>// Step 5: Export the raster image\nExport.image.toDrive({\n  image: clippedRaster, // The image we want to export\n  description: 'Exported_Raster', // Name for this export task\n  folder: 'GEE_Exports', // Folder in Google Drive to save the file\n  fileNamePrefix: 'raster_example', // File name for the exported raster\n  region: aoi, // The area we want to export\n  scale: 30, // Resolution in meters per pixel (30m here)\n  crs: 'EPSG:4326', // CRS (Geographic projection in lat/lon)\n  maxPixels: 1e13 // Maximum number of pixels allowed for export\n});\n\n// Step 6: Filter the vector data to the AOI\nvar filteredVector = vector.filterBounds(aoi);\n// This keeps only the parts of the vector that intersect with our AOI.\n\nMap.addLayer(filteredVector, {}, 'Filtered Vector');\n// Show the filtered vector data on the map\n\n// Step 7: Export the vector data\nExport.table.toDrive({\n  collection: filteredVector, // The vector data we want to export\n  description: 'Exported_Vector', // Name for this export task\n  folder: 'GEE_Exports', // Folder in Google Drive to save the file\n  fileNamePrefix: 'vector_example', // File name for the exported vector\n  fileFormat: 'GeoJSON' // File format (GeoJSON is commonly used)\n});\n</code></pre> <p>Made by Pulakesh Pradhan</p>"},{"location":"gee/Tutoring/gee_syntex/","title":"Commonly Used GEE Syntax Reference","text":""},{"location":"gee/Tutoring/gee_syntex/#goto-online-version-for-copy-the-codes-click-here","title":"Goto Online Version for Copy the Codes Click Here","text":"<p>This document provides a comprehensive reference for commonly used Google Earth Engine (GEE) syntax and functions, organized by category with detailed examples.</p>"},{"location":"gee/Tutoring/gee_syntex/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Basic Display &amp; Visualization</li> <li>Map.addLayer()</li> <li>Map.centerObject()</li> <li>print()</li> <li>Map.setCenter()</li> <li>Map.add()</li> <li>Loading Datasets</li> <li>ee.Image()</li> <li>ee.ImageCollection()</li> <li>ee.FeatureCollection()</li> <li>ee.Image() (DEM)</li> <li>Filtering Data</li> <li>filterDate()</li> <li>filterBounds()</li> <li>filter()</li> <li>Mathematical &amp; Band Operations</li> <li>normalizedDifference()</li> <li>select()</li> <li>add()</li> <li>multiply()</li> <li>Geometry &amp; Feature Collection Operations</li> <li>ee.Geometry.Point()</li> <li>ee.Geometry.Polygon()</li> <li>ee.FeatureCollection()</li> <li>filterBounds()</li> <li>Reducing &amp; Statistics</li> <li>reduce(ee.Reducer.mean())</li> <li>reduce(ee.Reducer.minMax())</li> <li>reduce(ee.Reducer.sum())</li> <li>reduceRegion()</li> <li>Exporting Data</li> <li>Export.image.toDrive()</li> <li>Export.table.toDrive()</li> <li>Export.image.toAsset()</li> <li>Miscellaneous</li> <li>clip()</li> <li>median()</li> </ol>"},{"location":"gee/Tutoring/gee_syntex/#basic-display-visualization","title":"Basic Display &amp; Visualization","text":"<p>Functions for visualizing data and controlling the map display</p>"},{"location":"gee/Tutoring/gee_syntex/#mapaddlayerimage-visparams-name","title":"Map.addLayer(image, visParams, name)","text":"<p>Adds an image/layer to the map.</p> <p>Example: <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Define visualization parameters\nvar visParams = {\n  bands: ['B4', 'B3', 'B2'],  // Use Red, Green, Blue bands\n  min: 0,                     // Minimum value for display\n  max: 0.3,                   // Maximum value for display\n  gamma: 1.4                  // Gamma correction\n};\n\n// Add the image to the map\nMap.addLayer(landsat, visParams, 'Landsat 8 RGB');\n\n// Add a single band with a different color palette\nMap.addLayer(landsat.select('B5'), \n  {min: 0, max: 0.4, palette: ['blue', 'green', 'red']}, \n  'NIR Band');\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#mapcenterobjectobject-zoom","title":"Map.centerObject(object, zoom)","text":"<p>Centers the map on a feature/geometry/image.</p> <p>Example: <pre><code>// Create a point for San Francisco\nvar sanFrancisco = ee.Geometry.Point([-122.4193, 37.7749]);\n\n// Center the map on the point with zoom level 10\nMap.centerObject(sanFrancisco, 10);\n\n// Center on a feature collection with automatic zoom\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nvar brazil = countries.filter(ee.Filter.eq('country_na', 'Brazil'));\nMap.centerObject(brazil);\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#printvariable","title":"print(variable)","text":"<p>Prints a variable to the Console.</p> <p>Example: <pre><code>// Print a simple message\nprint('Hello Earth Engine!');\n\n// Print an Earth Engine object\nvar image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nprint('Landsat Image:', image);\n\n// Print properties of an image\nprint('Image Bands:', image.bandNames());\nprint('Image Projection:', image.projection());\n\n// Print a dictionary\nvar stats = {min: 0, max: 255, mean: 127.5};\nprint('Statistics:', stats);\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#mapsetcenterlon-lat-zoom","title":"Map.setCenter(lon, lat, zoom)","text":"<p>Centers the map at a specific latitude and longitude.</p> <p>Example: <pre><code>// Center the map on Tokyo, Japan with zoom level 8\nMap.setCenter(139.6917, 35.6895, 8);\n\n// Center on the Amazon Rainforest with a closer zoom\nMap.setCenter(-60.5, -3.0, 6);\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#mapadduilabeltext","title":"Map.add(ui.Label('Text'))","text":"<p>Adds a UI label to the map.</p> <p>Example: <pre><code>// Create a simple label\nvar simpleLabel = ui.Label('This is a map label');\nMap.add(simpleLabel);\n\n// Create a styled label\nvar styledLabel = ui.Label({\n  value: 'NDVI Analysis Results',\n  style: {\n    fontWeight: 'bold',\n    fontSize: '18px',\n    margin: '10px',\n    padding: '8px',\n    backgroundColor: 'rgba(255, 255, 255, 0.8)'\n  }\n});\nMap.add(styledLabel);\n\n// Create a panel with multiple labels\nvar panel = ui.Panel({\n  style: {\n    position: 'top-left',\n    padding: '8px',\n    width: '300px'\n  }\n});\npanel.add(ui.Label('Vegetation Analysis'));\npanel.add(ui.Label('Data source: Landsat 8'));\nMap.add(panel);\n</code></pre></p> <p>Back to top</p>"},{"location":"gee/Tutoring/gee_syntex/#loading-datasets","title":"Loading Datasets","text":"<p>Functions for loading satellite imagery, collections, and vector data</p>"},{"location":"gee/Tutoring/gee_syntex/#var-image-eeimagecopernicuss2_sr20220101t000000_20220101t000000","title":"var image = ee.Image('COPERNICUS/S2_SR/20220101T000000_20220101T000000')","text":"<p>Loads a satellite image.</p> <p>Example: <pre><code>// Load a specific Sentinel-2 surface reflectance image\nvar sentinel2Image = ee.Image('COPERNICUS/S2_SR/20220101T104429_20220101T104426_T31TFJ');\nprint('Sentinel-2 Image:', sentinel2Image);\n\n// Load a Landsat 8 image\nvar landsat8Image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_123032_20210615');\nprint('Landsat 8 Image:', landsat8Image);\n\n// Load a MODIS image\nvar modisImage = ee.Image('MODIS/006/MOD13A2/2022_01_01');\nprint('MODIS Image:', modisImage);\n\n// Access image properties\nprint('Acquisition date:', sentinel2Image.get('system:time_start'));\nprint('Cloud cover percentage:', sentinel2Image.get('CLOUDY_PIXEL_PERCENTAGE'));\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#var-collection-eeimagecollectioncopernicuss2","title":"var collection = ee.ImageCollection('COPERNICUS/S2')","text":"<p>Loads an image collection.</p> <p>Example: <pre><code>// Load the Sentinel-2 image collection\nvar sentinel2Collection = ee.ImageCollection('COPERNICUS/S2');\nprint('Sentinel-2 Collection:', sentinel2Collection);\n\n// Load the MODIS NDVI collection\nvar modisNDVI = ee.ImageCollection('MODIS/006/MOD13Q1');\nprint('MODIS NDVI Collection:', modisNDVI);\n\n// Load Landsat 8 collection\nvar landsat8Collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA');\nprint('Landsat 8 Collection:', landsat8Collection);\n\n// Get collection metadata\nprint('Number of images in collection:', sentinel2Collection.size());\nprint('Collection date range:', sentinel2Collection.date());\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#var-feature-eefeaturecollectionfaogaul2015level1","title":"var feature = ee.FeatureCollection('FAO/GAUL/2015/level1')","text":"<p>Loads a feature collection (vector data).</p> <p>Example: <pre><code>// Load country boundaries\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nprint('Countries:', countries);\n\n// Load administrative boundaries (level 1 - states/provinces)\nvar adminLevel1 = ee.FeatureCollection('FAO/GAUL/2015/level1');\nprint('Admin Level 1:', adminLevel1);\n\n// Load watershed boundaries\nvar watersheds = ee.FeatureCollection('WWF/HydroSHEDS/v1/Basins/hybas_12');\nprint('Watersheds:', watersheds);\n\n// Filter a feature collection\nvar california = adminLevel1.filter(ee.Filter.and(\n  ee.Filter.eq('ADM0_NAME', 'United States of America'),\n  ee.Filter.eq('ADM1_NAME', 'California')\n));\nprint('California:', california);\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#var-dem-eeimageusgssrtmgl1_003","title":"var dem = ee.Image('USGS/SRTMGL1_003')","text":"<p>Loads a Digital Elevation Model (DEM).</p> <p>Example: <pre><code>// Load SRTM 30m global DEM\nvar srtm = ee.Image('USGS/SRTMGL1_003');\nprint('SRTM DEM:', srtm);\n\n// Load ALOS 30m global DEM\nvar alos = ee.Image('JAXA/ALOS/AW3D30/V2_2');\nprint('ALOS DEM:', alos);\n\n// Visualize elevation data\nMap.setCenter(-119.5383, 37.8651, 9); // Yosemite National Park\nMap.addLayer(srtm, {min: 0, max: 4000, palette: ['blue', 'green', 'yellow', 'brown', 'white']}, 'SRTM DEM');\n\n// Calculate slope and aspect from DEM\nvar slope = ee.Terrain.slope(srtm);\nvar aspect = ee.Terrain.aspect(srtm);\nMap.addLayer(slope, {min: 0, max: 60}, 'Slope (degrees)');\nMap.addLayer(aspect, {min: 0, max: 360, palette: ['blue', 'green', 'yellow', 'orange', 'red']}, 'Aspect (degrees)');\n</code></pre></p> <p>Back to top</p>"},{"location":"gee/Tutoring/gee_syntex/#filtering-data","title":"Filtering Data","text":"<p>Functions for subsetting and filtering image collections and feature collections</p>"},{"location":"gee/Tutoring/gee_syntex/#collectionfilterdate2023-01-01-2023-12-31","title":"collection.filterDate('2023-01-01', '2023-12-31')","text":"<p>Filters images by date.</p> <p>Example: <pre><code>// Load Sentinel-2 collection\nvar sentinel2 = ee.ImageCollection('COPERNICUS/S2_SR');\n\n// Filter by date range (for the year 2023)\nvar s2_2023 = sentinel2.filterDate('2023-01-01', '2023-12-31');\nprint('Images from 2023:', s2_2023.size());\n\n// Filter by specific season (summer 2023)\nvar s2_summer = sentinel2.filterDate('2023-06-01', '2023-08-31');\nprint('Summer 2023 images:', s2_summer.size());\n\n// Filter by specific month and sort by cloud cover\nvar s2_july = sentinel2.filterDate('2023-07-01', '2023-07-31')\n  .sort('CLOUDY_PIXEL_PERCENTAGE');\nprint('July 2023 images (sorted by cloud cover):', s2_july);\n\n// Get the most recent image from a date range\nvar endDate = ee.Date('2023-12-31');\nvar startDate = endDate.advance(-1, 'month');\nvar recentImage = sentinel2\n  .filterDate(startDate, endDate)\n  .sort('system:time_start', false) // Sort in descending order\n  .first();\nprint('Most recent image:', recentImage);\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#collectionfilterboundsgeometry","title":"collection.filterBounds(geometry)","text":"<p>Filters images by geographic region.</p> <p>Example: <pre><code>// Define a region of interest (ROI)\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]); // San Francisco area\n\n// Load Landsat 8 collection\nvar landsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA');\n\n// Filter collection by the ROI\nvar landsatSF = landsat8.filterBounds(roi);\nprint('Images intersecting ROI:', landsatSF.size());\n\n// Combine with date filter\nvar landsatSF_2023 = landsat8\n  .filterBounds(roi)\n  .filterDate('2023-01-01', '2023-12-31');\nprint('2023 images intersecting ROI:', landsatSF_2023.size());\n\n// Filter using a point\nvar mountEverest = ee.Geometry.Point([86.9250, 27.9881]);\nvar landsatEverest = landsat8\n  .filterBounds(mountEverest)\n  .filterDate('2023-01-01', '2023-12-31');\nprint('2023 images covering Mount Everest:', landsatEverest.size());\n\n// Filter using a feature collection\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nvar japan = countries.filter(ee.Filter.eq('country_na', 'Japan'));\nvar landsatJapan = landsat8\n  .filterBounds(japan.geometry())\n  .filterDate('2023-01-01', '2023-01-31');\nprint('January 2023 images covering Japan:', landsatJapan.size());\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#collectionfiltereefiltereqcloud_cover-0","title":"collection.filter(ee.Filter.eq('CLOUD_COVER', 0))","text":"<p>Filters images based on metadata properties.</p> <p>Example: <pre><code>// Load Landsat 8 collection\nvar landsat8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA');\n\n// Filter by cloud cover (less than 10%)\nvar clearImages = landsat8.filter(ee.Filter.lt('CLOUD_COVER', 10));\nprint('Images with &lt; 10% cloud cover:', clearImages.size());\n\n// Filter by exact property match\nvar path44 = landsat8.filter(ee.Filter.eq('WRS_PATH', 44));\nprint('Images from Path 44:', path44.size());\n\n// Combine multiple filters\nvar clearPath44 = landsat8\n  .filter(ee.Filter.and(\n    ee.Filter.eq('WRS_PATH', 44),\n    ee.Filter.lt('CLOUD_COVER', 10)\n  ));\nprint('Clear images from Path 44:', clearPath44.size());\n\n// Filter by date and properties\nvar recentClearImages = landsat8\n  .filterDate('2023-01-01', '2023-12-31')\n  .filter(ee.Filter.lt('CLOUD_COVER', 5));\nprint('Clear 2023 images:', recentClearImages.size());\n\n// Filter by list of values\nvar pathList = ee.List([44, 45, 46]);\nvar multiPath = landsat8.filter(ee.Filter.inList('WRS_PATH', pathList));\nprint('Images from multiple paths:', multiPath.size());\n</code></pre></p> <p>Back to top</p>"},{"location":"gee/Tutoring/gee_syntex/#mathematical-band-operations","title":"Mathematical &amp; Band Operations","text":"<p>Functions for performing calculations and manipulating image bands</p>"},{"location":"gee/Tutoring/gee_syntex/#var-ndvi-imagenormalizeddifferenceb5-b4","title":"var ndvi = image.normalizedDifference(['B5', 'B4'])","text":"<p>Calculates NDVI (or any other index).</p> <p>Example: <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Calculate NDVI (Normalized Difference Vegetation Index)\n// For Landsat 8: NIR is B5, Red is B4\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']);\nMap.addLayer(ndvi, {min: -1, max: 1, palette: ['blue', 'white', 'green']}, 'NDVI');\n\n// Calculate NDWI (Normalized Difference Water Index)\n// For Landsat 8: Green is B3, NIR is B5\nvar ndwi = landsat.normalizedDifference(['B3', 'B5']);\nMap.addLayer(ndwi, {min: -1, max: 1, palette: ['white', 'blue']}, 'NDWI');\n\n// Calculate EVI (Enhanced Vegetation Index)\n// EVI = 2.5 * ((NIR - Red) / (NIR + 6 * Red - 7.5 * Blue + 1))\nvar evi = landsat.expression(\n  '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {\n    'NIR': landsat.select('B5'),\n    'RED': landsat.select('B4'),\n    'BLUE': landsat.select('B2')\n  });\nMap.addLayer(evi, {min: -1, max: 1, palette: ['white', 'darkgreen']}, 'EVI');\n\n// Create a mask for high vegetation areas\nvar vegetationMask = ndvi.gt(0.4);\nMap.addLayer(vegetationMask, {palette: ['white', 'green']}, 'Vegetation Mask');\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#var-image2-imageselectb4-b3-b2","title":"var image2 = image.select(['B4', 'B3', 'B2'])","text":"<p>Selects specific bands.</p> <p>Example: <pre><code>// Load a Sentinel-2 image\nvar sentinel2 = ee.Image('COPERNICUS/S2_SR/20210701T101559_20210701T101554_T33UUP');\n\n// Select RGB bands\nvar rgbImage = sentinel2.select(['B4', 'B3', 'B2']);\nMap.addLayer(rgbImage, {min: 0, max: 3000}, 'RGB Image');\n\n// Select NIR band\nvar nirImage = sentinel2.select('B8');\nMap.addLayer(nirImage, {min: 0, max: 3000, palette: ['black', 'white']}, 'NIR Band');\n\n// Select multiple bands and rename them\nvar selectedBands = sentinel2.select(\n  ['B8', 'B4', 'B3', 'B2'], // Original band names\n  ['nir', 'red', 'green', 'blue'] // New band names\n);\nprint('Selected bands with new names:', selectedBands);\n\n// Select all bands that match a pattern (using regular expression)\nvar allBands = sentinel2.bandNames();\nprint('All bands:', allBands);\n\nvar selectedBands = sentinel2.select('B.*'); // Select all bands starting with 'B'\nprint('Bands starting with B:', selectedBands.bandNames());\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#var-newimage-imageaddimage2","title":"var newImage = image.add(image2)","text":"<p>Adds two images.</p> <p>Example: <pre><code>// Load two Landsat 8 images from different dates\nvar image1 = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\nvar image2 = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20150321');\n\n// Add corresponding bands\nvar sumImage = image1.add(image2);\nMap.addLayer(sumImage.select(['B4', 'B3', 'B2']), \n  {min: 0, max: 0.6}, 'Sum of two images');\n\n// Calculate the difference between images (for change detection)\nvar diffImage = image2.subtract(image1);\nMap.addLayer(diffImage.select(['B4', 'B3', 'B2']), \n  {min: -0.2, max: 0.2}, 'Difference between images');\n\n// Calculate the average of two images\nvar avgImage = image1.add(image2).divide(2);\nMap.addLayer(avgImage.select(['B4', 'B3', 'B2']), \n  {min: 0, max: 0.3}, 'Average of two images');\n\n// Perform band-wise operations\nvar ndvi1 = image1.normalizedDifference(['B5', 'B4']);\nvar ndvi2 = image2.normalizedDifference(['B5', 'B4']);\nvar ndviDiff = ndvi2.subtract(ndvi1);\nMap.addLayer(ndviDiff, \n  {min: -0.5, max: 0.5, palette: ['red', 'white', 'green']}, \n  'NDVI Change');\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#var-newimage-imagemultiply2","title":"var newImage = image.multiply(2)","text":"<p>Multiplies an image by a constant.</p> <p>Example: <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Multiply all bands by a constant (e.g., for scaling)\nvar scaledImage = landsat.multiply(10000);\nprint('Original range:', landsat.select('B4').reduceRegion({\n  reducer: ee.Reducer.minMax(),\n  geometry: landsat.geometry(),\n  scale: 30\n}));\nprint('Scaled range:', scaledImage.select('B4').reduceRegion({\n  reducer: ee.Reducer.minMax(),\n  geometry: landsat.geometry(),\n  scale: 30\n}));\n\n// Apply different scaling factors to different bands\nvar scaleFactors = ee.Image([0.0001, 0.0001, 0.0001, 1]); // Different factors for each band\nvar selectedBands = landsat.select(['B2', 'B3', 'B4', 'B5']);\nvar customScaled = selectedBands.multiply(scaleFactors);\nMap.addLayer(customScaled, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Custom Scaled');\n\n// Convert temperature from Kelvin to Celsius\nvar thermal = landsat.select('B10'); // Thermal band in Kelvin\nvar celsius = thermal.multiply(0.1).subtract(273.15); // K to C conversion\nMap.addLayer(celsius, {min: -10, max: 30, palette: ['blue', 'white', 'red']}, 'Temperature (C)');\n\n// Calculate percent reflectance\nvar percentReflectance = landsat.select(['B4', 'B3', 'B2']).multiply(100);\nMap.addLayer(percentReflectance, {min: 0, max: 30}, 'Percent Reflectance');\n</code></pre></p> <p>Back to top</p>"},{"location":"gee/Tutoring/gee_syntex/#geometry-feature-collection-operations","title":"Geometry &amp; Feature Collection Operations","text":"<p>Functions for creating and manipulating vector geometries and feature collections</p>"},{"location":"gee/Tutoring/gee_syntex/#var-point-eegeometrypointlon-lat","title":"var point = ee.Geometry.Point([lon, lat])","text":"<p>Creates a point geometry.</p> <p>Example: <pre><code>// Create a point for New York City\nvar nyc = ee.Geometry.Point([-74.0060, 40.7128]);\nprint('NYC Point:', nyc);\n\n// Add the point to the map\nMap.centerObject(nyc, 10);\nMap.addLayer(nyc, {color: 'red'}, 'New York City');\n\n// Create a point from coordinates\nvar longitude = -118.2437;\nvar latitude = 34.0522;\nvar losAngeles = ee.Geometry.Point([longitude, latitude]);\nMap.addLayer(losAngeles, {color: 'blue'}, 'Los Angeles');\n\n// Get information about the point\nprint('Point coordinates:', nyc.coordinates());\nprint('Point type:', nyc.type());\nprint('Point area (should be 0):', nyc.area());\n\n// Buffer a point to create a circle\nvar bufferedPoint = nyc.buffer(10000); // 10km buffer\nMap.addLayer(bufferedPoint, {color: 'yellow'}, 'NYC 10km Buffer');\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#var-polygon-eegeometrypolygonlon1-lat1-lon2-lat2","title":"var polygon = ee.Geometry.Polygon([[[lon1, lat1], [lon2, lat2], ...]])","text":"<p>Creates a polygon.</p> <p>Example: <pre><code>// Create a polygon for Yellowstone National Park (approximate)\nvar yellowstone = ee.Geometry.Polygon([\n  [[-111.2, 44.6],\n   [-111.2, 45.1],\n   [-109.9, 45.1],\n   [-109.9, 44.6],\n   [-111.2, 44.6]]\n]);\n\n// Add the polygon to the map\nMap.centerObject(yellowstone, 8);\nMap.addLayer(yellowstone, {color: 'green'}, 'Yellowstone National Park');\n\n// Create a rectangle (simplified polygon)\nvar rectangle = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]);\nMap.addLayer(rectangle, {color: 'blue'}, 'San Francisco Bay Area');\n\n// Create a multi-polygon\nvar multiPolygon = ee.Geometry.MultiPolygon([\n  [[[-122.1, 37.4], [-122.1, 37.5], [-122.0, 37.5], [-122.0, 37.4], [-122.1, 37.4]]], // Polygon 1\n  [[[-122.3, 37.6], [-122.3, 37.7], [-122.2, 37.7], [-122.2, 37.6], [-122.3, 37.6]]]  // Polygon 2\n]);\nMap.addLayer(multiPolygon, {color: 'red'}, 'Multi-Polygon');\n\n// Calculate polygon area\nprint('Yellowstone area (square meters):', yellowstone.area());\nprint('Yellowstone perimeter (meters):', yellowstone.perimeter());\n\n// Check if a point is inside a polygon\nvar testPoint = ee.Geometry.Point([-110.5, 44.8]);\nprint('Is point inside Yellowstone?', yellowstone.contains(testPoint));\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#var-fc-eefeaturecollectionfeature1-feature2","title":"var fc = ee.FeatureCollection([feature1, feature2])","text":"<p>Creates a Feature Collection.</p> <p>Example: <pre><code>// Create features with properties\nvar city1 = ee.Feature(\n  ee.Geometry.Point([-122.4194, 37.7749]), // San Francisco\n  {name: 'San Francisco', population: 874961, state: 'CA'}\n);\n\nvar city2 = ee.Feature(\n  ee.Geometry.Point([-74.0060, 40.7128]), // New York\n  {name: 'New York', population: 8804190, state: 'NY'}\n);\n\nvar city3 = ee.Feature(\n  ee.Geometry.Point([-87.6298, 41.8781]), // Chicago\n  {name: 'Chicago', population: 2746388, state: 'IL'}\n);\n\n// Create a feature collection from the features\nvar cities = ee.FeatureCollection([city1, city2, city3]);\nprint('Cities collection:', cities);\n\n// Add the feature collection to the map\nMap.setCenter(-95, 40, 4);\nMap.addLayer(cities, {color: 'red'}, 'Major US Cities');\n\n// Create a feature collection from a list of geometries\nvar points = [\n  ee.Geometry.Point([-122.4, 37.8]),\n  ee.Geometry.Point([-122.5, 37.7]),\n  ee.Geometry.Point([-122.3, 37.9])\n];\nvar pointCollection = ee.FeatureCollection(points);\nMap.addLayer(pointCollection, {color: 'blue'}, 'Bay Area Points');\n\n// Create a feature collection with computed properties\nvar citiesWithDensity = cities.map(function(city) {\n  // Add a new property based on existing properties\n  return city.set('density', ee.Number(city.get('population')).divide(100));\n});\nprint('Cities with density:', citiesWithDensity);\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#fcfilterboundspoint","title":"fc.filterBounds(point)","text":"<p>Filters features based on location.</p> <p>Example: <pre><code>// Load country boundaries\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\n\n// Create a point for Paris\nvar paris = ee.Geometry.Point([2.3522, 48.8566]);\n\n// Filter to find which country contains Paris\nvar franceFilter = countries.filterBounds(paris);\nprint('Country containing Paris:', franceFilter);\n\n// Load global cities dataset\nvar cities = ee.FeatureCollection('projects/sat-io/open-datasets/hrsl/hrsl_cities');\n\n// Define a region of interest (California)\nvar california = ee.Geometry.Rectangle([-124.4, 32.5, -114.1, 42.0]);\n\n// Filter cities that fall within California\nvar californiaCities = cities.filterBounds(california);\nprint('Number of cities in California:', californiaCities.size());\nMap.addLayer(californiaCities, {color: 'yellow'}, 'California Cities');\n\n// Filter features that intersect with a buffer\nvar bufferZone = paris.buffer(100000); // 100km around Paris\nvar nearbyCountries = countries.filterBounds(bufferZone);\nprint('Countries within 100km of Paris:', nearbyCountries);\n\n// Combine with property filters\nvar europeanCountriesNearParis = countries\n  .filter(ee.Filter.eq('continent', 'Europe'))\n  .filterBounds(bufferZone);\nprint('European countries near Paris:', europeanCountriesNearParis);\n</code></pre></p> <p>Back to top</p>"},{"location":"gee/Tutoring/gee_syntex/#reducing-statistics","title":"Reducing &amp; Statistics","text":"<p>Functions for computing statistics and aggregating data across collections and regions</p>"},{"location":"gee/Tutoring/gee_syntex/#var-mean-collectionreduceeereducermean","title":"var mean = collection.reduce(ee.Reducer.mean())","text":"<p>Computes the mean of an image collection.</p> <p>Example: <pre><code>// Load a Landsat 8 collection for a specific area and time\nvar roi = ee.Geometry.Point([-122.3578, 37.7726]).buffer(50000); // San Francisco area\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterDate('2020-01-01', '2020-12-31')\n  .filterBounds(roi);\n\n// Calculate the mean (average) image across the collection\nvar meanImage = collection.reduce(ee.Reducer.mean());\nMap.centerObject(roi, 9);\nMap.addLayer(meanImage, \n  {bands: ['B4_mean', 'B3_mean', 'B2_mean'], min: 0, max: 0.3}, \n  'Mean RGB');\n\n// Calculate mean NDVI across the collection\nvar ndviCollection = collection.map(function(image) {\n  return image.normalizedDifference(['B5', 'B4']).rename('NDVI');\n});\nvar meanNDVI = ndviCollection.reduce(ee.Reducer.mean());\nMap.addLayer(meanNDVI, \n  {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, \n  'Mean NDVI');\n\n// Calculate mean by season\nvar winter = collection.filter(ee.Filter.calendarRange(12, 2, 'month'));\nvar summer = collection.filter(ee.Filter.calendarRange(6, 8, 'month'));\nvar winterMean = winter.reduce(ee.Reducer.mean());\nvar summerMean = summer.reduce(ee.Reducer.mean());\nMap.addLayer(winterMean, \n  {bands: ['B4_mean', 'B3_mean', 'B2_mean'], min: 0, max: 0.3}, \n  'Winter Mean');\nMap.addLayer(summerMean, \n  {bands: ['B4_mean', 'B3_mean', 'B2_mean'], min: 0, max: 0.3}, \n  'Summer Mean');\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#var-minmax-collectionreduceeereducerminmax","title":"var minMax = collection.reduce(ee.Reducer.minMax())","text":"<p>Computes min and max values.</p> <p>Example: <pre><code>// Load a Landsat 8 collection for a specific area and time\nvar roi = ee.Geometry.Point([-122.3578, 37.7726]).buffer(50000); // San Francisco area\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterDate('2020-01-01', '2020-12-31')\n  .filterBounds(roi);\n\n// Calculate min and max values across the collection\nvar minMaxImage = collection.reduce(ee.Reducer.minMax());\nMap.centerObject(roi, 9);\n\n// Display the minimum values\nMap.addLayer(minMaxImage, \n  {bands: ['B4_min', 'B3_min', 'B2_min'], min: 0, max: 0.3}, \n  'Min RGB');\n\n// Display the maximum values\nMap.addLayer(minMaxImage, \n  {bands: ['B4_max', 'B3_max', 'B2_max'], min: 0, max: 0.3}, \n  'Max RGB');\n\n// Calculate the range (max - min)\nvar rangeImage = minMaxImage.select('.*_max').subtract(minMaxImage.select('.*_min'));\n// Rename the bands to remove the _max suffix\nvar bandNames = rangeImage.bandNames().map(function(name) {\n  return ee.String(name).replace('_max', '_range');\n});\nrangeImage = rangeImage.rename(bandNames);\nMap.addLayer(rangeImage, \n  {bands: ['B4_range', 'B3_range', 'B2_range'], min: 0, max: 0.3}, \n  'Range RGB');\n\n// Calculate min/max NDVI\nvar ndviCollection = collection.map(function(image) {\n  return image.normalizedDifference(['B5', 'B4']).rename('NDVI');\n});\nvar ndviMinMax = ndviCollection.reduce(ee.Reducer.minMax());\nMap.addLayer(ndviMinMax.select('NDVI_min'), \n  {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, \n  'Min NDVI');\nMap.addLayer(ndviMinMax.select('NDVI_max'), \n  {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, \n  'Max NDVI');\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#var-sum-collectionreduceeereducersum","title":"var sum = collection.reduce(ee.Reducer.sum())","text":"<p>Computes the sum of pixel values.</p> <p>Example: <pre><code>// Load a MODIS precipitation collection\nvar precipitation = ee.ImageCollection('UCSB-CHG/CHIRPS/PENTAD')\n  .filterDate('2020-01-01', '2020-12-31');\n\n// Calculate total annual precipitation\nvar annualPrecip = precipitation.reduce(ee.Reducer.sum());\nMap.addLayer(annualPrecip, \n  {min: 0, max: 3000, palette: ['white', 'blue', 'purple']}, \n  'Annual Precipitation (mm)');\n\n// Calculate seasonal precipitation\nvar winterMonths = ee.List([12, 1, 2]);\nvar springMonths = ee.List([3, 4, 5]);\nvar summerMonths = ee.List([6, 7, 8]);\nvar fallMonths = ee.List([9, 10, 11]);\n\n// Filter by season and calculate sum\nvar winterPrecip = precipitation\n  .filter(ee.Filter.calendarRange(12, 2, 'month'))\n  .reduce(ee.Reducer.sum());\nvar springPrecip = precipitation\n  .filter(ee.Filter.calendarRange(3, 5, 'month'))\n  .reduce(ee.Reducer.sum());\nvar summerPrecip = precipitation\n  .filter(ee.Filter.calendarRange(6, 8, 'month'))\n  .reduce(ee.Reducer.sum());\nvar fallPrecip = precipitation\n  .filter(ee.Filter.calendarRange(9, 11, 'month'))\n  .reduce(ee.Reducer.sum());\n\n// Display seasonal precipitation\nMap.addLayer(winterPrecip, \n  {min: 0, max: 1000, palette: ['white', 'blue', 'purple']}, \n  'Winter Precipitation');\nMap.addLayer(summerPrecip, \n  {min: 0, max: 1000, palette: ['white', 'blue', 'purple']}, \n  'Summer Precipitation');\n\n// Calculate cumulative precipitation over time\nvar cumulativePrecip = precipitation.sort('system:time_start').iterate(\n  function(image, result) {\n    result = ee.Image(result);\n    image = ee.Image(image);\n    return result.add(image);\n  },\n  ee.Image.constant(0)\n);\nMap.addLayer(ee.Image(cumulativePrecip), \n  {min: 0, max: 3000, palette: ['white', 'blue', 'purple']}, \n  'Cumulative Precipitation');\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#var-histogram-imagereduceregion-reducer-eereducerhistogram-geometry-region","title":"var histogram = image.reduceRegion({ reducer: ee.Reducer.histogram(), geometry: region })","text":"<p>Computes a histogram of pixel values.</p> <p>Example: <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Define a region of interest\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]); // San Francisco Bay Area\n\n// Calculate NDVI\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']).rename('NDVI');\n\n// Compute histogram of NDVI values in the region\nvar histogram = ndvi.reduceRegion({\n  reducer: ee.Reducer.histogram({\n    maxBuckets: 30\n  }),\n  geometry: roi,\n  scale: 30,\n  maxPixels: 1e9\n});\n\n// Print the histogram\nprint('NDVI Histogram:', histogram);\n\n// Access histogram properties\nvar ndviHistogram = ee.Dictionary(histogram.get('NDVI'));\nvar counts = ndviHistogram.get('histogram');\nvar buckets = ndviHistogram.get('bucketMeans');\nprint('Histogram counts:', counts);\nprint('Bucket means:', buckets);\n\n// Compute histograms for multiple bands\nvar rgbHistograms = landsat.select(['B4', 'B3', 'B2']).reduceRegion({\n  reducer: ee.Reducer.histogram({\n    maxBuckets: 50\n  }),\n  geometry: roi,\n  scale: 30,\n  maxPixels: 1e9\n});\nprint('RGB Histograms:', rgbHistograms);\n\n// Compute statistics from histogram\nvar ndviStats = ndvi.reduceRegion({\n  reducer: ee.Reducer.mean().combine({\n    reducer2: ee.Reducer.stdDev(),\n    sharedInputs: true\n  }),\n  geometry: roi,\n  scale: 30,\n  maxPixels: 1e9\n});\nprint('NDVI Statistics:', ndviStats);\n</code></pre></p> <p>Back to top</p>"},{"location":"gee/Tutoring/gee_syntex/#exporting-data","title":"Exporting Data","text":"<p>Functions for exporting images and feature collections to Google Drive and Earth Engine assets</p>"},{"location":"gee/Tutoring/gee_syntex/#exportimagetodriveimage-img-description-export-scale-30-region-geometry","title":"Export.image.toDrive({image: img, description: 'export', scale: 30, region: geometry})","text":"<p>Exports an image to Google Drive.</p> <p>Example: <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Define a region of interest\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]); // San Francisco Bay Area\n\n// Select RGB bands for a natural color image\nvar rgb = landsat.select(['B4', 'B3', 'B2']);\n\n// Export the RGB image to Google Drive\nExport.image.toDrive({\n  image: rgb,\n  description: 'Landsat8_RGB_SanFrancisco',\n  folder: 'GEE_Exports',\n  scale: 30,  // 30 meters per pixel\n  region: roi,\n  fileFormat: 'GeoTIFF',\n  maxPixels: 1e9\n});\n\n// Export an NDVI image\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']).rename('NDVI');\nExport.image.toDrive({\n  image: ndvi,\n  description: 'Landsat8_NDVI_SanFrancisco',\n  folder: 'GEE_Exports',\n  scale: 30,\n  region: roi,\n  fileFormat: 'GeoTIFF'\n});\n\n// Export with different parameters\nExport.image.toDrive({\n  image: landsat.select(['B4', 'B3', 'B2', 'B5', 'B6']),\n  description: 'Landsat8_Multispectral',\n  folder: 'GEE_Exports',\n  scale: 100,  // Coarser resolution (100m)\n  region: roi,\n  fileFormat: 'GeoTIFF',\n  crs: 'EPSG:4326',  // WGS84 coordinate system\n  dimensions: null,  // Use scale instead of dimensions\n  skipEmptyTiles: true\n});\n\n// Export a classified image\nvar classified = landsat.select('B5').gt(0.2).add(landsat.select('B4').gt(0.2)).rename('classes');\nExport.image.toDrive({\n  image: classified,\n  description: 'Landsat8_Classification',\n  folder: 'GEE_Exports',\n  scale: 30,\n  region: roi,\n  fileFormat: 'GeoTIFF'\n});\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#exporttabletodrivecollection-fc-description-export_fc","title":"Export.table.toDrive({collection: fc, description: 'export_fc'})","text":"<p>Exports a feature collection to Google Drive.</p> <p>Example: <pre><code>// Load country boundaries\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\n\n// Filter to get specific countries\nvar selectedCountries = countries.filter(ee.Filter.inList('country_na', \n  ['Brazil', 'Argentina', 'Chile', 'Peru', 'Colombia']));\n\n// Export the feature collection to Google Drive as a shapefile\nExport.table.toDrive({\n  collection: selectedCountries,\n  description: 'South_American_Countries',\n  folder: 'GEE_Exports',\n  fileFormat: 'SHP'  // Shapefile format\n});\n\n// Export as CSV with selected properties\nExport.table.toDrive({\n  collection: selectedCountries,\n  description: 'South_American_Countries_CSV',\n  folder: 'GEE_Exports',\n  fileFormat: 'CSV',\n  selectors: ['country_na', 'iso_alpha3']  // Only export these properties\n});\n\n// Export as GeoJSON\nExport.table.toDrive({\n  collection: selectedCountries,\n  description: 'South_American_Countries_GeoJSON',\n  folder: 'GEE_Exports',\n  fileFormat: 'GeoJSON'\n});\n\n// Export with computed properties\nvar countriesWithArea = selectedCountries.map(function(feature) {\n  // Add area in square kilometers\n  var area = feature.geometry().area().divide(1000 * 1000);\n  return feature.set('area_km2', area);\n});\n\nExport.table.toDrive({\n  collection: countriesWithArea,\n  description: 'South_American_Countries_With_Area',\n  folder: 'GEE_Exports',\n  fileFormat: 'CSV',\n  selectors: ['country_na', 'area_km2']\n});\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#exportimagetoassetimage-img-description-export_asset","title":"Export.image.toAsset({image: img, description: 'export_asset'})","text":"<p>Exports an image to an Earth Engine asset.</p> <p>Example: <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Define a region of interest\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]); // San Francisco Bay Area\n\n// Calculate NDVI\nvar ndvi = landsat.normalizedDifference(['B5', 'B4']).rename('NDVI');\n\n// Export the NDVI image to an Earth Engine asset\nExport.image.toAsset({\n  image: ndvi,\n  description: 'NDVI_SanFrancisco',\n  assetId: 'users/username/NDVI_SanFrancisco',  // Replace 'username' with your GEE username\n  scale: 30,\n  region: roi,\n  maxPixels: 1e9\n});\n\n// Export a composite image to an asset\nvar composite = landsat.select(['B4', 'B3', 'B2', 'B5']);\nExport.image.toAsset({\n  image: composite,\n  description: 'Landsat_Composite',\n  assetId: 'users/username/Landsat_Composite',\n  scale: 30,\n  region: roi,\n  maxPixels: 1e9\n});\n\n// Export a classified image to an asset\nvar classified = ndvi.gt(0.3).rename('vegetation');\nExport.image.toAsset({\n  image: classified,\n  description: 'Vegetation_Mask',\n  assetId: 'users/username/Vegetation_Mask',\n  scale: 30,\n  region: roi,\n  maxPixels: 1e9\n});\n\n// Export with pyramiding policy\nvar elevation = ee.Image('USGS/SRTMGL1_003');\nExport.image.toAsset({\n  image: elevation.clip(roi),\n  description: 'SRTM_Elevation',\n  assetId: 'users/username/SRTM_Elevation',\n  scale: 30,\n  region: roi,\n  maxPixels: 1e9,\n  pyramidingPolicy: {'.default': 'mean'}  // Use mean for pyramiding\n});\n</code></pre></p> <p>Back to top</p>"},{"location":"gee/Tutoring/gee_syntex/#miscellaneous","title":"Miscellaneous","text":"<p>Additional useful functions for various operations in Earth Engine</p>"},{"location":"gee/Tutoring/gee_syntex/#imageclipregion","title":"image.clip(region)","text":"<p>Clips an image to a specified region.</p> <p>Example: <pre><code>// Load a Landsat 8 image\nvar landsat = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');\n\n// Define a region to clip to (San Francisco Bay Area)\nvar roi = ee.Geometry.Rectangle([-122.5, 37.5, -122.0, 38.0]);\n\n// Clip the image to the region\nvar clippedImage = landsat.clip(roi);\n\n// Display the clipped image\nMap.centerObject(roi, 10);\nMap.addLayer(clippedImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Clipped Landsat Image');\n\n// Clip a DEM to a country boundary\nvar dem = ee.Image('USGS/SRTMGL1_003');\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nvar nepal = countries.filter(ee.Filter.eq('country_na', 'Nepal'));\n\nvar nepalDEM = dem.clip(nepal);\nMap.centerObject(nepal, 7);\nMap.addLayer(nepalDEM, {min: 0, max: 8000, palette: ['blue', 'green', 'yellow', 'red', 'white']}, 'Nepal Elevation');\n\n// Clip multiple bands\nvar rgbImage = landsat.select(['B4', 'B3', 'B2']).clip(roi);\nMap.addLayer(rgbImage, {min: 0, max: 0.3}, 'Clipped RGB');\n\n// Clip an image collection\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterDate('2020-01-01', '2020-12-31')\n  .filterBounds(roi);\n\nvar clippedCollection = collection.map(function(image) {\n  return image.clip(roi);\n});\n\n// Display the first image from the clipped collection\nvar firstImage = ee.Image(clippedCollection.first());\nMap.addLayer(firstImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'First Clipped Image');\n</code></pre></p>"},{"location":"gee/Tutoring/gee_syntex/#collectionmedian","title":"collection.median()","text":"<p>Computes the median of an image collection.</p> <p>Example: <pre><code>// Load a Landsat 8 collection for a specific area and time\nvar roi = ee.Geometry.Point([-122.3578, 37.7726]).buffer(50000); // San Francisco area\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterDate('2020-01-01', '2020-12-31')\n  .filterBounds(roi);\n\n// Compute the median image\nvar medianImage = collection.median();\nMap.centerObject(roi, 9);\nMap.addLayer(medianImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Median RGB');\n\n// Compare median with mean\nvar meanImage = collection.mean();\nMap.addLayer(meanImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Mean RGB');\n\n// Calculate median NDVI\nvar ndviCollection = collection.map(function(image) {\n  return image.normalizedDifference(['B5', 'B4']).rename('NDVI');\n});\nvar medianNDVI = ndviCollection.median();\nMap.addLayer(medianNDVI, {min: -0.2, max: 0.8, palette: ['blue', 'white', 'green']}, 'Median NDVI');\n\n// Create a cloud-free composite using median\nvar cloudFreeLandsat = collection\n  .filter(ee.Filter.lt('CLOUD_COVER', 20))  // Filter low cloud images\n  .median();\nMap.addLayer(cloudFreeLandsat, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Cloud-free Composite');\n\n// Calculate seasonal medians\nvar winter = collection.filter(ee.Filter.calendarRange(12, 2, 'month')).median();\nvar summer = collection.filter(ee.Filter.calendarRange(6, 8, 'month')).median();\nMap.addLayer(winter, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Winter Median');\nMap.addLayer(summer, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Summer Median');\n</code></pre></p> <p>scale: 300  // 10x coarser than original 30m resolution });</p> <p>Map.addLayer(image, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Original Resolution'); Map.addLayer(coarseImage, {bands: ['B4', 'B3', 'B2'], min: 0, max: 0.3}, 'Aggregated Resolution'); ```</p>"},{"location":"gee/Tutoring/geechart/","title":"Charts in Google Earth Engine","text":""},{"location":"gee/Tutoring/geechart/#1-image-based-charts","title":"1. Image-Based Charts","text":""},{"location":"gee/Tutoring/geechart/#time-series-analysis","title":"Time Series Analysis","text":"<ul> <li><code>ui.Chart.image.series</code>: Single region over time</li> <li><code>ui.Chart.image.seriesByRegion</code>: Multiple regions over time</li> <li><code>ui.Chart.image.doySeries</code>: Day-of-year patterns for single region</li> <li><code>ui.Chart.image.doySeriesByYear</code>: Compare years for single region</li> <li><code>ui.Chart.image.doySeriesByRegion</code>: Day-of-year patterns across regions</li> </ul>"},{"location":"gee/Tutoring/geechart/#spatial-analysis","title":"Spatial Analysis","text":"<ul> <li><code>ui.Chart.image.byRegion</code>: Single-band summary across regions</li> <li><code>ui.Chart.image.regions</code>: Time series across multiple regions</li> <li><code>ui.Chart.image.byClass</code>: Band distribution by region class</li> <li><code>ui.Chart.image.histogram</code>: Pixel value distribution</li> </ul>"},{"location":"gee/Tutoring/geechart/#2-feature-based-charts","title":"2. Feature-Based Charts","text":"<p>These functions work with FeatureCollections.</p>"},{"location":"gee/Tutoring/geechart/#property-analysis","title":"Property Analysis","text":"<ul> <li><code>ui.Chart.feature.byFeature</code>: Individual feature properties</li> <li><code>ui.Chart.feature.byProperty</code>: Multiple properties comparison</li> <li><code>ui.Chart.feature.groups</code>: Grouped data comparisons</li> <li><code>ui.Chart.feature.histogram</code>: Property value distribution</li> </ul>"},{"location":"gee/Tutoring/geechart/#common-parameters","title":"Common Parameters","text":""},{"location":"gee/Tutoring/geechart/#general-parameters","title":"General Parameters","text":"<ul> <li><code>scale</code>: Spatial resolution in meters</li> <li><code>reducer</code>: Function for aggregating pixel values (e.g., mean, max, min)</li> <li><code>region/regions</code>: Area(s) of interest for analysis</li> <li><code>xProperty</code>: Property for x-axis values</li> <li><code>seriesProperty</code>: Property for distinguishing multiple series</li> </ul>"},{"location":"gee/Tutoring/geechart/#customization-options","title":"Customization Options","text":"<p><pre><code>.setOptions({\n  title: 'Chart Title',\n  hAxis: {\n    title: 'X-Axis Label',\n    titleTextStyle: {italic: false, bold: true}\n  },\n  vAxis: {\n    title: 'Y-Axis Label',\n    titleTextStyle: {italic: false, bold: true}\n  },\n  lineWidth: 2,\n  colors: ['hexcolor1', 'hexcolor2'],\n  curveType: 'function'  // for smooth lines\n})\n</code></pre> </p>"},{"location":"gee/Tutoring/geechart/#1-uichartimageseries","title":"1. <code>ui.Chart.image.series</code>","text":""},{"location":"gee/Tutoring/geechart/#description","title":"Description:","text":"<p>This chart shows how vegetation indices (NDVI and EVI) change over time for a specific region, such as a forest. Each image band (NDVI and EVI) is plotted as a unique series. The x-axis represents the time, and the y-axis shows the average vegetation index value.</p>"},{"location":"gee/Tutoring/geechart/#code","title":"Code:","text":"<p><pre><code>// Import the example feature collection and subset the forest feature.\nvar forest = ee.FeatureCollection('projects/google/charts_feature_example')\n                 .filter(ee.Filter.eq('label', 'Forest'));\n\n// Load MODIS vegetation indices data and subset a decade of images.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filter(ee.Filter.date('2010-01-01', '2020-01-01'))\n                     .select(['NDVI', 'EVI']);\n\n// Define the chart and print it to the console.\nvar chart = ui.Chart.image.series({\n  imageCollection: vegIndices,\n  region: forest,\n  reducer: ee.Reducer.mean(),\n  scale: 500,\n  xProperty: 'system:time_start'\n})\n.setSeriesNames(['EVI', 'NDVI'])\n.setOptions({\n  title: 'Average Vegetation Index Value by Date for Forest',\n  hAxis: {title: 'Date', titleTextStyle: {italic: false, bold: true}},\n  vAxis: {title: 'Vegetation index (x1e4)', titleTextStyle: {italic: false, bold: true}},\n  lineWidth: 5,\n  colors: ['e37d05', '1d6b99'],\n  curveType: 'function'\n});\nprint(chart);\n</code></pre> </p>"},{"location":"gee/Tutoring/geechart/#2-uichartimageseriesbyregion","title":"2. <code>ui.Chart.image.seriesByRegion</code>","text":""},{"location":"gee/Tutoring/geechart/#description_1","title":"Description:","text":"<p>This chart compares NDVI values over time for multiple regions, such as forest, desert, and grasslands. Each region is represented as a unique series.</p>"},{"location":"gee/Tutoring/geechart/#code_1","title":"Code:","text":"<p><pre><code>// Import the example feature collection.\nvar ecoregions = ee.FeatureCollection('projects/google/charts_feature_example');\n\n// Load MODIS vegetation indices data and subset a decade of images.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filter(ee.Filter.date('2010-01-01', '2020-01-01'))\n                     .select(['NDVI', 'EVI']);\n\n// Define the chart and print it to the console.\nvar chart = ui.Chart.image.seriesByRegion({\n  imageCollection: vegIndices,\n  band: 'NDVI',\n  regions: ecoregions,\n  reducer: ee.Reducer.mean(),\n  scale: 500,\n  seriesProperty: 'label',\n  xProperty: 'system:time_start'\n})\n.setOptions({\n  title: 'Average NDVI Value by Date',\n  hAxis: {title: 'Date', titleTextStyle: {italic: false, bold: true}},\n  vAxis: {title: 'NDVI (x1e4)', titleTextStyle: {italic: false, bold: true}},\n  lineWidth: 5,\n  colors: ['f0af07', '0f8755', '76b349'],\n});\nprint(chart);\n</code></pre> </p>"},{"location":"gee/Tutoring/geechart/#3-uichartimagedoyseries","title":"3. <code>ui.Chart.image.doySeries</code>","text":""},{"location":"gee/Tutoring/geechart/#description_2","title":"Description:","text":"<p>This chart plots average NDVI and EVI values for each day of the year across multiple years for a single region. For example, it can help identify seasonal vegetation trends in a grassland.</p>"},{"location":"gee/Tutoring/geechart/#code_2","title":"Code:","text":"<p><pre><code>// Import the example feature collection and subset the grassland feature.\nvar grassland = ee.FeatureCollection('projects/google/charts_feature_example')\n                    .filter(ee.Filter.eq('label', 'Grassland'));\n\n// Load MODIS vegetation indices data and subset a decade of images.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filter(ee.Filter.date('2010-01-01', '2020-01-01'))\n                     .select(['NDVI', 'EVI']);\n\n// Define the chart and print it to the console.\nvar chart = ui.Chart.image.doySeries({\n  imageCollection: vegIndices,\n  region: grassland,\n  regionReducer: ee.Reducer.mean(),\n  scale: 500,\n  yearReducer: ee.Reducer.mean(),\n  startDay: 1,\n  endDay: 365\n})\n.setSeriesNames(['EVI', 'NDVI'])\n.setOptions({\n  title: 'Average Vegetation Index Value by Day of Year for Grassland',\n  hAxis: {title: 'Day of year', titleTextStyle: {italic: false, bold: true}},\n  vAxis: {title: 'Vegetation index (x1e4)', titleTextStyle: {italic: false, bold: true}},\n  lineWidth: 5,\n  colors: ['e37d05', '1d6b99'],\n});\nprint(chart);\n</code></pre> </p>"},{"location":"gee/Tutoring/geechart/#4-uichartimagedoyseriesbyyear","title":"4. <code>ui.Chart.image.doySeriesByYear</code>","text":""},{"location":"gee/Tutoring/geechart/#description_3","title":"Description:","text":"<p>This chart compares NDVI trends for a specific region over different years, plotting the average value for each day of the year. Each year\u2019s data is shown as a separate series.</p>"},{"location":"gee/Tutoring/geechart/#code_3","title":"Code:","text":"<p><pre><code>// Import the example feature collection and subset the grassland feature.\nvar grassland = ee.FeatureCollection('projects/google/charts_feature_example')\n                    .filter(ee.Filter.eq('label', 'Grassland'));\n\n// Load MODIS vegetation indices data and subset years 2012 and 2019.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filter(ee.Filter.or(\n                         ee.Filter.date('2012-01-01', '2013-01-01'),\n                         ee.Filter.date('2019-01-01', '2020-01-01')))\n                     .select(['NDVI', 'EVI']);\n\n// Define the chart and print it to the console.\nvar chart = ui.Chart.image.doySeriesByYear({\n  imageCollection: vegIndices,\n  bandName: 'NDVI',\n  region: grassland,\n  regionReducer: ee.Reducer.mean(),\n  scale: 500,\n  sameDayReducer: ee.Reducer.mean(),\n  startDay: 1,\n  endDay: 365\n})\n.setOptions({\n  title: 'Average NDVI Value by Day of Year for Grassland',\n  hAxis: {title: 'Day of year', titleTextStyle: {italic: false, bold: true}},\n  vAxis: {title: 'NDVI (x1e4)', titleTextStyle: {italic: false, bold: true}},\n  lineWidth: 5,\n  colors: ['39a8a7', '9c4f97'],\n});\nprint(chart);\n</code></pre> </p>"},{"location":"gee/Tutoring/geechart/#5-uichartimagedoyseriesbyregion","title":"5. <code>ui.Chart.image.doySeriesByRegion</code>","text":""},{"location":"gee/Tutoring/geechart/#description_4","title":"Description:","text":"<p>This chart compares average NDVI values for different regions (e.g., forest, desert, and grasslands) over a single year. It shows how vegetation varies seasonally across regions.</p>"},{"location":"gee/Tutoring/geechart/#code_4","title":"Code:","text":"<p><pre><code>// Import the example feature collection.\nvar ecoregions = ee.FeatureCollection('projects/google/charts_feature_example');\n\n// Load MODIS vegetation indices data and subset a decade of images.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filter(ee.Filter.date('2010-01-01', '2020-01-01'))\n                     .select(['NDVI', 'EVI']);\n\n// Define the chart and print it to the console.\nvar chart = ui.Chart.image.doySeriesByRegion({\n  imageCollection: vegIndices,\n  bandName: 'NDVI',\n  regions: ecoregions,\n  regionReducer: ee.Reducer.mean(),\n  scale: 500,\n  yearReducer: ee.Reducer.mean(),\n  seriesProperty: 'label',\n  startDay: 1,\n  endDay: 365\n})\n.setOptions({\n  title: 'Average NDVI Value by Day of Year',\n  hAxis: {title: 'Day of year', titleTextStyle: {italic: false, bold: true}},\n  vAxis: {title: 'NDVI (x1e4)', titleTextStyle: {italic: false, bold: true}},\n  lineWidth: 5,\n  colors: ['f0af07', '0f8755', '76b349'],\n});\nprint(chart);\n</code></pre> </p>"},{"location":"gee/Tutoring/geechart/#_1","title":"* * *","text":""},{"location":"gee/Tutoring/geechart/#1-uichartimagebyregion","title":"1. <code>ui.Chart.image.byRegion</code>","text":""},{"location":"gee/Tutoring/geechart/#purpose","title":"Purpose:","text":"<p>This function creates a chart summarizing the values of a single band of an image or image collection across multiple regions.</p>"},{"location":"gee/Tutoring/geechart/#example","title":"Example:","text":"<p>We will calculate and display the mean NDVI for different ecoregions.</p> <p><pre><code>// Import the example feature collection.\nvar ecoregions = ee.FeatureCollection('projects/google/charts_feature_example');\n\n// Load a MODIS image containing NDVI and EVI bands for a specific date.\nvar modisImage = ee.Image('MODIS/061/MOD13A1/2010_01_01').select('NDVI');\n\n// Create the chart and print it.\nvar chart = ui.Chart.image.byRegion({\n  image: modisImage,\n  regions: ecoregions,\n  reducer: ee.Reducer.mean(),\n  scale: 500,\n  xProperty: 'label'\n})\n.setOptions({\n  title: 'Mean NDVI for Ecoregions',\n  hAxis: {title: 'Ecoregion'},\n  vAxis: {title: 'NDVI (x1e4)'},\n  colors: ['76b349']\n});\nprint(chart);\n</code></pre> </p>"},{"location":"gee/Tutoring/geechart/#2-uichartimageregions","title":"2. <code>ui.Chart.image.regions</code>","text":""},{"location":"gee/Tutoring/geechart/#purpose_1","title":"Purpose:","text":"<p>This function plots a time series for a given region using the values of one or more bands over multiple images in an image collection.</p>"},{"location":"gee/Tutoring/geechart/#example_1","title":"Example:","text":"<p>We will generate a time series for NDVI values in a single region (grassland).</p> <pre><code>// Import the example feature collection and filter the grassland feature.\nvar grassland = ee.FeatureCollection('projects/google/charts_feature_example')\n                    .filter(ee.Filter.eq('label', 'Grassland'));\n\n// Load MODIS vegetation indices data for a decade.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filterDate('2010-01-01', '2020-01-01')\n                     .select('NDVI');\n\n// Reduce the ImageCollection over the time period to create a time series.\nvar meanNDVI = vegIndices.mean();  // Calculate the mean NDVI for the whole time period.\n\n// Create the chart with regions for the time series\nvar chart = ui.Chart.image.regions({\n  image: meanNDVI,          // Use the reduced image (mean NDVI)\n  regions: grassland,       // The FeatureCollection (regions of interest)\n  reducer: ee.Reducer.mean(),  // Aggregation function (mean of NDVI)\n  scale: 500,               // Spatial resolution (500 meters)\n  seriesProperty: 'label'   // Use the 'label' property to differentiate regions\n})\n.setOptions({\n  title: 'NDVI Time Series for Grassland',\n  hAxis: {title: 'Date'},\n  vAxis: {title: 'NDVI (x1e4)'},\n  lineWidth: 2,\n  colors: ['#1d6b99']  // Set a valid color code (hex format)\n});\n\n// Print the chart\nprint(chart);\n</code></pre>"},{"location":"gee/Tutoring/geechart/#3-uichartimagebyclass","title":"3. <code>ui.Chart.image.byClass</code>","text":""},{"location":"gee/Tutoring/geechart/#purpose_2","title":"Purpose:","text":"<p>This function compares the value distribution of an image's band(s) across different classes defined in a region.</p>"},{"location":"gee/Tutoring/geechart/#example_2","title":"Example:","text":"<p>We will compare the mean NDVI for forest, desert, and grassland classes.</p> <pre><code>// Import the example feature collection.\nvar ecoregions = ee.FeatureCollection('projects/google/charts_feature_example');\n\n// Load a MODIS image containing NDVI and EVI bands for a specific date.\nvar modisImage = ee.Image('MODIS/061/MOD13A1/2010_01_01').select('NDVI');\n\n// Create the chart and print it.\nvar chart = ui.Chart.image.byClass({\n  image: modisImage,\n  regions: ecoregions,\n  classProperty: 'label',\n  reducer: ee.Reducer.mean(),\n  scale: 500\n})\n.setOptions({\n  title: 'NDVI Distribution by Class',\n  hAxis: {title: 'Class'},\n  vAxis: {title: 'NDVI (x1e4)'},\n  colors: ['f0af07', '76b349', '1d6b99']\n});\nprint(chart);\n</code></pre>"},{"location":"gee/Tutoring/geechart/#4-uichartimagehistogram","title":"4. <code>ui.Chart.image.histogram</code>","text":""},{"location":"gee/Tutoring/geechart/#purpose_3","title":"Purpose:","text":"<p>This function generates a histogram for one or more bands of an image or image collection, based on pixel values.</p>"},{"location":"gee/Tutoring/geechart/#example_3","title":"Example:","text":"<p>We will create a histogram showing the distribution of NDVI values for a grassland region.</p> <pre><code>// Import the example feature collection and filter the grassland feature.\nvar grassland = ee.FeatureCollection('projects/google/charts_feature_example')\n                    .filter(ee.Filter.eq('label', 'Grassland'));\n\n// Load a MODIS image containing NDVI and EVI bands for a specific date.\nvar modisImage = ee.Image('MODIS/061/MOD13A1/2010_01_01').select('NDVI');\n\n// Create the chart and print it.\nvar chart = ui.Chart.image.histogram({\n  image: modisImage,\n  region: grassland,\n  scale: 500,\n  maxBuckets: 20\n})\n.setOptions({\n  title: 'NDVI Histogram for Grassland',\n  hAxis: {title: 'NDVI Value'},\n  vAxis: {title: 'Frequency'},\n  colors: ['39a8a7']\n});\nprint(chart);\n</code></pre>"},{"location":"gee/Tutoring/geechart/#_2","title":"* * *","text":""},{"location":"gee/Tutoring/geechart/#1-uichartfeaturebyfeature","title":"1. <code>ui.Chart.feature.byFeature</code>","text":""},{"location":"gee/Tutoring/geechart/#purpose_4","title":"Purpose:","text":"<p>This function creates a chart displaying feature properties, with each feature in a <code>FeatureCollection</code> represented as a unique data point on the chart.</p>"},{"location":"gee/Tutoring/geechart/#example_4","title":"Example:","text":"<p>We will plot average NDVI values for individual features in an <code>FeatureCollection</code> (ecoregions).</p> <pre><code>// Import the example feature collection.\nvar ecoregions = ee.FeatureCollection('projects/google/charts_feature_example');\n\n// Calculate the mean NDVI for each region and add it as a property.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filterDate('2010-01-01', '2010-12-31')\n                     .select('NDVI')\n                     .mean();\nvar ecoregionsWithNDVI = vegIndices.reduceRegions({\n  collection: ecoregions,\n  reducer: ee.Reducer.mean(),\n  scale: 500\n});\n\n// Create the chart and print it.\nvar chart = ui.Chart.feature.byFeature({\n  features: ecoregionsWithNDVI,\n  xProperty: 'label',\n  yProperties: ['mean']\n})\n.setOptions({\n  title: 'Average NDVI by Region',\n  hAxis: {title: 'Region'},\n  vAxis: {title: 'Mean NDVI'},\n  colors: ['76b349']\n});\nprint(chart);\n</code></pre>"},{"location":"gee/Tutoring/geechart/#2-uichartfeaturebyproperty","title":"2. <code>ui.Chart.feature.byProperty</code>","text":""},{"location":"gee/Tutoring/geechart/#purpose_5","title":"Purpose:","text":"<p>This function displays a chart summarizing multiple numeric properties of a <code>FeatureCollection</code>. Each property is represented as a series.</p>"},{"location":"gee/Tutoring/geechart/#example_5","title":"Example:","text":"<p>We will compare mean NDVI and EVI values across features in a <code>FeatureCollection</code>.</p> <pre><code>// Add both mean NDVI and mean EVI properties to the FeatureCollection.\nvar vegIndices = ee.ImageCollection('MODIS/061/MOD13A1')\n                     .filterDate('2010-01-01', '2010-12-31')\n                     .mean();\nvar ecoregionsWithVeg = vegIndices.reduceRegions({\n  collection: ecoregions,\n  reducer: ee.Reducer.mean(),\n  scale: 500\n}).map(function(feature) {\n  return feature.set({\n    NDVI: feature.get('mean'),\n    EVI: vegIndices.select('EVI').reduceRegion({\n      reducer: ee.Reducer.mean(),\n      geometry: feature.geometry(),\n      scale: 500\n    }).get('EVI')\n  });\n});\n\n// Create the chart and print it.\nvar chart = ui.Chart.feature.byProperty({\n  features: ecoregionsWithVeg,\n  xProperties: ['NDVI', 'EVI']\n})\n.setOptions({\n  title: 'Vegetation Index Comparison by Property',\n  hAxis: {title: 'Properties'},\n  vAxis: {title: 'Values'},\n  colors: ['76b349', '1d6b99']\n});\nprint(chart);\n</code></pre>"},{"location":"gee/Tutoring/geechart/#3-uichartfeaturegroups","title":"3. <code>ui.Chart.feature.groups</code>","text":""},{"location":"gee/Tutoring/geechart/#purpose_6","title":"Purpose:","text":"<p>This function creates a chart comparing grouped data based on a categorical property. It\u2019s useful for aggregating and comparing data across different groups.</p>"},{"location":"gee/Tutoring/geechart/#example_6","title":"Example:","text":"<p>We will compare mean NDVI values for forest, grassland, and desert groups.</p> <pre><code>// Add a grouping property to the FeatureCollection.\nvar ecoregionsWithGroups = ecoregionsWithNDVI.map(function(feature) {\n  return feature.set('group', feature.get('label'));\n});\n\n// Create the chart and print it.\nvar chart = ui.Chart.feature.groups({\n  features: ecoregionsWithGroups,\n  xProperty: 'group',\n  yProperty: 'mean'\n})\n.setOptions({\n  title: 'Grouped Mean NDVI Values',\n  hAxis: {title: 'Group'},\n  vAxis: {title: 'Mean NDVI'},\n  colors: ['39a8a7']\n});\nprint(chart);\n</code></pre>"},{"location":"gee/Tutoring/geechart/#4-uichartfeaturehistogram","title":"4. <code>ui.Chart.feature.histogram</code>","text":""},{"location":"gee/Tutoring/geechart/#purpose_7","title":"Purpose:","text":"<p>This function generates a histogram of a numeric property across features in a <code>FeatureCollection</code>.</p>"},{"location":"gee/Tutoring/geechart/#example_7","title":"Example:","text":"<p>We will create a histogram of mean NDVI values for all regions.</p> <pre><code>// Create the chart and print it.\nvar chart = ui.Chart.feature.histogram({\n  features: ecoregionsWithNDVI,\n  property: 'mean',\n  minBucketWidth: 0.1\n})\n.setOptions({\n  title: 'Histogram of NDVI Values',\n  hAxis: {title: 'NDVI Value'},\n  vAxis: {title: 'Frequency'},\n  colors: ['9c4f97']\n});\nprint(chart);\n</code></pre>"},{"location":"lulc/","title":"Index","text":""},{"location":"lulc/#image-processing","title":"Image Processing","text":""},{"location":"lulc/#1-radiometric-correction","title":"1. Radiometric Correction","text":"<p>These corrections deal with the image\u2019s brightness values (Digital Numbers or DN), ensuring they accurately represent surface reflectance. They aim to correct: </p> <ul> <li>Sensor Defects: Calibration errors, striping, and sensor drift (especially for older sensors like Landsat MSS or TM).</li> <li>Atmospheric Correction: Removing scattering and absorption effects caused by the atmosphere. Methods range from simple (Dark Object Subtraction) to complex (physical modeling like 6S or MODTRAN).</li> <li></li> </ul>"},{"location":"lulc/#2-geometric-correction","title":"2. Geometric Correction","text":"<p>This ensures images align properly with geographic coordinates, correcting distortions caused by:</p> <ul> <li>Sensor Geometry: Perspective distortions caused by sensor movement and angle.</li> <li>Platform Instability: Aircraft or satellite movement during capture (pitch, roll, yaw).</li> <li>Earth Curvature and Terrain Effects: These are addressed through:<ul> <li>GPS and Ground Control Points (GCP): Linking image features to known geographic coordinates.</li> <li>Mathematical Transformation Models: Polynomial transformations, RPC models, etc.</li> <li>DTM/DEM Use: For terrain correction, especially in hilly/mountainous areas.</li> <li></li> </ul> </li> </ul>"},{"location":"lulc/#image-enhancement","title":"Image Enhancement","text":""},{"location":"lulc/#1-radiometriccontrast-enhancement","title":"1. Radiometric/Contrast Enhancement","text":"<p>Direct modification of individual pixel brightness (DN values) to enhance visual interpretability:</p> <ul> <li>Linear Contrast Stretch: Expands DN range (e.g., min-max stretch).</li> <li>Non-Linear Transformations: Logarithmic and inverse log stretches to enhance darker areas (log) or compress brighter areas (inverse log).</li> <li></li> </ul>"},{"location":"lulc/#2-spectral-enhancement","title":"2. Spectral Enhancement","text":"<p>Multiband transformations to enhance spectral patterns:</p> <ul> <li>Band Ratios: e.g., NDVI (Vegetation), NDBI (Built-up), NDWI (Water).</li> <li>Principal Component Analysis (PCA): Reduces data dimensionality by transforming correlated bands into a set of uncorrelated components.</li> <li></li> </ul>"},{"location":"lulc/#3-spatial-enhancement","title":"3. Spatial Enhancement","text":"<p>Enhancement based on relationships between neighboring pixels (spatial context):</p> <ul> <li>Low-Pass Filters: Smoothing (e.g., Mean filter) to reduce noise.</li> <li>Edge Enhancement: High-pass filters to sharpen edges.</li> <li>Edge Detection: Sobel, Prewitt, or Canny filters for boundary extraction.</li> </ul> <p></p>"},{"location":"lulc/#land-use-land-cover-lulc-classification","title":"Land Use / Land Cover (LULC) Classification","text":""},{"location":"lulc/#1-spectral-pattern-recognition","title":"1. Spectral Pattern Recognition","text":"<p>The most widely used approach, distinguishing land cover classes based on:</p> <ul> <li>Differences in spectral reflectance (or DN values) across different wavelength bands.</li> <li>Works well when spectral separability is high (e.g., water vs vegetation vs bare soil).</li> </ul>"},{"location":"lulc/#2-spatial-pattern-recognition","title":"2. Spatial Pattern Recognition","text":"<p>This method adds texture analysis and spatial context into classification. This can involve:</p> <ul> <li>Measuring texture (e.g., homogeneity, contrast, entropy).</li> <li>Considering shapes, sizes, and spatial relationships between objects.</li> <li>Particularly useful in high-resolution imagery (e.g., urban mapping).</li> </ul>"},{"location":"lulc/#3-temporal-pattern-recognition","title":"3. Temporal Pattern Recognition","text":"<p>For dynamic landscapes, you can leverage:</p> <ul> <li>Multi-temporal data: Changes in spectral reflectance over time (e.g., phenological cycles in vegetation).</li> <li>Derived indices over time: Time-series analysis of NDVI or other spectral indices.</li> </ul>"},{"location":"lulc/#training-samples-key-characteristics","title":"Training Samples - Key Characteristics","text":"<p>For supervised classification, training samples must follow these criteria:</p>"},{"location":"lulc/#number-of-pixels","title":"Number of Pixels","text":"<ul> <li>Minimum: 10-25n pixels (where <code>n</code> = number of spectral bands).</li> <li>Recommended: Each class should have at least 100n pixels.</li> </ul>"},{"location":"lulc/#quality-factors","title":"Quality Factors","text":"<ul> <li>Size: Large enough to capture within-class spectral variability.</li> <li>Shape: Ideally compact and contiguous.</li> <li>Geographic Distribution: Spread across the image, covering different terrain/conditions.</li> <li>Number of Training Areas: Several training sites per class to capture variations.</li> <li>Easy Identification: Sites should be visually distinct and geographically locatable on the image.</li> <li>Spectral Homogeneity: Each training site should have relatively uniform spectral properties representative of the class.</li> </ul>"},{"location":"lulc/#spectral-homogeneity-check","title":"Spectral Homogeneity Check","text":"<ul> <li>Before classification, plot spectral curves for all training samples.</li> <li>Spectra for pixels within each class should cluster tightly (indicating good homogeneity).</li> </ul>"},{"location":"lulc/#classifier-example-parallelepiped-box-classifier","title":"Classifier Example: Parallelepiped (Box Classifier)","text":""},{"location":"lulc/#how-it-works","title":"How it works","text":"<ul> <li>Each class is defined by upper and lower bounds in each spectral band (essentially defining an n-dimensional box for each class).</li> <li>If a pixel falls within all boxes for a class, it gets classified to that class.</li> </ul>"},{"location":"lulc/#problems-with-parallelepiped-classifier","title":"Problems with Parallelepiped Classifier","text":"<ul> <li>Sensitivity to Overlap: If two classes have overlapping boxes, the classifier either assigns one arbitrarily or flags it as unclassified.</li> <li>Rigidity: It assumes all class distributions are rectangular, which is almost never the case.</li> <li>Not Robust in Complex Spectral Spaces: It struggles with subtle class separations and noisy data.</li> <li>Prone to Overclassification: Especially if boxes are too large, leading to false positives.</li> </ul>"},{"location":"lulc/#when-to-use","title":"When to Use","text":"<ul> <li>Works reasonably well for simple, spectrally distinct classes (e.g., water vs forest).</li> <li>Avoid for complex land covers with high spectral variability (e.g., urban vs bare soil).</li> </ul>"},{"location":"lulc/Spatial-Analyst/","title":"Spatial-Analyst","text":"<p>Vector operations in Google Earth Engine (GEE) involve manipulating and analyzing vector datasets, which are typically geometries, features, or feature collections. Below is a comprehensive guide to vector operations with corresponding GEE code snippets.</p>"},{"location":"lulc/Spatial-Analyst/#1-loading-and-displaying-vector-data","title":"1. Loading and Displaying Vector Data","text":"<p>GEE allows you to import vector datasets (shapefiles, GeoJSON, etc.) as FeatureCollection.</p> <p><pre><code>// Load a built-in FeatureCollection\nvar countries = ee.FeatureCollection(\"USDOS/LSIB_SIMPLE/2017\");\n\n// Display the FeatureCollection\nMap.centerObject(countries, 2);\nMap.addLayer(countries, {}, \"Countries\");\n</code></pre> 2. Filtering Features Filtering allows selecting specific features from a FeatureCollection based on attributes or spatial constraints.</p> <p>a. Attribute-based Filtering <pre><code>// Filter countries by name\nvar usa = countries.filter(ee.Filter.eq('country_na', 'United States'));\n\n// Display the filtered feature\nMap.addLayer(usa, {color: 'blue'}, 'USA');\n</code></pre> b. Spatial Filtering <pre><code>// Define a geometry\nvar point = ee.Geometry.Point([-100, 40]);\n\n// Find countries that intersect with the point\nvar intersecting = countries.filterBounds(point);\n\n// Display the result\nMap.addLayer(intersecting, {color: 'red'}, 'Intersecting Countries');\n</code></pre> 3. Creating Geometries GEE supports creating geometries such as points, lines, and polygons.</p> <p><pre><code>// Create a point\nvar point = ee.Geometry.Point([-122.082, 37.42]);\n\n// Create a line\nvar line = ee.Geometry.LineString([[-122.1, 37.4], [-122.0, 37.5]]);\n\n// Create a polygon\nvar polygon = ee.Geometry.Polygon([\n  [[-122.1, 37.4], [-122.0, 37.4], [-122.0, 37.5], [-122.1, 37.5], [-122.1, 37.4]]\n]);\n\n// Display geometries\nMap.addLayer(point, {color: 'green'}, 'Point');\nMap.addLayer(line, {color: 'blue'}, 'Line');\nMap.addLayer(polygon, {color: 'red'}, 'Polygon');\n</code></pre> 4. Buffering enlarges geometries by a specified distance. </p> <p><pre><code>// Create a buffer around the point\nvar bufferedPoint = point.buffer(10000); // 10 km buffer\n\n// Display the buffered geometry\nMap.addLayer(bufferedPoint, {color: 'yellow'}, 'Buffered Point');\n</code></pre> 5. Clipping restricts the extent of a geometry to another geometry. </p> <p><pre><code>// Clip the countries dataset to a specific polygon\nvar clipped = countries.clip(polygon);\n\n// Display the clipped features\nMap.addLayer(clipped, {color: 'purple'}, 'Clipped Countries');\n</code></pre> 6. Dissolving Features </p> <p>Dissolving merges features into a single geometry.</p> <p><pre><code>// Dissolve all countries into a single geometry\nvar dissolved = countries.geometry();\n\n// Display the dissolved geometry\nMap.addLayer(dissolved, {color: 'gray'}, 'Dissolved Countries');\n</code></pre> 7. Calculating Area and Length You can calculate the area of polygons or the length of lines.</p> <p><pre><code>// Calculate the area of a polygon\nvar area = polygon.area().divide(1e6); // Convert to square kilometers\nprint('Polygon area (km\u00b2):', area);\n\n// Calculate the length of a line\nvar length = line.length().divide(1000); // Convert to kilometers\nprint('Line length (km):', length);\n</code></pre> 8. Joining FeatureCollections GEE supports spatial and attribute-based joins between feature collections.</p> <p>a. Spatial Join <pre><code>// Define another FeatureCollection\nvar points = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([-122.08, 37.43]), {name: 'A'}),\n  ee.Feature(ee.Geometry.Point([-122.1, 37.4]), {name: 'B'})\n]);\n\n// Join points to countries they fall within\nvar spatialJoin = ee.Join.inner().apply({\n  primary: countries,\n  secondary: points,\n  condition: ee.Filter.intersects('.geo', null, '.geo')\n});\n\n// Display results\nprint('Spatial join result:', spatialJoin);\n</code></pre></p> <p>b. Attribute Join <pre><code>// Create two FeatureCollections with matching attributes\nvar featuresA = ee.FeatureCollection([\n  ee.Feature(null, {id: 1, value: 'A'}),\n  ee.Feature(null, {id: 2, value: 'B'})\n]);\n\nvar featuresB = ee.FeatureCollection([\n  ee.Feature(null, {id: 1, description: 'First'}),\n  ee.Feature(null, {id: 2, description: 'Second'})\n]);\n\n// Perform an inner join based on the 'id' attribute\nvar attributeJoin = ee.Join.inner().apply({\n  primary: featuresA,\n  secondary: featuresB,\n  condition: ee.Filter.equals({leftField: 'id', rightField: 'id'})\n});\n\n// Display the joined collection\nprint('Attribute join result:', attributeJoin);\n</code></pre> 9. Union of Geometries Union combines multiple geometries into one, merging their boundaries.</p> <p><pre><code>// Define two polygons\nvar polygon1 = ee.Geometry.Polygon([\n  [[-122.1, 37.4], [-122.0, 37.4], [-122.0, 37.5], [-122.1, 37.5], [-122.1, 37.4]]\n]);\nvar polygon2 = ee.Geometry.Polygon([\n  [[-122.05, 37.45], [-122.02, 37.45], [-122.02, 37.48], [-122.05, 37.48], [-122.05, 37.45]]\n]);\n\n// Perform the union\nvar unioned = polygon1.union(polygon2);\n\n// Display the unioned geometry\nMap.addLayer(unioned, {color: 'orange'}, 'Unioned Geometry');\n</code></pre> 10. Intersection of Geometries Intersection returns the overlapping area of two geometries.</p> <p><pre><code>// Find the intersection of two polygons\nvar intersection = polygon1.intersection(polygon2);\n\n// Display the intersection\nMap.addLayer(intersection, {color: 'blue'}, 'Intersection Geometry');\n</code></pre> 11. Difference of Geometries Difference removes the overlapping area from one geometry.</p> <p><pre><code>// Find the difference between two polygons\nvar difference = polygon1.difference(polygon2);\n\n// Display the difference\nMap.addLayer(difference, {color: 'red'}, 'Difference Geometry');\n</code></pre> 12. Simplifying Geometries Simplification reduces the complexity of geometries while maintaining their general shape.</p> <p><pre><code>// Simplify a polygon\nvar simplified = polygon.simplify(100); // Tolerance of 100 meters\n\n// Display the simplified geometry\nMap.addLayer(simplified, {color: 'green'}, 'Simplified Polygon');\n</code></pre> 13. Reducing FeatureCollections You can reduce a FeatureCollection into a single geometry or property summary.</p> <p>a. Reduce to Geometry <pre><code>// Combine all features into one geometry\nvar reducedGeometry = countries.union();\n\n// Display the reduced geometry\nMap.addLayer(reducedGeometry, {color: 'purple'}, 'Reduced Geometry');\n</code></pre> b. Reduce by Property <pre><code>// Calculate the total area of all features in the collection\nvar totalArea = countries.reduceColumns({\n  reducer: ee.Reducer.sum(),\n  selectors: ['shape_area'] // Replace with the relevant property in your dataset\n});\n\n// Print the result\nprint('Total Area:', totalArea);\n</code></pre> 14. Adding and Modifying Properties You can add or modify properties of a Feature or FeatureCollection.</p> <p><pre><code>// Add a property to a feature\nvar featureWithProperty = ee.Feature(point, {name: 'Sample Point'});\n\n// Modify an existing property\nvar updatedFeature = featureWithProperty.set('name', 'Updated Point');\n\n// Display the properties\nprint('Updated Feature:', updatedFeature);\n</code></pre> 15. Exporting Vector Data GEE allows you to export vector data for use outside the platform.</p> <p><pre><code>// Export a FeatureCollection as a shapefile\nExport.table.toDrive({\n  collection: countries,\n  description: 'CountriesExport',\n  fileFormat: 'SHP'\n});\n</code></pre> 16. Rasterizing Vector Data You can convert vector data to raster format using a property as pixel value.</p> <pre><code>// Rasterize the countries dataset with a constant value\nvar rasterized = countries.reduceToImage({\n  properties: ['shape_area'], // Replace with relevant property\n  reducer: ee.Reducer.first()\n});\n\n// Display the rasterized data\nMap.addLayer(rasterized, {min: 0, max: 1e12, palette: ['white', 'green']}, 'Rasterized Countries');\n</code></pre> <ol> <li>Merging FeatureCollections Merging combines multiple FeatureCollections into one.</li> </ol> <p><pre><code>// Define two small FeatureCollections\nvar collection1 = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([-122.1, 37.4]), {name: 'A'}),\n  ee.Feature(ee.Geometry.Point([-122.2, 37.5]), {name: 'B'})\n]);\n\nvar collection2 = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([-122.3, 37.6]), {name: 'C'}),\n  ee.Feature(ee.Geometry.Point([-122.4, 37.7]), {name: 'D'})\n]);\n\n// Merge the two collections\nvar mergedCollection = collection1.merge(collection2);\n\n// Display the merged collection\nMap.addLayer(mergedCollection, {color: 'blue'}, 'Merged Collection');\nprint('Merged Collection:', mergedCollection);\n</code></pre> 18. Splitting FeatureCollections Splitting separates a FeatureCollection into subsets based on a property or condition.</p> <p><pre><code>// Filter features with a specific condition\nvar subset1 = mergedCollection.filter(ee.Filter.stringStartsWith('name', 'A'));\nvar subset2 = mergedCollection.filter(ee.Filter.stringStartsWith('name', 'B'));\n\n// Display subsets\nMap.addLayer(subset1, {color: 'red'}, 'Subset 1');\nMap.addLayer(subset2, {color: 'green'}, 'Subset 2');\n</code></pre> 19. Sampling FeatureCollections Sampling extracts points, lines, or polygons from a FeatureCollection based on certain conditions.</p> <p><pre><code>// Generate random points within the unioned geometry\nvar randomPoints = ee.FeatureCollection.randomPoints({\n  region: unioned,\n  points: 10\n});\n\n// Display random points\nMap.addLayer(randomPoints, {color: 'orange'}, 'Random Points');\n</code></pre> 20. Buffering Multiple Features Buffering can be applied to all features in a FeatureCollection.</p> <p><pre><code>// Buffer all features in the merged collection\nvar bufferedFeatures = mergedCollection.map(function(feature) {\n  return feature.buffer(5000); // 5 km buffer\n});\n\n// Display buffered features\nMap.addLayer(bufferedFeatures, {color: 'yellow'}, 'Buffered Features');\n</code></pre> 21. Reprojecting Vector Data Reprojection changes the coordinate system of geometries.</p> <p><pre><code>// Reproject a geometry to a new CRS (e.g., EPSG:3857)\nvar reprojected = polygon.transform('EPSG:3857');\n\n// Display reprojected geometry\nMap.addLayer(reprojected, {color: 'purple'}, 'Reprojected Geometry');\n</code></pre> 22. Exporting to Other Formats GEE allows exporting vector data in multiple formats, such as GeoJSON.</p> <p><pre><code>// Export FeatureCollection to GeoJSON\nExport.table.toDrive({\n  collection: countries,\n  description: 'CountriesExportGeoJSON',\n  fileFormat: 'GeoJSON'\n});\n</code></pre> 23. Mapping Functions on FeatureCollections The map function can apply transformations to every feature in a FeatureCollection.</p> <p><pre><code>// Add a new property to all features\nvar updatedCollection = mergedCollection.map(function(feature) {\n  return feature.set('category', 'Test Category');\n});\n\n// Print the updated collection\nprint('Updated Collection:', updatedCollection);\n</code></pre> 24. Converting Between Geometries You can convert between geometry types, such as from points to lines.</p> <p><pre><code>// Create a line from the points in the FeatureCollection\nvar lineFromPoints = mergedCollection.geometry().dissolve();\n\n// Display the generated line\nMap.addLayer(lineFromPoints, {color: 'cyan'}, 'Line from Points');\n</code></pre> 25. Calculating Feature Stats Calculate statistics (e.g., mean, sum) for numeric properties in a FeatureCollection.</p> <p><pre><code>// Reduce properties in the FeatureCollection\nvar stats = mergedCollection.reduceColumns({\n  reducer: ee.Reducer.mean(),\n  selectors: ['name_length'] // Replace with a valid numeric property\n});\n\n// Print the stats\nprint('Feature Stats:', stats);\n\n26. Advanced Spatial Joins\nSpatial joins in GEE can perform operations such as nearest-neighbor associations or finding features within a specific distance.\n\na. Nearest Neighbor Join\n```javascript\n\n// Define two FeatureCollections: points and polygons\nvar polygons = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Polygon([[\n    [-122.1, 37.4], [-122.0, 37.4], [-122.0, 37.5], [-122.1, 37.5], [-122.1, 37.4]\n  ]]), {id: 'Polygon1'}),\n  ee.Feature(ee.Geometry.Polygon([[\n    [-122.2, 37.6], [-122.1, 37.6], [-122.1, 37.7], [-122.2, 37.7], [-122.2, 37.6]\n  ]]), {id: 'Polygon2'})\n]);\n\nvar points = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([-122.15, 37.45]), {name: 'PointA'}),\n  ee.Feature(ee.Geometry.Point([-122.05, 37.65]), {name: 'PointB'})\n]);\n\n// Find the nearest polygon for each point\nvar nearest = ee.Join.saveBest({\n  matchKey: 'nearest_polygon',\n  measureKey: 'distance'\n}).apply({\n  primary: points,\n  secondary: polygons,\n  condition: ee.Filter.proximity({\n    distance: 100000, // 100 km\n    rightField: '.geo'\n  })\n});\n\n// Print and display results\nprint('Nearest polygons:', nearest);\nMap.addLayer(points, {color: 'red'}, 'Points');\nMap.addLayer(polygons, {color: 'blue'}, 'Polygons');\n</code></pre> 27. Finding Features Within a Distance Find features within a specified distance from another geometry.</p> <p><pre><code>// Find polygons within 20 km of a point\nvar bufferPoint = ee.Geometry.Point([-122.1, 37.5]).buffer(20000); // 20 km buffer\nvar nearbyPolygons = polygons.filterBounds(bufferPoint);\n\n// Display the nearby polygons\nMap.addLayer(bufferPoint, {color: 'yellow'}, 'Buffer');\nMap.addLayer(nearbyPolygons, {color: 'green'}, 'Nearby Polygons');\n</code></pre> 28. Converting Raster to Vector You can vectorize raster data by extracting boundaries or regions.</p> <p><pre><code>// Load a raster image (e.g., a land cover dataset)\nvar landcover = ee.Image('MODIS/006/MCD12Q1/2016_01_01')\n  .select('LC_Type1');\n\n// Extract regions of a specific land cover type (e.g., forests)\nvar forest = landcover.eq(1); // Assuming class 1 represents forest\n\n// Vectorize the raster data\nvar forestVector = forest.reduceToVectors({\n  geometryType: 'polygon',\n  scale: 500,\n  maxPixels: 1e8\n});\n\n// Display the vectorized data\nMap.addLayer(forest, {min: 0, max: 1, palette: ['white', 'green']}, 'Forest Raster');\nMap.addLayer(forestVector, {color: 'green'}, 'Forest Vector');\n</code></pre> 29. Splitting Features by Properties Split a FeatureCollection into multiple groups based on a property.</p> <p><pre><code>// Split polygons by their 'id' property\nvar groups = polygons.aggregate_array('id').distinct();\ngroups.evaluate(function(ids) {\n  ids.forEach(function(id) {\n    var group = polygons.filter(ee.Filter.eq('id', id));\n    Map.addLayer(group, {}, 'Group: ' + id);\n  });\n});\n</code></pre> 30. Calculating Distance Between Features Compute distances between points, lines, or polygons.</p> <p><pre><code>// Calculate distance between a point and a polygon\nvar distance = points.first().geometry().distance(polygons.first().geometry());\nprint('Distance (meters):', distance);\n</code></pre> 31. Using Vector Data in Machine Learning Vector data can serve as training data for machine learning models in GEE.</p> <p><pre><code>// Define training points with labels\nvar trainingPoints = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([-122.1, 37.4]), {landcover: 0}), // Water\n  ee.Feature(ee.Geometry.Point([-122.1, 37.5]), {landcover: 1})  // Forest\n]);\n\n// Load an image to classify (e.g., MODIS)\nvar image = ee.Image('MODIS/006/MCD12Q1/2016_01_01')\n  .select('LC_Type1');\n\n// Sample the image at training points\nvar trainingData = image.sampleRegions({\n  collection: trainingPoints,\n  properties: ['landcover'],\n  scale: 500\n});\n\n// Train a classifier\nvar classifier = ee.Classifier.smileCart().train({\n  features: trainingData,\n  classProperty: 'landcover',\n  inputProperties: ['LC_Type1']\n});\n\n// Classify the image\nvar classified = image.classify(classifier);\n\n// Display the classified image\nMap.addLayer(classified, {min: 0, max: 1, palette: ['blue', 'green']}, 'Classified');\n</code></pre> 32. Exporting Vector Subsets Export a subset of vector data after applying filters.</p> <p><pre><code>// Export filtered polygons\nExport.table.toDrive({\n  collection: nearbyPolygons,\n  description: 'FilteredPolygons',\n  fileFormat: 'KML'\n});\n</code></pre> 33. Custom Reducers with FeatureCollections Custom reducers allow aggregation of numeric properties or geometries in complex ways.</p> <p>a. Summarizing Numeric Properties <pre><code>// Create a FeatureCollection with numeric properties\nvar features = ee.FeatureCollection([\n  ee.Feature(null, {value: 10, category: 'A'}),\n  ee.Feature(null, {value: 20, category: 'B'}),\n  ee.Feature(null, {value: 30, category: 'A'})\n]);\n\n// Summarize by category using group reducer\nvar grouped = features.reduceColumns({\n  reducer: ee.Reducer.sum().group(1),\n  selectors: ['value', 'category']\n});\n\n// Print the grouped result\nprint('Grouped Sum by Category:', grouped);\nb. Reducing Geometries\n```javascript\n\n// Calculate the union of geometries in a FeatureCollection\nvar geometryUnion = features.geometry().union();\n\n// Display the unioned geometry\nMap.addLayer(geometryUnion, {color: 'orange'}, 'Union of Geometries');\n</code></pre> 34. Handling Complex Multi-Polygons Manipulating multi-polygon geometries for tasks such as splitting, simplifying, or calculating metrics.</p> <p><pre><code>// Define a multi-polygon\nvar multiPolygon = ee.Geometry.MultiPolygon([\n  [[[-122.1, 37.4], [-122.0, 37.4], [-122.0, 37.5], [-122.1, 37.5], [-122.1, 37.4]]],\n  [[[-122.2, 37.6], [-122.1, 37.6], [-122.1, 37.7], [-122.2, 37.7], [-122.2, 37.6]]]\n]);\n\n// Split the multi-polygon into individual polygons\nvar splitPolygons = multiPolygon.geometries();\n\n// Print each split polygon\nprint('Individual Polygons:', splitPolygons);\n\n// Display the multi-polygon\nMap.addLayer(multiPolygon, {color: 'purple'}, 'Multi-Polygon');\n</code></pre> 35. Buffer with Varying Distances Apply a buffer with dynamic distances for each feature.</p> <p><pre><code>// Add a buffer size property to features\nvar bufferedFeatures = features.map(function(feature) {\n  var bufferSize = feature.get('value'); // Use 'value' as buffer size\n  return feature.buffer(bufferSize);\n});\n\n// Display buffered features\nMap.addLayer(bufferedFeatures, {color: 'green'}, 'Buffered Features with Varying Distances');\n</code></pre> 36. Convex Hull of Geometries Convex hull computes the smallest convex polygon enclosing a geometry or a collection of geometries.</p> <p><pre><code>// Create a convex hull of the FeatureCollection\nvar convexHull = features.geometry().convexHull();\n\n// Display the convex hull\nMap.addLayer(convexHull, {color: 'red'}, 'Convex Hull');\n</code></pre> 37. Centroids of Geometries Calculate the centroid of a geometry or each feature in a FeatureCollection.</p> <p><pre><code>// Calculate the centroid of each feature\nvar centroids = features.map(function(feature) {\n  return feature.setGeometry(feature.geometry().centroid());\n});\n\n// Display the centroids\nMap.addLayer(centroids, {color: 'blue'}, 'Centroids');\n</code></pre> 38. Sampling Raster Data with FeatureCollections Extract raster values at vector locations.</p> <p><pre><code>// Load a raster image\nvar elevation = ee.Image('CGIAR/SRTM90_V4');\n\n// Sample elevation values at points\nvar sampled = points.map(function(feature) {\n  var elevationValue = elevation.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: feature.geometry(),\n    scale: 30\n  }).get('elevation');\n  return feature.set('elevation', elevationValue);\n});\n\n// Print the sampled points with elevation values\nprint('Sampled Points with Elevation:', sampled);\n\n// Display sampled points\nMap.addLayer(sampled, {color: 'yellow'}, 'Sampled Elevation Points');\n</code></pre> 39. Combining Vector Data with Imagery Masks Apply vector geometries as masks to filter raster imagery.</p> <p><pre><code>// Load a raster image\nvar landcover = ee.Image('MODIS/006/MCD12Q1/2016_01_01').select('LC_Type1');\n\n// Create a mask from a polygon\nvar polygonMask = landcover.updateMask(polygon.contains(landcover.geometry()));\n\n// Display the masked raster\nMap.addLayer(polygonMask, {min: 1, max: 17, palette: ['blue', 'green']}, 'Masked Landcover');\n</code></pre> 40. Real-World Application: Mapping Urban Growth Use vector operations for practical applications like mapping urban growth.</p> <p><pre><code>// Load urban areas for two different years\nvar urban2000 = ee.FeatureCollection('users/yourusername/urban2000');\nvar urban2020 = ee.FeatureCollection('users/yourusername/urban2020');\n\n// Calculate the difference (new urban areas in 2020)\nvar newUrban = urban2020.filterBounds(urban2000.geometry().difference(urban2020.geometry()));\n\n// Display results\nMap.addLayer(urban2000, {color: 'gray'}, 'Urban Areas 2000');\nMap.addLayer(urban2020, {color: 'blue'}, 'Urban Areas 2020');\nMap.addLayer(newUrban, {color: 'red'}, 'New Urban Areas');\n</code></pre> 41. Simplifying Complex FeatureCollections Reduce the complexity of geometries in a FeatureCollection for faster processing.</p> <p><pre><code>// Simplify geometries in a FeatureCollection\nvar simplifiedFeatures = features.map(function(feature) {\n  return feature.setGeometry(feature.geometry().simplify(100)); // Simplify with a tolerance of 100 meters\n});\n\n// Display simplified features\nMap.addLayer(simplifiedFeatures, {color: 'cyan'}, 'Simplified Features');\n</code></pre> 42. Overlay Analysis Perform overlay analysis to calculate spatial relationships between geometries, such as intersections and unions.</p> <p>a. Intersect Two FeatureCollections <pre><code>// Find intersections between two FeatureCollections\nvar intersections = polygons.map(function(polygon) {\n  return points.filterBounds(polygon.geometry()).map(function(point) {\n    return point.setGeometry(point.geometry().intersection(polygon.geometry()));\n  });\n}).flatten();\n\n// Display the intersections\nMap.addLayer(intersections, {color: 'orange'}, 'Intersections');\n</code></pre> b. Combine Multiple Layers Using Union <pre><code>// Union all geometries in two FeatureCollections\nvar unionedFeatures = polygons.merge(points).geometry().union();\n\n// Display the unioned geometry\nMap.addLayer(unionedFeatures, {color: 'purple'}, 'Unioned Features');\n</code></pre> 43. Clipping Rasters with Vectors Use vector data to clip raster imagery.</p> <p><pre><code>// Clip a raster using a polygon\nvar clippedRaster = elevation.clip(polygon);\n\n// Display the clipped raster\nMap.addLayer(clippedRaster, {min: 0, max: 4000, palette: ['white', 'black']}, 'Clipped Raster');\n</code></pre> 44. Creating Grids or Tessellations Generate grids or tessellations over a specified region.</p> <p><pre><code>// Define a bounding box\nvar boundingBox = ee.Geometry.Rectangle([-122.2, 37.4, -121.8, 37.8]);\n\n// Create a grid of 0.01-degree squares\nvar grid = ee.FeatureCollection(\n  ee.Image().paint(boundingBox, 1).reduceToVectors({\n    geometryType: 'polygon',\n    reducer: ee.Reducer.countEvery(),\n    scale: 1000,\n    geometry: boundingBox\n  })\n);\n\n// Display the grid\nMap.addLayer(grid, {color: 'blue'}, 'Grid');\n</code></pre> 45. Working with Multi-Feature Layers Handle layers with mixed geometry types.</p> <p><pre><code>// Filter and separate geometry types\nvar pointsOnly = mergedCollection.filter(ee.Filter.eq('type', 'Point'));\nvar polygonsOnly = mergedCollection.filter(ee.Filter.eq('type', 'Polygon'));\n\n// Display filtered layers\nMap.addLayer(pointsOnly, {color: 'red'}, 'Points Only');\nMap.addLayer(polygonsOnly, {color: 'green'}, 'Polygons Only');\n</code></pre> 46. Geometry Metrics Calculate metrics like area, length, or perimeter for geometries.</p> <p><pre><code>// Calculate area of polygons\nvar areas = polygons.map(function(feature) {\n  var area = feature.geometry().area(); // Area in square meters\n  return feature.set('area', area);\n});\n\n// Print areas\nprint('Polygons with Areas:', areas);\n</code></pre> 47. Dissolving Features by Attribute Group and merge features based on a common property.</p> <p><pre><code>// Dissolve polygons by 'id' attribute\nvar dissolved = polygons.reduceToImage(['id'], ee.Reducer.mode()).reduceToVectors({\n  geometryType: 'polygon',\n  scale: 1000\n});\n\n// Display dissolved features\nMap.addLayer(dissolved, {color: 'orange'}, 'Dissolved Features');\n</code></pre> 48. Spatial Weighting Assign weights to features based on proximity or density.</p> <p><pre><code>// Create a distance-based weighting image\nvar distanceWeights = ee.Image().paint(points, 1).fastDistanceTransform({\n  maxDistance: 10000, // Max distance in meters\n  units: 'meters'\n});\n\n// Display weights\nMap.addLayer(distanceWeights, {min: 0, max: 10000, palette: ['white', 'blue']}, 'Distance Weights');\n</code></pre> 49. Spatial Autocorrelation Analysis Assess spatial patterns and relationships between features.</p> <p><pre><code>// Calculate spatial autocorrelation using Moran's I\nvar autocorrelation = features.map(function(feature) {\n  var neighbors = features.filterBounds(feature.geometry().buffer(1000));\n  return feature.set('neighborCount', neighbors.size());\n});\n\n// Print results\nprint('Spatial Autocorrelation:', autocorrelation);\n</code></pre> 50. Combining Vector and Raster in Zonal Analysis Use vector polygons to summarize raster data.</p> <p><pre><code>// Calculate mean elevation within each polygon\nvar zonalStats = polygons.map(function(feature) {\n  var meanElevation = elevation.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: feature.geometry(),\n    scale: 30\n  }).get('elevation');\n  return feature.set('mean_elevation', meanElevation);\n});\n\n// Print zonal stats\nprint('Zonal Statistics:', zonalStats);\n</code></pre> 51. Using Weighted Overlay for Multi-Criteria Analysis Combine multiple raster layers with vector weights for decision-making applications.</p> <p><pre><code>// Load multiple raster layers (e.g., slope and land cover)\nvar slope = ee.Terrain.slope(elevation);\nvar landcover = ee.Image('MODIS/006/MCD12Q1/2016_01_01').select('LC_Type1');\n\n// Assign weights to layers\nvar weightedOverlay = slope.multiply(0.4).add(landcover.multiply(0.6));\n\n// Mask by a polygon region\nvar maskedOverlay = weightedOverlay.updateMask(polygon);\n\n// Display the weighted overlay\nMap.addLayer(maskedOverlay, {min: 0, max: 1, palette: ['white', 'red']}, 'Weighted Overlay');\n</code></pre> 52. Extracting Sub-Geometries Extract specific parts of geometries like rings or interiors.</p> <p><pre><code>// Extract the outer ring of a polygon\nvar outerRing = polygon.geometries().get(0);\n\n// Convert to a new geometry for visualization\nvar outerGeometry = ee.Geometry(outerRing);\n\n// Display the outer ring\nMap.addLayer(outerGeometry, {color: 'blue'}, 'Outer Ring');\n</code></pre> 53. Computing Voronoi Diagrams Create Voronoi diagrams from point geometries.</p> <p><pre><code>// Generate Voronoi polygons from points\nvar voronoi = points.reduceToImage(['name'], ee.Reducer.first())\n  .fastDistanceTransform(5000)\n  .reduceToVectors({geometryType: 'polygon', scale: 500});\n\n// Display Voronoi diagram\nMap.addLayer(voronoi, {color: 'purple'}, 'Voronoi Diagram');\n</code></pre> 54. Hotspot Analysis Identify areas of high density or significant activity.</p> <p><pre><code>// Count the number of points in grid cells\nvar hotspotImage = ee.Image().paint(points, 1).reduceNeighborhood({\n  reducer: ee.Reducer.count(),\n  kernel: ee.Kernel.square(1)\n});\n\n// Display hotspots\nMap.addLayer(hotspotImage, {min: 0, max: 10, palette: ['white', 'red']}, 'Hotspots');\n</code></pre> 55. Integrating External Data Sources Load vector data from external files, such as GeoJSON or KML.</p> <p><pre><code>// Import a GeoJSON file from Google Drive\nvar externalData = ee.FeatureCollection('users/yourusername/geojson_data');\n\n// Display external data\nMap.addLayer(externalData, {color: 'green'}, 'External Data');\n</code></pre> 56. Topology Validation Ensure vector data meets topological rules, such as non-overlapping polygons.</p> <p><pre><code>// Validate topology of a FeatureCollection\nvar validatedFeatures = polygons.map(function(feature) {\n  var isValid = feature.geometry().isValid();\n  return feature.set('is_valid', isValid);\n});\n\n// Filter for invalid features\nvar invalidFeatures = validatedFeatures.filter(ee.Filter.eq('is_valid', false));\n\n// Display invalid features\nMap.addLayer(invalidFeatures, {color: 'red'}, 'Invalid Features');\n</code></pre> 57. Custom Feature Attributes Add attributes based on calculations or external logic.</p> <p><pre><code>// Add a custom property based on area\nvar updatedFeatures = polygons.map(function(feature) {\n  var area = feature.geometry().area();\n  return feature.set('size_category', area.gt(1000000) ? 'Large' : 'Small');\n});\n\n// Display categorized features\nprint('Features with Size Categories:', updatedFeatures);\n</code></pre> 58. Using Vector Layers for Visualization Create custom symbology for vector layers.</p> <p><pre><code>// Style features based on a property\nvar styledFeatures = polygons.map(function(feature) {\n  var color = feature.get('id') === 'Polygon1' ? 'red' : 'blue';\n  return feature.set('style', {color: color, width: 2});\n});\n\n// Display styled features\nMap.addLayer(styledFeatures.style(), {}, 'Styled Features');\n</code></pre> 59. Calculating Density Maps Create density maps from point data.</p> <p><pre><code>// Generate a density map\nvar density = ee.Image().paint(points, 1).convolve(ee.Kernel.gaussian(5, 3, 'meters'));\n\n// Display the density map\nMap.addLayer(density, {min: 0, max: 10, palette: ['white', 'blue']}, 'Density Map');\n</code></pre> 60. Detecting Changes Over Time Analyze changes between different time periods using vector and raster layers.</p> <p><pre><code>// Detect changes between two time periods\nvar change = urban2020.difference(urban2000);\n\n// Display changes\nMap.addLayer(change, {color: 'red'}, 'Urban Growth');\n</code></pre> 61. Time-Series Analysis with Vector Features Track changes over time using vector data.</p> <p><pre><code>// Create a time-series property for features\nvar timeSeries = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([-122.2, 37.5]), {year: 2000, population: 500}),\n  ee.Feature(ee.Geometry.Point([-122.2, 37.5]), {year: 2010, population: 800}),\n  ee.Feature(ee.Geometry.Point([-122.2, 37.5]), {year: 2020, population: 1200})\n]);\n\n// Filter by year and analyze changes\nvar year2000 = timeSeries.filter(ee.Filter.eq('year', 2000));\nvar year2020 = timeSeries.filter(ee.Filter.eq('year', 2020));\n\n// Print filtered data\nprint('Data for Year 2000:', year2000);\nprint('Data for Year 2020:', year2020);\n</code></pre> 62. Vector Rasterization Convert vector data into raster format for pixel-based analysis.</p> <p><pre><code>// Rasterize a FeatureCollection based on a property\nvar rasterized = polygons.reduceToImage({\n  properties: ['id'],\n  reducer: ee.Reducer.first()\n});\n\n// Display rasterized data\nMap.addLayer(rasterized, {min: 0, max: 10, palette: ['yellow', 'orange']}, 'Rasterized Data');\n</code></pre> 63. Custom Kernels for Proximity Analysis Design and apply custom kernels to analyze proximity or influence.</p> <p><pre><code>// Create a custom kernel\nvar kernel = ee.Kernel.circle({\n  radius: 1000,\n  units: 'meters',\n  normalize: true\n});\n\n// Apply the kernel to analyze point influence\nvar proximity = ee.Image().paint(points, 1).convolve(kernel);\n\n// Display proximity map\nMap.addLayer(proximity, {min: 0, max: 1, palette: ['white', 'blue']}, 'Proximity Map');\n</code></pre> 64. Dynamic Region Selection Allow interactive selection of regions for processing.</p> <p><pre><code>// Define a region dynamically (e.g., a manually drawn polygon)\nvar drawnRegion = ee.Geometry.Polygon([\n  [[-122.3, 37.6], [-122.3, 37.8], [-122.1, 37.8], [-122.1, 37.6]]\n]);\n\n// Clip a raster using the dynamic region\nvar clippedRegion = elevation.clip(drawnRegion);\n\n// Display the clipped raster\nMap.addLayer(clippedRegion, {min: 0, max: 4000, palette: ['white', 'black']}, 'Clipped Region');\n</code></pre> 65. Optimizing Vector Processing Improve performance for large FeatureCollections.</p> <p>a. Tile-Based Processing Divide large datasets into manageable tiles.</p> <p><pre><code>// Divide the region into tiles\nvar tiles = ee.FeatureCollection.randomPoints({\n  region: polygon,\n  points: 100,\n  seed: 42\n});\n\n// Process data tile by tile\nvar processedTiles = tiles.map(function(tile) {\n  return tile.buffer(100).intersection(polygon);\n});\n\n// Display tiles\nMap.addLayer(processedTiles, {color: 'purple'}, 'Processed Tiles');\n</code></pre> b. Filtering by Attribute Reduce computation by pre-filtering features.</p> <p><pre><code>// Filter features with an attribute condition\nvar largePolygons = polygons.filter(ee.Filter.gt('area', 1e6));\n\n// Display filtered polygons\nMap.addLayer(largePolygons, {color: 'green'}, 'Large Polygons');\n</code></pre> 66. Creating Animated Maps Visualize temporal changes with animations.</p> <p><pre><code>// Load annual data\nvar years = ee.List.sequence(2000, 2020);\nvar annualFeatures = years.map(function(year) {\n  var data = ee.FeatureCollection('users/yourusername/annual_data_' + year);\n  return data.set('year', year);\n});\n\n// Create an animation\nvar animation = ee.ImageCollection(annualFeatures).map(function(feature) {\n  return feature.set('year', feature.get('year'));\n});\n\n// Export animation\nExport.video.toDrive({\n  collection: animation,\n  description: 'AnimatedMap',\n  dimensions: 720,\n  framesPerSecond: 2\n});\n</code></pre> 67. Custom Feature Joins Join vector datasets based on spatial or attribute relationships.</p> <p><pre><code>// Perform a spatial join\nvar joined = ee.Join.saveAll('matches').apply({\n  primary: polygons,\n  secondary: points,\n  condition: ee.Filter.intersects('.geo', null, '.geo')\n});\n\n// Display joined features\nprint('Joined Features:', joined);\n</code></pre> 68. Network Analysis Analyze paths and connectivity between points.</p> <p><pre><code>// Load road network data\nvar roads = ee.FeatureCollection('users/yourusername/road_network');\n\n// Find the shortest path between points\nvar shortestPath = roads.shortestPath({\n  start: ee.Geometry.Point([-122.1, 37.6]),\n  end: ee.Geometry.Point([-121.9, 37.6])\n});\n\n// Display the shortest path\nMap.addLayer(shortestPath, {color: 'red'}, 'Shortest Path');\n</code></pre> 69. Multi-Layer Analysis Combine multiple vector and raster datasets for integrated analysis.</p> <p><pre><code>// Combine land cover and population density\nvar combined = landcover.addBands(elevation).reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: polygon,\n  scale: 30\n});\n\n// Print combined analysis result\nprint('Combined Analysis:', combined);\n</code></pre> 70. Real-Time Updates Use streaming data or real-time updates in visualization.</p> <p><pre><code>// Simulate real-time updates\nvar realTimePoints = ee.FeatureCollection.randomPoints({\n  region: polygon,\n  points: 10,\n  seed: Date.now()\n});\n\n// Update map every 5 seconds\nMap.addLayer(realTimePoints, {color: 'orange'}, 'Real-Time Points');\n</code></pre> 71. Integrating Machine Learning with Vectors Combine vector data with machine learning models for predictions.</p> <p>a. Feature Extraction for Training Use vector attributes as training data for models.</p> <p><pre><code>// Extract features from points\nvar trainingData = points.map(function(feature) {\n  var elevationValue = elevation.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: feature.geometry(),\n    scale: 30\n  }).get('elevation');\n  return feature.set('elevation', elevationValue);\n});\n\n// Print training data\nprint('Training Data:', trainingData);\n</code></pre> b. Train a Classifier Train a classifier with vector-based training data.</p> <p><pre><code>// Create a training set with land cover labels\nvar trainingSet = polygons.map(function(feature) {\n  return feature.set('label', feature.get('land_cover_type'));\n});\n\n// Train a random forest classifier\nvar classifier = ee.Classifier.smileRandomForest(10).train({\n  features: trainingSet,\n  classProperty: 'label',\n  inputProperties: ['elevation', 'slope']\n});\n\n// Print classifier\nprint('Trained Classifier:', classifier);\n</code></pre> 72. Scaling Large Region Analysis Process large regions efficiently using batch and tiling methods.</p> <p>a. Batch Export Export results for large areas using batch processing.</p> <p><pre><code>// Export large analysis results\nExport.table.toDrive({\n  collection: polygons,\n  description: 'LargeRegionAnalysis',\n  fileFormat: 'CSV'\n});\n</code></pre> b. Tiling for Scalability Divide analysis into tiles to avoid computation limits.</p> <p><pre><code>// Create a grid for tiling\nvar grid = ee.FeatureCollection.randomPoints({\n  region: ee.Geometry.BBox(-122.5, 37.5, -121.5, 38),\n  points: 100\n});\n\n// Process each tile independently\nvar tiledAnalysis = grid.map(function(tile) {\n  return tile.buffer(5000).intersection(polygon).set('tile_id', tile.get('system:index'));\n});\n\n// Display tiled results\nMap.addLayer(tiledAnalysis, {color: 'cyan'}, 'Tiled Analysis');\n</code></pre> 73. Dynamic Apps with Earth Engine Create interactive applications for visualization.</p> <p><pre><code>// Import ui module for Earth Engine Apps\nvar ui = require('users/gena/packages:ui');\n\n// Create a dynamic app\nvar slider = ui.Slider({\n  min: 0,\n  max: 100,\n  value: 50,\n  onChange: function(value) {\n    Map.layers().reset([ui.Map.Layer(elevation.multiply(value))]);\n  }\n});\n\n// Add the slider to the UI\nui.root.widgets().add(slider);\n</code></pre> 74. Custom Rasterization with Attributes Use feature attributes to create a custom raster.</p> <p><pre><code>// Rasterize features using a custom property\nvar customRaster = polygons.reduceToImage({\n  properties: ['population_density'],\n  reducer: ee.Reducer.mean()\n});\n\n// Display the custom raster\nMap.addLayer(customRaster, {min: 0, max: 500, palette: ['white', 'red']}, 'Custom Raster');\n</code></pre> 75. Spatial Correlation Analysis Analyze relationships between spatial features.</p> <p><pre><code>// Calculate Moran's I for spatial correlation\nvar moransI = polygons.aggregate_stats({\n  property: 'elevation',\n  scale: 500,\n  reducer: ee.Reducer.pearsonCorrelation()\n});\n\n// Print Moran's I result\nprint('Moran\\'s I:', moransI);\n</code></pre> 76. Edge Detection in Vector Layers Identify boundaries or edges in vector geometries.</p> <p><pre><code>// Extract edges from a polygon\nvar edges = polygons.geometry().edges();\n\n// Display edges\nMap.addLayer(edges, {color: 'black'}, 'Edges');\n</code></pre> 77. Advanced Zonal Statistics Perform advanced aggregation within vector polygons.</p> <p><pre><code>// Compute zonal statistics for multiple layers\nvar advancedZonalStats = polygons.map(function(feature) {\n  var stats = elevation.reduceRegion({\n    reducer: ee.Reducer.mean().combine({\n      reducer2: ee.Reducer.median(),\n      sharedInputs: true\n    }),\n    geometry: feature.geometry(),\n    scale: 30\n  });\n  return feature.set(stats);\n});\n\n// Print advanced zonal statistics\nprint('Advanced Zonal Statistics:', advancedZonalStats);\n</code></pre> 78. Global Region Processing Handle vector data at a global scale.</p> <p><pre><code>// Load a global dataset\nvar globalDataset = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level1');\n\n// Filter to a specific region\nvar country = globalDataset.filter(ee.Filter.eq('ADM0_NAME', 'India'));\n\n// Display the country data\nMap.addLayer(country, {color: 'blue'}, 'Country Data');\n</code></pre> 79. Time-Weighted Analysis Incorporate time as a weighting factor in vector analyses.</p> <p><pre><code>// Apply time weights to features\nvar timeWeightedData = points.map(function(feature) {\n  var timeWeight = ee.Date(feature.get('timestamp')).millis().divide(Date.now());\n  return feature.set('time_weight', timeWeight);\n});\n\n// Display weighted data\nprint('Time-Weighted Data:', timeWeightedData);\n80. Automated Workflow Integration\nCombine multiple steps into a single workflow for automation.\n\n```javascript\n\n// Automated workflow combining clipping, rasterization, and export\nvar workflowResult = polygons.reduceToImage({\n  properties: ['id'],\n  reducer: ee.Reducer.first()\n}).clip(polygon);\n\n// Export the result\nExport.image.toDrive({\n  image: workflowResult,\n  description: 'AutomatedWorkflow',\n  scale: 30,\n  region: polygon\n});\n</code></pre> 81. Integrating External APIs Connect external data sources and APIs with Earth Engine for enhanced workflows.</p> <p>a. Fetch External Data Use external APIs to fetch data and integrate it with Earth Engine.</p> <p><pre><code>// Example: Fetch weather data via a REST API\nvar apiUrl = 'https://api.open-meteo.com/v1/forecast?latitude=37.7749&amp;longitude=-122.4194&amp;daily=temperature_2m_max&amp;timezone=auto';\n\n// Simulate an API integration with an Earth Engine FeatureCollection\nvar apiData = ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([-122.4194, 37.7749]), {max_temp: 28}),\n  ee.Feature(ee.Geometry.Point([-121.8863, 37.3382]), {max_temp: 30})\n]);\n\n// Display the external data\nMap.addLayer(apiData, {color: 'red'}, 'API Data');\n</code></pre> 82. Custom Geometry Manipulation Apply complex geometry operations to refine datasets.</p> <p><pre><code>// Example: Split polygons into equal parts\nvar splitPolygons = polygons.map(function(feature) {\n  var bounds = feature.geometry().bounds();\n  var split = bounds.divide(2, 2); // Divide into 4 quadrants\n  return ee.Feature(split).set(feature.toDictionary());\n});\n\n// Display split polygons\nMap.addLayer(splitPolygons, {color: 'orange'}, 'Split Polygons');\n</code></pre> 83. Real-Time Dashboard Integration Create live dashboards for data visualization.</p> <p><pre><code>// Example: Set up a live map layer\nvar liveLayer = ui.Map.Layer(points, {color: 'blue'}, 'Live Data');\n\n// Set up a dashboard panel\nvar panel = ui.Panel({\n  widgets: [\n    ui.Label('Live Dashboard'),\n    ui.Label('Data Points: ' + points.size().getInfo())\n  ],\n  style: {width: '300px'}\n});\n\n// Add the panel and layer to the map\nui.root.add(panel);\nMap.add(liveLayer);\n</code></pre> 84. Customized Export Formats Export Earth Engine results in tailored formats.</p> <p><pre><code>// Export data as GeoJSON\nExport.table.toDrive({\n  collection: polygons,\n  description: 'CustomGeoJSON',\n  fileFormat: 'GeoJSON'\n});\n\n// Export raster data with custom scale and region\nExport.image.toDrive({\n  image: elevation.clip(polygon),\n  description: 'CustomRaster',\n  scale: 10,\n  region: polygon\n});\n</code></pre> 85. Heatmap Generation Create heatmaps based on point density or attributes.</p> <p><pre><code>// Generate a heatmap from point density\nvar heatmap = ee.Image().paint(points, 1).convolve(ee.Kernel.gaussian(2000, 'meters'));\n\n// Display the heatmap\nMap.addLayer(heatmap, {min: 0, max: 10, palette: ['white', 'blue', 'red']}, 'Heatmap');\n</code></pre> 86. Vector-Based Interpolation Perform spatial interpolation using vector data.</p> <p><pre><code>// Interpolate values between points\nvar interpolated = points.reduceToImage({\n  properties: ['value'],\n  reducer: ee.Reducer.mean()\n}).resample('bicubic');\n\n// Display interpolated results\nMap.addLayer(interpolated, {min: 0, max: 1, palette: ['white', 'green']}, 'Interpolated Data');\n</code></pre> 87. Land Use Change Detection Analyze changes in land use over time using vector data.</p> <p><pre><code>// Load historical land use data\nvar landUse2000 = ee.FeatureCollection('users/yourusername/land_use_2000');\nvar landUse2020 = ee.FeatureCollection('users/yourusername/land_use_2020');\n\n// Detect changes between years\nvar changes = landUse2020.difference(landUse2000);\n\n// Display land use changes\nMap.addLayer(changes, {color: 'red'}, 'Land Use Changes');\n</code></pre> 88. Geospatial Optimization Optimize geospatial processes, such as site selection.</p> <p><pre><code>// Example: Find optimal locations for wind farms\nvar windSpeeds = ee.Image('path_to_wind_speed_data');\nvar optimalLocations = windSpeeds.gt(10).clip(polygon);\n\n// Display optimal locations\nMap.addLayer(optimalLocations, {palette: ['green']}, 'Optimal Wind Locations');\n</code></pre> 89. Multi-Layer Buffer Analysis Buffer around multiple layers and analyze overlaps.</p> <p><pre><code>// Apply buffers to multiple feature collections\nvar bufferedPoints = points.map(function(feature) {\n  return feature.buffer(500);\n});\nvar bufferedPolygons = polygons.map(function(feature) {\n  return feature.buffer(1000);\n});\n\n// Analyze overlaps between buffers\nvar overlaps = bufferedPoints.union(bufferedPolygons);\n\n// Display overlaps\nMap.addLayer(overlaps, {color: 'purple'}, 'Buffer Overlaps');\n</code></pre> 90. Dynamic Web Map Integration Integrate Earth Engine data with web mapping libraries like Leaflet.</p> <p><pre><code>// Export a map tile for integration\nExport.map.toCloudStorage({\n  image: elevation,\n  description: 'ElevationMap',\n  bucket: 'your-bucket-name',\n  fileFormat: 'PNG',\n  path: 'maps/elevation_tiles'\n});\n\n\n91. Scalability Optimization with Parallel Processing\nOptimize workflows by leveraging Earth Engine\u2019s parallel processing capabilities.\n\na. Parallel Feature Mapping\nDistribute operations across features in a FeatureCollection.\n\n```javascript\n\n// Apply operations in parallel\nvar parallelProcessing = polygons.map(function(feature) {\n  var clippedImage = elevation.clip(feature.geometry());\n  var meanElevation = clippedImage.reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: feature.geometry(),\n    scale: 30\n  });\n  return feature.set('mean_elevation', meanElevation.get('elevation'));\n});\n\n// Display results\nprint('Parallel Processing Results:', parallelProcessing);\n</code></pre> b. Chunk-Based Processing Divide large datasets into smaller chunks for efficient processing.</p> <p><pre><code>// Split dataset into chunks\nvar chunkSize = 100;\nvar totalSize = polygons.size().getInfo();\nfor (var i = 0; i &lt; totalSize; i += chunkSize) {\n  var chunk = polygons.toList(chunkSize, i);\n  var chunkFc = ee.FeatureCollection(chunk);\n  // Perform processing on each chunk\n  print('Processing Chunk:', chunkFc);\n}\n</code></pre> 92. Integration with Google Cloud Services Enhance workflows with Google Cloud resources like BigQuery and Cloud Storage.</p> <p>a. BigQuery Integration Export vector analysis results to BigQuery.</p> <p><pre><code>// Export analysis results to BigQuery\nExport.table.toBigQuery({\n  collection: polygons,\n  description: 'ExportToBigQuery',\n  tableId: 'earth_engine_results',\n  dataset: 'geo_analysis',\n  projectId: 'your-project-id'\n});\n</code></pre> b. Cloud Storage Integration Store and access large raster data using Google Cloud Storage.</p> <pre><code>// Export raster data to Cloud Storage\nExport.image.toCloudStorage({\n  image: elevation.clip(polygon),\n  description: 'ElevationToCloudStorage',\n  bucket: 'your-bucket-name',\n  fileNamePrefix: 'elevation_raster',\n  scale: 30,\n  region: polygon\n});\n</code></pre>"},{"location":"lulc/Supervised%20LULC%20Classification%20GEE/","title":"Supervised LULC Classification GEE","text":""},{"location":"lulc/Supervised%20LULC%20Classification%20GEE/#overview-of-steps","title":"\ud83d\udd0d Overview of Steps:","text":"<ol> <li> <p>Load and Visualize Satellite Imagery</p> </li> <li> <p>Define Training Samples</p> </li> <li> <p>Merge and Sample Training Data</p> </li> <li> <p>Train the Classifier</p> </li> <li> <p>Classify the Image</p> </li> <li> <p>Visualize the Classified Map</p> </li> <li> <p>Export the Result</p> </li> <li> <p>(Optional) Accuracy Assessment</p> </li> </ol>"},{"location":"lulc/Supervised%20LULC%20Classification%20GEE/#step-1-load-and-visualize-satellite-imagery","title":"\ud83d\udef0\ufe0f Step 1: Load and Visualize Satellite Imagery","text":"<pre><code>// Define Area of Interest (AOI)\nvar aoi = ee.Geometry.Rectangle([85.0, 20.0, 86.0, 21.0]);\n\n// Load Sentinel-2 image\nvar image = ee.ImageCollection(\"COPERNICUS/S2_SR\")\n  .filterBounds(aoi)\n  .filterDate('2022-01-01', '2022-12-31')\n  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n  .median()\n  .clip(aoi);\n\n// Select bands\nvar bands = ['B2', 'B3', 'B4', 'B8']; // Blue, Green, Red, NIR\n\nMap.centerObject(aoi, 10);\nMap.addLayer(image.select(['B4', 'B3', 'B2']), {min: 0, max: 3000}, 'True Color Image');\n</code></pre>"},{"location":"lulc/Supervised%20LULC%20Classification%20GEE/#step-2-define-training-samples-manually-using-featurecollection","title":"\ud83e\uddea Step 2: Define Training Samples (Manually using FeatureCollection)","text":"<pre><code>// Example: Manually drawn polygons for different classes\nvar water = /* color: blue */ ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([85.1, 20.5]), {'landcover': 0}),\n  ee.Feature(ee.Geometry.Point([85.2, 20.6]), {'landcover': 0})\n]);\n\nvar forest = /* color: green */ ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([85.4, 20.5]), {'landcover': 1}),\n  ee.Feature(ee.Geometry.Point([85.5, 20.6]), {'landcover': 1})\n]);\n\nvar urban = /* color: red */ ee.FeatureCollection([\n  ee.Feature(ee.Geometry.Point([85.6, 20.5]), {'landcover': 2}),\n  ee.Feature(ee.Geometry.Point([85.7, 20.6]), {'landcover': 2})\n]);\n</code></pre>"},{"location":"lulc/Supervised%20LULC%20Classification%20GEE/#step-3-merge-and-sample-training-data","title":"\ud83d\udd17 Step 3: Merge and Sample Training Data","text":"<pre><code>var trainingPoints = water.merge(forest).merge(urban);\n\n// Sample the image at the locations of the training points\nvar training = image.select(bands).sampleRegions({\n  collection: trainingPoints,\n  properties: ['landcover'],\n  scale: 10\n});\n</code></pre>"},{"location":"lulc/Supervised%20LULC%20Classification%20GEE/#step-4-train-the-classifier-random-forest","title":"\ud83e\udde0 Step 4: Train the Classifier (Random Forest)","text":"<pre><code>var classifier = ee.Classifier.smileRandomForest(50).train({\n  features: training,\n  classProperty: 'landcover',\n  inputProperties: bands\n});\n</code></pre>"},{"location":"lulc/Supervised%20LULC%20Classification%20GEE/#step-5-classify-the-image","title":"\ud83d\uddfa\ufe0f Step 5: Classify the Image","text":"<pre><code>var classified = image.select(bands).classify(classifier);\n</code></pre>"},{"location":"lulc/Supervised%20LULC%20Classification%20GEE/#step-6-visualize-the-classified-map","title":"\ud83c\udfa8 Step 6: Visualize the Classified Map","text":"<pre><code>// Define a palette\nvar palette = ['0000FF', '00FF00', 'FF0000']; // water, forest, urban\n\nMap.addLayer(classified, {min: 0, max: 2, palette: palette}, 'LULC Classification');\n</code></pre>"},{"location":"lulc/Supervised%20LULC%20Classification%20GEE/#step-7-export-the-result","title":"\ud83d\udcbe Step 7: Export the Result","text":"<pre><code>Export.image.toDrive({\n  image: classified,\n  description: 'LULC_Classification',\n  scale: 10,\n  region: aoi,\n  maxPixels: 1e13\n});\n</code></pre>"},{"location":"lulc/Supervised%20LULC%20Classification%20GEE/#optional-step-8-accuracy-assessment","title":"\u2705 (Optional) Step 8: Accuracy Assessment","text":"<pre><code>// Split into training/testing datasets\nvar withRandom = training.randomColumn('random');\nvar trainingSet = withRandom.filter(ee.Filter.lt('random', 0.7));\nvar testingSet = withRandom.filter(ee.Filter.gte('random', 0.7));\n\n// Train new classifier\nvar trainedClassifier = ee.Classifier.smileRandomForest(50).train({\n  features: trainingSet,\n  classProperty: 'landcover',\n  inputProperties: bands\n});\n\n// Classify testing set\nvar validated = testingSet.classify(trainedClassifier);\n\n// Error Matrix\nvar errorMatrix = validated.errorMatrix('landcover', 'classification');\nprint('Confusion Matrix:', errorMatrix);\nprint('Overall Accuracy:', errorMatrix.accuracy());\n</code></pre>"},{"location":"lulc/Supervised%20LULC%20Classification%20GEE/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li> <p>You can use more landcover classes by adding more <code>FeatureCollection</code> for other types (e.g., agriculture, barren, grassland).</p> </li> <li> <p>You can use other classifiers like <code>smileCart()</code> or <code>smileSVM()</code> by changing the classifier function.</p> </li> <li> <p>Use NDVI or other indices if helpful as input features.</p> </li> </ul> <p>Would you like a version of this in Python (GEE Python API) as well?</p>"},{"location":"programming/","title":"Concepts-of-Programming","text":"<p>Concepts-of-Programming</p>"},{"location":"programming/02.Where%20to%20write%20code/","title":"Where to Write Code","text":"<p>=======================</p> <p>You can write code in various places, depending on your goals and preferences. Here are some options:</p>"},{"location":"programming/02.Where%20to%20write%20code/#1-text-editor","title":"1. Text Editor","text":"<p>A basic text editor like Notepad (Windows), TextEdit (Mac), or Gedit (Linux) can be used to write code. However, they lack advanced features and syntax highlighting.</p>"},{"location":"programming/02.Where%20to%20write%20code/#2-ide-integrated-development-environment","title":"2. IDE (Integrated Development Environment)","text":"<p>An IDE is a comprehensive tool that provides syntax highlighting, code completion, debugging, and project management. Popular IDEs include:</p> <ul> <li>PyCharm (Python)</li> <li>Eclipse (Java)</li> <li>Visual Studio (C++, C#, etc.)</li> <li>IntelliJ IDEA (Multi-language)</li> </ul>"},{"location":"programming/02.Where%20to%20write%20code/#3-code-editors","title":"3. Code Editors","text":"<p>Code editors are lightweight alternatives to IDEs, offering syntax highlighting, code completion, and debugging. Popular code editors include:</p> <ul> <li>Visual Studio Code (Multi-language)</li> <li>Sublime Text (Multi-language)</li> <li>Atom (Multi-language)</li> <li>Brackets (Web development)</li> </ul>"},{"location":"programming/02.Where%20to%20write%20code/#4-online-code-editors","title":"4. Online Code Editors","text":"<p>Online code editors allow you to write and execute code in the cloud. Popular options include:</p> <ul> <li>Repl.it (Multi-language)</li> <li>CodePen (Web development)</li> <li>Ideone (Multi-language)</li> <li>Google Colab (Python, Jupyter Notebooks)</li> </ul>"},{"location":"programming/02.Where%20to%20write%20code/#5-jupyter-notebooks","title":"5. Jupyter Notebooks","text":"<p>Jupyter Notebooks are web-based interactive environments for working with Python, R, and other languages. They're ideal for data science, scientific computing, and education.</p>"},{"location":"programming/02.Where%20to%20write%20code/#6-command-line","title":"6. Command Line","text":"<p>You can write code directly in the command line interface (CLI) using a terminal or command prompt. This is often used for quick scripts or executing code snippets.</p> <p>Choose the tool that best fits your needs, and happy coding!</p>"},{"location":"programming/02.Where%20to%20write%20code/#additional-resources","title":"Additional Resources","text":"<ul> <li>[Codecademy]</li> <li>[Coursera]</li> <li>[GitHub]</li> <li>[Stack Overflow]</li> </ul>"},{"location":"programming/03.What%20is%20id/","title":"Python <code>id()</code> Function","text":"<p>In Python, every data element or object stored in memory is referenced by a numeric value. These numeric values are useful for distinguishing objects from one another. This numeric value is referred to as the identity of an object. The Python <code>id()</code> function is used to return a unique identification value of an object stored in memory. This is similar to how unique memory addresses are assigned to variables and objects in languages like C.</p>"},{"location":"programming/03.What%20is%20id/#definition","title":"Definition","text":"<p>The Python <code>id()</code> function accepts a single parameter and returns a unique identity (integer value) of that object.</p>"},{"location":"programming/03.What%20is%20id/#python-id","title":"Python <code>id()</code>","text":"<p>When we input any object as a parameter into the Python <code>id()</code> function, the function assigns an identity to the object. This identity is an integer value that remains constant during the lifetime of the program and cannot be modified. Each object has its own unique identity assigned to it, which differentiates it from other objects.</p>"},{"location":"programming/03.What%20is%20id/#syntax","title":"Syntax","text":"<p>```python id(object)</p> <p>Syntax \u2013</p> <p>id(object) where,</p> <p>object = int, float, string, tuple, list, class, function, etc.</p> <p>Note \u2013 The Python id() function only takes a single parameter object.</p> <p>How id() works? Python can utilize an object\u2019s id to cache the values of its variables. This approach for accessing cached items via id() improves Python performance. As a result, many variables may refer to the same object and have the same id() value if their values are the same.</p> <p>Basic Example \u2013</p> <p>Copy Code</p>"},{"location":"programming/03.What%20is%20id/#python-program-to-illustrate-id-function","title":"Python program to illustrate id() function","text":"<p>a = 10 b = 11 c = 130.56 text = 'Hello'</p> <p>print('ID of a =', id(a)) print('ID of b =', id(b)) print('ID of c =', id(c)) print('ID of text =', id(text)) Output \u2013</p> <p>ID of a = 9781088 ID of b = 9781120 ID of c = 139832028993808 ID of text = 139894857394352 Notice in the above program, for the variables holding integer values 10 and 11, there is an identity difference of only 32.</p> <p>Why so?</p> <p>Understand that the id(11) is the next block after id(10) in the memory location. And since integer values in Python are 4 bytes i.e. 32 bits, which is the exact difference between the 2 ID numbers. This also means that Python stores integers in a sequence of blocks that are spaced equally. Hence providing an efficient memory allocation process.</p> <p>More Examples on id() An instance where ID\u2019s are unidentical \u2013 Example \u2013</p> <p>Copy Code</p>"},{"location":"programming/03.What%20is%20id/#python-program-to-illustrate-id-function_1","title":"Python program to illustrate id() function","text":"<p>a = 10 b = 14 text1 = 'Hello' text2 = 'Hi'</p> <p>print(id(a) == id(b)) print(id(text1) == id(text2)) Output \u2013</p> <p>False False Here the output is FALSE in both the print statements because each variable has a different value assigned to it, and the Python id() function will allocate a unique identification number to each of them.</p> <p>An instance where ID\u2019s are identical \u2013 There are few cases when the Python id() function assigns the exact same identification number to multiple objects. This happens when the objects, like integers, floats, strings, tuples are immutable. The id() function works on the principle of caching which in turn works only on the objects that are immutable. This helps Python preserve memory.</p> <p>Example \u2013</p> <p>Copy Code</p>"},{"location":"programming/03.What%20is%20id/#python-program-to-illustrate-id-function_2","title":"Python program to illustrate id() function","text":"<p>txt1 = 'Python' txt2 = 'Python'</p> <p>my_tuple1 = ('A', 'B', 'C') my_tuple2 = ('A', 'B', 'C')</p> <p>print(id(txt1)) print(id(txt2))</p> <p>print(id(my_tuple1)) print(id(my_tuple2)) Output \u2013</p> <p>140562250770160 140562250770160 140562250322496 140562250322496 Python id() function on Immutable objects \u2013 On immutable objects like lists and dictionaries, the id() function allocates distinctive identity numbers.</p> <p>Example \u2013</p> <p>Copy Code</p>"},{"location":"programming/03.What%20is%20id/#python-program-to-illustrate-id-function_3","title":"Python program to illustrate id() function","text":"<p>my_list1 = [1, 2, 3, 4] my_list2 = [1, 2, 3, 4]</p> <p>my_dict1 = {1: 'Hi', 2: 'Hello'} my_dict2 = {1: 'Hi', 2: 'Hello'}</p> <p>print(id(my_list1)) print(id(my_list2)) print(id(my_dict2)) print(id(my_dict2)) Output \u2013</p> <p>140117770739136 140117770107456 140117770935360 140117770935360 Using id() on Custom Objects Python id() function can also be used on user-defined classes. Let\u2019s take a simple example to understand this.</p> <p>Example \u2013</p> <p>Copy Code</p>"},{"location":"programming/03.What%20is%20id/#python-program-to-illustrate-id-function-in-class","title":"Python program to illustrate id() function in class","text":"<p>class Car:      name = 'Ford'      price = 30000</p> <p>c1 = Car() print(id(c1))</p> <p>c2 = Car() print(id(c2))</p> <p>c3 = Car() c3.name = 'Audi' print(id(c3.name)) Output \u2013</p> <p>140030909930752 140030909344928 140030908951088 Frequently Asked Questions Q1. What is the id in Python? The \u2018id\u2019 in Python stands for Identity. Each and every object in Python when stored into the memory is being allocated a unique identification number that helps the Python compiler to perform better and utilize memory efficiently. Each object has its own unique identity assigned to it as an integer number which differentiates it from other objects.</p> <p>Q2. What does id() do in Python? The Python id() function accepts a single parameter and returns a unique identity (integer value) of that object. When we input any object as a parameter into the Python id() function, the id() function assigns an identity to the object. This identity is an integer value that remains constant during the lifetime of the program.</p> <p>Example \u2013</p> <p>Copy Code</p>"},{"location":"programming/03.What%20is%20id/#program-to-illustrate-python-id-function","title":"Program to illustrate Python id() function","text":"<p>a = 12.46 txt = 'Hello World' items = ['soap', 'brush', 'deodorant']</p> <p>print(id(a)) print(id(12.46)) print(id(txt)) print(id(items)) Output \u2013</p> <p>139996850014480 139996850014480 139996849567984 139996850200128 Note \u2013 Here, the id for variable a and float value 12.46 is the same. This is because both are sharing the same values and hence Python id() function assigns them with the equivalent identity number.</p> <p>Q3. What is the return type of id()? The syntax for Python id() function is as below \u2013</p> <p>id(object) where,</p> <p>object = int, float, string, tuple, list, class, function, etc.</p> <p>The id() function in Python returns every object\u2019s \u201cidentity.\u201d It returns a unique integer value that remains constant throughout the program execution time and cannot be modified or changed.</p> <p>Share with friends FacebookTwitterWhatsApp Previous Python args &amp; *kwargs</p>"},{"location":"programming/04.Variables/","title":"What is variable in programming","text":""},{"location":"programming/04.Variables/#types-of-variabls-in-programming","title":"Types of variabls in programming","text":""},{"location":"programming/07.Dictionaries/","title":"Dictionaries in Google Earth Engine","text":"<p>=====================================</p> <p>Dictionaries in Google Earth Engine (GEE) are key-value pair data structures used to store and organize data. They are implemented as <code>ee.Dictionary</code> objects and are similar to JavaScript objects or Python dictionaries.</p>"},{"location":"programming/07.Dictionaries/#creating-dictionaries","title":"Creating Dictionaries","text":""},{"location":"programming/07.Dictionaries/#1-using-eedictionary","title":"1. Using <code>ee.Dictionary()</code>","text":"<pre><code>var dict = ee.Dictionary({\n  'name': 'John Doe',\n  'age': 30,\n  'city': 'New York'\n});\nprint('Dictionary:', dict);\n</code></pre>"},{"location":"programming/07.Dictionaries/#2-from-a-list-of-keys-and-values","title":"2. From a List of Keys and Values","text":"<pre><code>var keys = ['a', 'b', 'c'];\nvar values = [1, 2, 3];\nvar dictFromLists = ee.Dictionary.fromLists(keys, values);\nprint('Dictionary from lists:', dictFromLists);\n</code></pre>"},{"location":"programming/07.Dictionaries/#accessing-dictionary-values","title":"Accessing Dictionary Values","text":""},{"location":"programming/07.Dictionaries/#1-using-get","title":"1. Using get()","text":"<pre><code>var name = dict.get('name');\nprint('Name:', name);\n</code></pre>"},{"location":"programming/07.Dictionaries/#2-using-getnumber-getstring-etc","title":"2. Using getNumber(), getString(), etc.","text":"<pre><code>var age = dict.getNumber('age');\nprint('Age as number:', age);\n</code></pre>"},{"location":"programming/07.Dictionaries/#modifying-dictionaries","title":"Modifying Dictionaries","text":"<p>Dictionaries in GEE are immutable, but you can create new dictionaries with modifications. 1. Adding or Updating Key-Value Pairs <pre><code>var updatedDict = dict.set('occupation', 'Engineer');\nprint('Updated Dictionary:', updatedDict);\n</code></pre> 2. Removing Key-Value Pairs <pre><code>var reducedDict = dict.remove(['age']);\nprint('Dictionary with age removed:', reducedDict);\n</code></pre></p>"},{"location":"programming/07.Dictionaries/#dictionary-operations","title":"Dictionary Operations","text":"<ol> <li>Combining Dictionaries <pre><code>var dict1 = ee.Dictionary({'a': 1, 'b': 2});\nvar dict2 = ee.Dictionary({'c': 3, 'd': 4});\nvar combinedDict = dict1.combine(dict2);\nprint('Combined Dictionary:', combinedDict);\n</code></pre></li> <li>Checking for Keys <pre><code>var hasKey = dict.contains('name');\nprint('Dictionary contains \"name\":', hasKey);\n</code></pre></li> <li>Getting All Keys or Values <pre><code>var allKeys = dict.keys();\nvar allValues = dict.values();\nprint('All Keys:', allKeys);\nprint('All Values:', allValues);\n</code></pre></li> </ol>"},{"location":"programming/07.Dictionaries/#advanced-usage","title":"Advanced Usage","text":"<ol> <li>Mapping Over Dictionary Values <pre><code>var doubledValues = dict.map(function(key, value) {\n  return ee.Number(value).multiply(2);\n});\nprint('Doubled numeric values:', doubledValues);\n````\n2. Using Dictionaries with Image Properties\n``` JavaScript\nvar image = ee.Image('LANDSAT/LC08/C02/T1_L2/LC09_044034_20230215')\n  .set({\n    'cloud_cover': 10,\n    'sensor': 'OLI',\n    'acquisition_date': '2023-02-15'\n  });\n\nvar properties = image.toDictionary();\nprint('Image properties as dictionary:', properties);\n</code></pre></li> </ol>"},{"location":"programming/07.Dictionaries/#3-creating-a-featurecollection-from-a-dictionary","title":"3. Creating a FeatureCollection from a Dictionary","text":"<pre><code>var dictFeature = ee.Feature(null, dict);\nvar dictFeatureCollection = ee.FeatureCollection([dictFeature]);\nprint('FeatureCollection from Dictionary:', dictFeatureCollection);\n</code></pre>"},{"location":"programming/07.Dictionaries/#best-practices","title":"Best Practices","text":"<ol> <li>Use Descriptive Key Names Use descriptive key names for clarity.</li> <li>Immutability Be aware of the immutability of dictionaries in GEE.</li> <li>Getter Methods Use appropriate getter methods (getString(), getNumber(), etc.) when you know the value type.</li> <li>Organizing Metadata Leverage dictionaries for organizing metadata and properties in your Earth Engine workflows. Conclusion</li> </ol> <p>Dictionaries in Google Earth Engine are versatile data structures that can be used in various scenarios, from simple data organization to complex image and feature property management.</p>"},{"location":"programming/09.FeatureCollection/","title":"Understanding FeatureCollection in Google Earth Engine","text":"<p>=====================================================</p> <p>This example demonstrates key operations on a <code>FeatureCollection</code>, including filtering, mapping, and aggregating.</p>"},{"location":"programming/09.FeatureCollection/#loading-a-featurecollection","title":"Loading a FeatureCollection","text":"<p><pre><code>// Import the country feature collection\nvar countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nprint(countries);\nprint(countries.first());\n</code></pre> Here, we load a FeatureCollection containing country boundaries. The print statements show: The entire FeatureCollection (metadata) The first feature in the collection</p>"},{"location":"programming/09.FeatureCollection/#featurecollections-overview","title":"FeatureCollections Overview","text":"<p>FeatureCollections are sets of features, where each feature has a geometry and properties. Mapping over a FeatureCollection</p> <p><pre><code>// Map a function to get the country_na property of each feature \nvar names = countries.map(function(x) {\n  // Return a new feature with only the country_na property\n  return ee.Feature(null, {'country_na': x.get('country_co')});\n});\nprint(names);\n</code></pre> This demonstrates the map function on a FeatureCollection: Applies the given function to each feature in the collection. Creates a new feature for each country, containing only the 'country_na' property. Result is a new FeatureCollection with simplified features.</p>"},{"location":"programming/09.FeatureCollection/#aggregating-data","title":"Aggregating Data","text":"<p><pre><code>// Convert the result to a list\nvar list = names.aggregate_array('country_na');\n// Print the list\nprint(list, 'country');\n</code></pre> The aggregate_array function is used here to: Extract a specific property ('country_na') from each feature. Combine these values into a single list.</p>"},{"location":"programming/09.FeatureCollection/#filtering-featurecollections","title":"Filtering FeatureCollections","text":"<p><pre><code>var india = countries.filter(ee.Filter.eq('country_na', 'Nepal'));\nMap.addLayer(india);\n</code></pre> This demonstrates filtering a FeatureCollection: filter is used with an ee.Filter to select features meeting specific criteria. Selects the feature where 'country_na' equals 'Nepal'. Result is added to the map for visualization.</p>"},{"location":"programming/09.FeatureCollection/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":"<ol> <li>Loading a FeatureCollection Using ee.FeatureCollection() to load data.</li> <li>Inspecting FeatureCollections Using print() to examine the collection and its features.</li> <li>Mapping over a FeatureCollection Using map() to apply a function to each feature.</li> <li>Creating new Features Using ee.Feature() to create features with specific properties.</li> <li>Aggregating data Using aggregate_array() to collect values from all features.</li> <li>Filtering FeatureCollections Using filter() with ee.Filter to select specific features.</li> <li>Visualization Adding filtered features to the map.</li> </ol>"},{"location":"programming/09.FeatureCollection/#conclusion","title":"Conclusion","text":"<p>FeatureCollections are versatile data structures in Earth Engine, useful for working with vector data like country boundaries, points of interest, or any data with geometric and non-geometric properties.</p>"},{"location":"programming/1.%20What%20is%20Programming/","title":"What is Programming?","text":"<p>Programming sounds scary, but it's simpler than you think. At its core, programming is just giving instructions.</p>"},{"location":"programming/1.%20What%20is%20Programming/#the-recipe-analogy","title":"The Recipe Analogy","text":"<p>Think of a computer as a Chef who is very fast, but not very smart. It needs exact instructions to bake a cake.</p> <pre><code>graph TD\n    A[Start: Make Sandwich] --&gt; B[Get Bread]\n    B --&gt; C[Add Cheese]\n    C --&gt; D[Add Ham]\n    D --&gt; E[Close Sandwich]\n    E --&gt; F[Eat!]\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style F fill:#9f9,stroke:#333,stroke-width:2px</code></pre> <p>A program is just a flowchart of steps, like this recipe.</p> <p>If you tell a friend \"Make a sandwich,\" they know what to do. If you tell a computer, you have to list every single step like above.</p> <p>Programming is simply writing that recipe in a language the computer understands.</p>"},{"location":"programming/1.%20What%20is%20Programming/#key-parts-of-programming","title":"Key Parts of Programming","text":"<p>Just like recipes have ingredients and steps, code has Data and Logic.</p>"},{"location":"programming/1.%20What%20is%20Programming/#1-variables-the-ingredients","title":"1. Variables (The Ingredients)","text":"<p>Variables are containers that hold information.</p> <p> Think of variables as Lego bricks. You can store them, stack them, and build new things.</p> <ul> <li>String: Text (e.g., \"Hello World\")</li> <li>Number: Math (e.g., 42, 3.14)</li> <li>List: A collection (e.g., <code>['Apple', 'Banana', 'Cherry']</code>)</li> </ul>"},{"location":"programming/1.%20What%20is%20Programming/#2-functions-the-tools","title":"2. Functions (The Tools)","text":"<p>A function is a mini-recipe. Instead of writing \"Mix flour, sugar, and eggs\" every time, you create a function called <code>MakeDough()</code>.</p> <p>In Google Earth Engine, we use functions for everything:</p> <ul> <li><code>Map.addLayer()</code> tells the computer to Draw something.</li> <li><code>image.clip()</code> tells the computer to Cut an image.</li> </ul>"},{"location":"programming/1.%20What%20is%20Programming/#3-logic-the-decisions","title":"3. Logic (The Decisions)","text":"<p>Sometimes the recipe changes. \"IF it is vegan, THEN skip the eggs.\"</p> <pre><code>graph TD\n    A[Start: Bake Cake] --&gt; B{Is it Vegan?}\n    B -- Yes --&gt; C[Use Apple Sauce]\n    B -- No --&gt; D[Use Eggs]\n    C --&gt; E[Mix Batter]\n    D --&gt; E\n    E --&gt; F[Bake]\n    style B fill:#ffd,stroke:#333,stroke-width:2px</code></pre> <p>Computers follow paths based on Yes/No questions. This is called Logic.</p>"},{"location":"programming/1.%20What%20is%20Programming/#why-google-earth-engine","title":"Why Google Earth Engine?","text":"<p>Usually, programming involves setting up complex software. Google Earth Engine is different.</p> <ul> <li>It runs in your browser (Chrome/Firefox).</li> <li>You don't need to install anything.</li> <li>You use functions that Google already wrote for you (like \"Cloud Masking\" or \"Calculate NDVI\").</li> </ul> <p>You act as the Head Chef, sequencing these powerful tools to create amazing maps!</p>"},{"location":"programming/10.ImageCollection/","title":"Detailed Explanation of Landsat 8 ImageCollection Processing","text":"<p>===========================================================</p>"},{"location":"programming/10.ImageCollection/#1-filtering-the-imagecollection","title":"1. Filtering the ImageCollection","text":"<p><pre><code>var dataset = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n  .filterDate('2017-01-01', '2017-01-10')\n  .filter(ee.Filter.lte('CLOUD_COVER', 1));\n</code></pre> This code: Loads the Landsat 8 TOA (Top of Atmosphere) reflectance ImageCollection. Filters images to a date range (January 1-10, 2017) using filterDate(). Further filters images to include only those with cloud cover \u2264 1% using filter(ee.Filter.lte()).</p>"},{"location":"programming/10.ImageCollection/#2-inspecting-the-dataset","title":"2. Inspecting the Dataset","text":"<p><pre><code>print(dataset);\nprint(dataset.first());\n</code></pre> These print statements: Display metadata about the entire filtered ImageCollection. Show details of the first image in the collection.</p>"},{"location":"programming/10.ImageCollection/#3-extracting-image-ids","title":"3. Extracting Image IDs","text":"<p><pre><code>var names = dataset.map(function(image){\n   var id = image.get('system:index');\n   return ee.Feature(null, {'id': id});\n});\n</code></pre> This map() function: Iterates over each image in the collection. Extracts the 'system:index' (a unique identifier) of each image. Creates a new feature with this ID as a property. Returns a FeatureCollection where each feature represents an image's ID.</p>"},{"location":"programming/10.ImageCollection/#4-aggregating-ids-into-a-list","title":"4. Aggregating IDs into a List","text":"<p><pre><code>var nameList = names.aggregate_array('id');\nprint(nameList, 'names of the image');\n</code></pre> This code: Uses aggregate_array() to collect all 'id' values into a single list. Prints this list, showing the IDs of all images in the collection.</p>"},{"location":"programming/10.ImageCollection/#5-preparing-image-for-visualization","title":"5. Preparing Image for Visualization","text":"<p><pre><code>var trueColor432 = dataset.select(['B4', 'B3', 'B2']);\n</code></pre> This selects specific bands from the ImageCollection: B4 (Red), B3 (Green), and B2 (Blue) for a true color composite.</p>"},{"location":"programming/10.ImageCollection/#6-setting-visualization-parameters","title":"6. Setting Visualization Parameters","text":"<p><pre><code>var trueColor432Vis = {\n  min: 0.0,\n  max: 0.4,\n};\n</code></pre> This object defines visualization parameters: Sets minimum and maximum values for color stretching. Values are in reflectance units (0-1 for TOA data).</p>"},{"location":"programming/10.ImageCollection/#7-map-visualization","title":"7. Map Visualization","text":"<p><pre><code>Map.setCenter(6.746, 46.529, 6);\nMap.addLayer(trueColor432, trueColor432Vis, 'True Color (432)');\n</code></pre> These functions: Set the map center to specific coordinates (near Geneva, Switzerland) with a zoom level of 6. Add the true color composite to the map with the specified visualization parameters.</p>"},{"location":"programming/10.ImageCollection/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":"<ol> <li>ImageCollection Filtering Using date and metadata filters to select specific images.</li> <li>Information Extraction Using map() to extract information from each image in a collection.</li> <li>Data Aggregation Using aggregate_array() to compile information from multiple images.</li> <li>Band Selection Choosing specific spectral bands for analysis or visualization.</li> <li>Visualization Parameters Setting up parameters to control how the image is displayed.</li> <li>Map Interaction Setting the map view and adding layers for visualization.</li> </ol>"},{"location":"programming/10.ImageCollection/#conclusion","title":"Conclusion","text":"<p>This script showcases a typical workflow in Earth Engine: loading data, filtering it, extracting information, and visualizing the results. It's particularly useful for analyzing satellite imagery over specific time periods and locations.</p>"},{"location":"programming/2.%20Data%20Types/","title":"Understanding Data Types (The Ingredients)","text":"<p>Just like a recipe has flour, sugar, and eggs, programming has strictly defined types of ingredients. A computer cannot act on \"flour\" unless it knows it's a \"Powder\".</p> <p>In Google Earth Engine, we use special types designed for maps.</p>"},{"location":"programming/2.%20Data%20Types/#basic-types-standard-programming","title":"Basic Types (Standard Programming)","text":"<p>These are common to both JavaScript and Python.</p> <ol> <li>String: Text (always in quotes).</li> <li><code>'Hello World'</code></li> <li> <p><code>'LANDSAT/LC08/C02/T1_L2'</code></p> </li> <li> <p>Number: Values for math.</p> </li> <li><code>42</code> (Integer)</li> <li> <p><code>3.14</code> (Decimal/Float)</p> </li> <li> <p>List: A collection of items (in square brackets).</p> </li> <li><code>['Apples', 'Bananas', 'Cherries']</code></li> <li> <p><code>[1, 2, 3]</code></p> </li> <li> <p>Dictionary (Object in JS): Key-Value pairs (like an address book).</p> </li> <li><code>{'name': 'Paris', 'population': 2161000}</code></li> <li><code>{'color': 'red', 'size': 10}</code></li> </ol>"},{"location":"programming/2.%20Data%20Types/#earth-engine-types-geospatial","title":"Earth Engine Types (Geospatial)","text":"<p>These are the special containers Google created for satellite data.</p> <ol> <li>Image (<code>ee.Image</code>)</li> <li>A single picture (Raster).</li> <li> <p>Contains bands (Red, Green, Blue, NIR).</p> </li> <li> <p>ImageCollection (<code>ee.ImageCollection</code>)</p> </li> <li>A folder of many images.</li> <li> <p>Example: All Landsat photos taken in 2023.</p> </li> <li> <p>Feature (<code>ee.Feature</code>)</p> </li> <li>A single shape (Vector) with data attached.</li> <li> <p>Example: The border of France.</p> </li> <li> <p>FeatureCollection (<code>ee.FeatureCollection</code>)</p> </li> <li>A group of features.</li> <li>Example: All countries in the world.</li> </ol>"},{"location":"programming/2.%20Data%20Types/#why-does-this-matter","title":"Why does this matter?","text":"<p>You can't mix them up!</p> <ul> <li>You can Clip an Image with a Feature.</li> <li>You can Filter an ImageCollection with a Geometry.</li> <li>But you cannot Add an Image to a Number directly (without using special functions).</li> </ul> <p>Think of it like cooking: You can whisk eggs, but you can't whisk a rock!</p>"},{"location":"programming/3.%20Functions/","title":"Working with Functions (Custom Tools)","text":"<p>A Function is like a mini-recipe. Instead of writing \"Mix flour, sugar, and eggs\" every time, you create a function called <code>MakeDough()</code>.</p>"},{"location":"programming/3.%20Functions/#why-use-functions","title":"Why use functions?","text":"<p>They save time! Instead of repeating yourself, you write the logic once and reuse it.</p>"},{"location":"programming/3.%20Functions/#example-a-simple-calculator","title":"Example: A Simple Calculator","text":"<p>Let's make a function that adds two numbers.</p> JavaScriptPython <pre><code>// Define the function\nvar addNumbers = function(a, b) {\n  return a + b;\n};\n\n// Use it!\nvar result = addNumbers(5, 10);\nprint(result); // Output: 15\n</code></pre> <pre><code># Define the function\ndef add_numbers(a, b):\n  return a + b\n\n# Use it!\nresult = add_numbers(5, 10)\nprint(result) # Output: 15\n</code></pre>"},{"location":"programming/3.%20Functions/#example-a-cloud-masking-function-real-world","title":"Example: A Cloud Masking Function (Real World)","text":"<p>In Earth Engine, we use functions mostly to hide clouds. This function takes an image with clouds, and returns a clean image.</p> JavaScriptPython <pre><code>// Define the function\nvar maskClouds = function(image) {\n  // Find the clouds using the QA band\n  var qa = image.select('QA_PIXEL');\n  var cloudMask = qa.bitwiseAnd(1 &lt;&lt; 3).eq(0); // Complex logic hidden here!\n\n  // Update the mask (hide clouds)\n  return image.updateMask(cloudMask);\n};\n\n// Now apply it to ANY image!\nvar cleanImage = maskClouds(cloudyImage);\n</code></pre> <pre><code># Define the function\ndef mask_clouds(image):\n  # Find the clouds using the QA band\n  qa = image.select('QA_PIXEL')\n  cloud_mask = qa.bitwiseAnd(1 &lt;&lt; 3).eq(0) # Complex logic hidden here!\n\n  # Update the mask (hide clouds)\n  return image.updateMask(cloud_mask)\n\n# Now apply it to ANY image!\nclean_image = mask_clouds(cloudy_image)\n</code></pre>"},{"location":"programming/3.%20Functions/#pro-tip","title":"Pro Tip","text":"<p>Keep your functions simple. One function should do one thing well.</p>"},{"location":"programming/4.%20Loops/","title":"Loops (Doing Things Again and Again)","text":"<p>Imagine you want to calculate the NDVI for every day in a year. Writing code 365 times is boring. That\u2019s why we use Loops.</p> <p>In standard programming, you might write code like: \"For Day 1, do this. For Day 2, do this.\"</p>"},{"location":"programming/4.%20Loops/#the-map-function-earth-engines-loop","title":"The <code>map()</code> Function (Earth Engine's Loop)","text":"<p>In Google Earth Engine, we use a special kind of loop called <code>.map()</code>. Think of it as an Assembly Line.</p> <ol> <li>You create a master instruction (a Function).</li> <li>You feed a collection of items (Images) into the line.</li> <li>The computer applies the instruction to every item at the same time.</li> </ol>"},{"location":"programming/4.%20Loops/#example-the-assembly-line","title":"Example: The Assembly Line","text":"<p>Let's assume we have a box of 10 apples (<code>ImageCollection</code>) and we want to peel them (<code>Function</code>).</p> JavaScriptPython <pre><code>// The collection: 3 years of images\nvar collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2');\n\n// The instruction: Calculate NDVI for one image\nvar addNDVI = function(image) {\n  return image.normalizedDifference(['SR_B5', 'SR_B4']);\n};\n\n// The loop: Apply instruction to all images\nvar processedCollection = collection.map(addNDVI);\n</code></pre> <pre><code># The collection: 3 years of images\ncollection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n\n# The instruction: Calculate NDVI for one image\ndef add_ndvi(image):\n  return image.normalizedDifference(['SR_B5', 'SR_B4'])\n\n# The loop: Apply instruction to all images\nprocessed_collection = collection.map(add_ndvi)\n</code></pre>"},{"location":"programming/4.%20Loops/#why-map-instead-of-for-loops","title":"Why <code>.map()</code> instead of <code>for</code> loops?","text":"<p>Standard <code>for</code> loops run on your computer (Client-side). <code>.map()</code> runs on Google's supercomputers (Server-side). It is much faster for processing thousands of satellite images.</p>"}]}