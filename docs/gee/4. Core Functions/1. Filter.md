# Filtering — Finding What You Need

In Google Earth Engine, datasets often contain **thousands of images** spanning decades.
A **filter** lets you zero in on exactly the data you need — by date, location, cloud cover, or any other property.

Think of it like searching a library. The catalog has a million books, but you only want books from 1990, written in English, about geography.

```mermaid
graph LR
    A["Huge ImageCollection\n(1000s of images)"] -->|.filterDate()| B["Date range subset"]
    B -->|.filterBounds()| C["Spatial subset"]
    C -->|.filter()| D["Property subset\n(cloud < 10%)"]
    D --> E["✅ Clean, focused dataset"]
    style A fill:#f9f,stroke:#333
    style E fill:#9f9,stroke:#333
```

---

## The Three Essential Filters

### 1. `.filterDate()` — Filter by Time

Selects images captured within a specific date range.

=== "JavaScript"
    ```javascript
    var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
      .filterDate('2023-01-01', '2023-12-31');

    print('Images in 2023:', collection.size());
    ```

=== "Python"
    ```python
    collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \
        .filterDate('2023-01-01', '2023-12-31')

    print('Images in 2023:', collection.size().getInfo())
    ```

---

### 2. `.filterBounds()` — Filter by Location

Selects only images that **overlap** with a geometry (point, polygon, or feature).

=== "JavaScript"
    ```javascript
    // Define a study area — Bhubaneswar, Odisha
    var point = ee.Geometry.Point([85.82, 20.30]);

    var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
      .filterDate('2023-01-01', '2023-12-31')
      .filterBounds(point);

    print('Images over Bhubaneswar:', collection.size());
    ```

=== "Python"
    ```python
    # Define a study area — Bhubaneswar, Odisha
    point = ee.Geometry.Point([85.82, 20.30])

    collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \
        .filterDate('2023-01-01', '2023-12-31') \
        .filterBounds(point)

    print('Images over Bhubaneswar:', collection.size().getInfo())
    ```

---

### 3. `.filter()` — Filter by Any Property

The most flexible filter. Uses `ee.Filter` to target any image metadata property.

=== "JavaScript"
    ```javascript
    var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
      .filterDate('2023-01-01', '2023-12-31')
      .filterBounds(ee.Geometry.Point([85.82, 20.30]))
      .filter(ee.Filter.lt('CLOUD_COVER', 10)); // less than 10% clouds

    print('Low-cloud images:', collection.size());
    ```

=== "Python"
    ```python
    collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \
        .filterDate('2023-01-01', '2023-12-31') \
        .filterBounds(ee.Geometry.Point([85.82, 20.30])) \
        .filter(ee.Filter.lt('CLOUD_COVER', 10))

    print('Low-cloud images:', collection.size().getInfo())
    ```

---

## Common `ee.Filter` Methods

| Filter Method | What it Does | Example |
| :--- | :--- | :--- |
| `ee.Filter.lt(prop, val)` | Less than | Cloud cover < 20% |
| `ee.Filter.gt(prop, val)` | Greater than | NDVI > 0.3 |
| `ee.Filter.eq(prop, val)` | Equal to | WRS_PATH equals 142 |
| `ee.Filter.bounds(geometry)` | Overlaps geometry | Within your study area |
| `ee.Filter.date(start, end)` | Date range | Between two dates |
| `ee.Filter.calendarRange(1,3,'month')` | By month/season | January to March only |

---

## Combining Filters

You can chain filters (one after another) or combine them with logical `And`/`Or`.

=== "JavaScript"
    ```javascript
    // Chain: each .filter() narrows it further (AND logic)
    var clean = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
      .filterDate('2023-06-01', '2023-09-30')
      .filterBounds(ee.Geometry.Point([85.82, 20.30]))
      .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5));

    // Combine with ee.Filter.and()
    var combined = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
      .filter(ee.Filter.and(
        ee.Filter.date('2023-06-01', '2023-09-30'),
        ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5)
      ));

    print('Monsoon Sentinel-2 (< 5% clouds):', clean.size());
    ```

=== "Python"
    ```python
    # Chain: each .filter() narrows it further (AND logic)
    clean = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') \
        .filterDate('2023-06-01', '2023-09-30') \
        .filterBounds(ee.Geometry.Point([85.82, 20.30])) \
        .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5))

    # Combine with ee.Filter.and_()
    combined = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') \
        .filter(ee.Filter.And(
            ee.Filter.date('2023-06-01', '2023-09-30'),
            ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5)
        ))

    print('Result:', clean.size().getInfo())
    ```

---

## Real-World Example: Seasonal Analysis

Getting cloud-free Landsat images for the dry season (November–March) over a watershed:

=== "JavaScript"
    ```javascript
    var watershed = ee.Geometry.Polygon([
      [[85.5, 20.1], [85.5, 20.6], [86.1, 20.6], [86.1, 20.1]]
    ]);

    var drySeason = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
      .filterDate('2022-11-01', '2023-03-31')
      .filterBounds(watershed)
      .filter(ee.Filter.lt('CLOUD_COVER', 15))
      .filter(ee.Filter.calendarRange(11, 3, 'month'));

    print('Dry Season Images:', drySeason.size());
    Map.centerObject(watershed, 10);
    Map.addLayer(drySeason.median(), {
      bands: ['SR_B4', 'SR_B3', 'SR_B2'],
      min: 7000, max: 30000
    }, 'Dry Season Composite');
    ```

=== "Python"
    ```python
    watershed = ee.Geometry.Polygon([[
        [85.5, 20.1], [85.5, 20.6], [86.1, 20.6], [86.1, 20.1]
    ]])

    dry_season = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \
        .filterDate('2022-11-01', '2023-03-31') \
        .filterBounds(watershed) \
        .filter(ee.Filter.lt('CLOUD_COVER', 15)) \
        .filter(ee.Filter.calendarRange(11, 3, 'month'))

    print('Dry Season Images:', dry_season.size().getInfo())
    ```

---

!!! tip "Always Filter First!"
    Always apply `.filterDate()` and `.filterBounds()` **before** any computation. This limits the data Earth Engine needs to process and prevents memory or timeout errors.

!!! warning "Filter ≠ Clip"
    `.filterBounds()` selects images that **overlap** your area — the images still cover their full original extent. To cut images to your actual boundary, use `.clip()` **after** filtering.
